/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Merhaba Dünya C++ programı
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
    cout << "Hello World" << endl;
    
    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ ilk standardı ISO/IEC tarafından 1998 yılında oluşturuldu (ISO/IEC 14882: 1998).Bunu 2003 yılındaki standartlar izledi. 2003 standartları daha çok düzeltme niteliğinde
	idi. Daha sonra C++'ın 2011 yılında yeni bir standardı oluşturuldu. Bu standartlarla C++'a pek çok yenilik eklendi. 2011 standartlarını 2014, 2017, 2020 standartları izşedi.
	Şu anda üzerinde çalışılmakta olan standart 2023'tür. Bu standartlar halk arasında C++98, C++03, C++11, C++14, C++17, C++20 ve C++23 olarak bilinmektedir. 

	C Progralama Dilinin ilk standartları "ISO/IEC 9899: 1990" ismiyle 1990 yılında ISO tarafından oluşturulmuştur. Buna halk arasında C90 denilmektedir. C'nin 1999 yılında
	yeni bir standardı daha oluşturuldu. Buna C99 denilmektedir. Daha sonra C'nin 2011 yılında yeni bir standardı oluşturulmuştur. Buna da C11 denilmektedir. Nihayet C'nin 2017
	yılında son sürümü yayınlandı. Buna da C17 denilmektedir. Ancak bu C17'de yeni özellikler eklenmedi. Yalnızca C11'deki bozukluklar düzeltildi.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
  	Bir C++ programı IDE'ler kullanılarak kolayca derlenip, link işlemi yapılarak çalıştırılabilir. Windows sistemlerinde en yaygın kullanılan IDE Microsfoft'un
	Visal Studio isimli IDE'sidir. C++ için diğer bir IDE seçeneği "Qt-Creator" olabilir. Bu IDE "cross platform" biçimindedir. Yani Windows, Mac OS X ve Linux sitemlerinde
	benzer biçimde kullanılabilmektedir. Tabii aslında derleyiciler komut satırından çalıştırılan programlar biçiminde oluşturulmuştur. Microsft'un C ve C++ derleyicisi
	"cl.exe" isimli programdır. Bu derleyici ile derleme komut satırında şöyle yapılabilir:

	cl sample.cpp

	Derleyici default durumda derleme işleminden sonra bağlayıcı (linker) programı da çalıştırır. İstersek çalıştırılabilen dosyanın ismini /Fe seçeneği ile 
	değiştirebiliriz:

	cl /Fe:test.exe sample.cpp

	UNIX/Linux ve MAC sistemlerinde GNU'nun g++ ve clang++ derleyicileri kullanılabilmektedir. Komut satırından derleme tipik olarak şöyle yapılmaktadır:

	g++ sample.cpp 

	Burada derleyici derleme işlemindne sonra yine bağlayıcı ptogramı çalıştırmaktadır. Bu durumda çalıştırılabilen dosya "a.out" biçiminde oluşur. Çalıştırılabilen dosyanın
	ismini değiştirmek için -o seçeneği kullanılmaktadır. Örneğin:

	g++ -o sample sample.cpp

	C++'ın çeşitli standartları olduğuna göre derleme işlemi bu stanrtlar belirtilerek yapılabilir. Visual Stduio IDE'sinde bu durum menüler yoluyla ayarlanmaktadır.
	g++ derleyicinde -std seçeneği ile ayarlama yapılır. Örneğin:

	-std=c++11
	-std=c++14
	-std=c++17
	-std=c++2a

	Örneğin:

	g++ -std=c++2a -o sample sample.cpp

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C'de C++'ta standartlarda belirtilen sentaks ve semantik kurallara uyulmadan yazılmış olan programlar yine de derleyici tarafından başarıyla derlenebilirler. 
	Çünkğ standartlar geçerli programların derlenmesi gerektiğini koşul olarak ifade etmiştir. Ancak geçesiz programların derlenip derlenmeyeceği konusunda bir hüküm
	belirtmemiştir. Yalnızca standartlarda geçersiz durumlar karşısında derleyicilerin bunu mesajla (diagnostic message) bildirimeleri zorunlu turulmuştur. Yani bu durumda
	geçerli programlar her zaman başarıyla derlenmek zorundadır. Ancal geçersiz programlar başarıyla derlenebilir ya da derlenmeyebilir. Bu nedenle derleme işleminin 
	başarısına bakarak dilin kurallarını öğrenmeye çalışmak iyi bir yöntem değildir. Ayrıca C ve C++'ta derleyiciler diğer derleyicilerde olmayan "eklentilere (extensions)" 
	sahip olabilirler. Neyin bir eklenti olup olmadığının programcı tarafındna bilinmesi gerekir. Eğer biz bir derleyixinin eklentisini kullanırsak o kodu başka bir derleyiciye
	götürdüğümüzde kod başarılı olarak derlenmeyebilir. Çalıştığınız derleyicilerin eklentilerini bilmelisiniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın C'den farklılıkları genellikle "fazlalık" biçimindedir. Bu fazlalıkların bir bölümü C++'ı daha iyi bir C yapmak için dile eklenmiştir. Bunlara "C++'ın C'den
	Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgisi Olmayan Farklılıkları" diyeceğiz. Önce bunlar üzerinde duracağız. Sonra C++'ı "Nesne Yönelimli bir dil yapan 
	"C++ özgü konular üzerinde duracağız." 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    1) C++'ta // ile satır sonuna kadar yorumlama eklenmiştir. Bu özellik C90'da yoktu. Fakat bu özellik C99 ile birlikte C'ye de eklenmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	cout << "Hello World" << endl;			// Merhaba dünya programı

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    2) C++'ta yerel değişkenlerin blokların herhangi bir yerinde bildirilebilirler. Halbuki C90'da yerel değişkenler blokların başlarında bildirilmek zorundaydı. 
	Ancak C99 ile birlikte C'de de yerel değişkenler artık bloların herhangi bir yerinde bildirilebilmektedir. C++'ta bir yerel değişkenin faaliyet alanı bildirim yerinden
	bildirildiği bloğun sonuna kadarki bölgededir Yine bu dilde de iç içe ya da ayrık bloklarlarda aynı isimli yerel değişkenler bildirilebilir. Ancak aynı blok içerisinde
	aynı isimli yerel değişkenler bildirilemez. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    3) C++'ta for döngülerinin birinci kısmında bildirimler yapılabilmektedir. Bu özellik C90'da yoktu. Ancak C99 ile birlikte C'ye de eklendi. Ayrıca C++'ta diğer deyimlerin parantezleri 
	içerisinde de bildirimler yapılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i)
		cout << i << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    for döngüsünün birinci kısmına bildirilen değişkenlerin faaliyet alanları for döngüsü ile sınırlıdır. Yani:

	for (bildirim; ifade; ifade) 
		<deyim>

	işleminin eşdeğeri aşağıdaki gibi düşünülmelidir:

	{
		bildirim;
	
		for (ifade; ifade) 
			<deyim>
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i) {
		cout << i << " ";
	}
	cout << endl;

	cout << i << endl;			// error! 

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bu biçimdeki bir for döngüsünü aşağıya kopyalarsak faaliyet alanı bakımından bir sorun oluşmayacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i) 
		cout << i << " ";
	
	for (int i = 0; i < 10; ++i) 		// Buaraki başka bir i
		cout << i << " ";

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İç içe for döngülerinde de aynı isimli değişkenlerin bulunması bu bağlamda bir sorun oluşturmaz. Ancak iç for döngüsünde biz dış for döngüsünün birinci 
	kısmında bildirilen değişkenleri kullanamayız. Burada bildirilen değişkenlere ilkdeğer verilmelidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0; i < 10; ++i)
		for (int i = 0; i < 10; ++i)
			cout << i << endl;		// Buradaki i iç for döngüsündeki i, diğer i'ye erişemeyiz
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta if, while gibi deyimlerin parantezleri içerisinde de bildirimler yapılabilir. Bu durumda o değişkenlere atanan değerler test işlemine girer.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo()
{
	cout << "foo" << endl;

	return 123;
}

int main()
{
	if (int a = foo())
		cout << a << endl;
	else
		cout << a << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    for döngüsünün birinci kısmında aynı türden olmak koşuluyla birden fazla değişkenin de bildirimi yapılabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	for (int i = 0, k = 100; i + k > 50; ++i, k -= 2)
		cout << i + k << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    4) C++'ta C90'da olmayan bool türü ve true false anahtar sözcükleri de eklenmiştir. bool türü C90'da yoktu. Ancak C99 ile birlikte _Bool ismiyle (ve <stdbool> 
	başlak dosyasında makrolar biçiminde) bool türü de C'ye eklenmiştir. C++'a bool türü eklenince if gibi while gibi deyimlerdeki koşullar bool türü ile standartlarda
	belirtilmiştir. Dolayısıyla C++'ta karşılaştırma operatörlerinin ürettiği değerler de bool türdendir. (Halbuki C'de C17'de dahil olmak üzere karşılaştırma operatörleri 
	int değer üretmektedir.) Standartlar bool türü için işaretsiz bir tamsayı türü kadar yer ayrılabileceğini belirtmektedir. Tipik olarak derleyicileer bool türü için 1 
	byte yer ayırmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 0;
	bool result;

	result = a > 10;		// karşılaştırma operatörleri bool türden değer üretir
	cout << result << endl;

	result = true;			// true ve false birer anahtar sözcüktür

	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta bool türü aritmetik işlemlere sokulabilir. Bu duurmda int türüne otomatik dönüştürülmektedir. true değeri 1 olarak false değer 0 olarak dönüştürülür.
	Yani örneğin biz int + bool gibi bir işlem yapsak bunun sonucu int türden çıkacaktır. Yine skaler türler bool türüne otomatik dönüştürülebilir. Sıfır dışı değerler true olarak 
	0 değeri false olarak dönüşürülür. Yine bir adres bilgisi bool türüne doğrudan atanabilmektedir. Bu durumda NULL adres falase olarak NULL olmayan adres true olarak atanır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int a = 10, c;
	bool b = true;
	char s[10];

	c = a + b;		// geçerli bool türü işlem öncesinde otomatik olarak int türüne dönüştürülür

	cout << c << endl;

	b = 120;		// geçerli, sıfır dışı değerler true olarak dönüştürülür
	b = 0;			// geçerli, sıfır değeri false olarak dönüştürülür

	b = s;			// geçerli NULL pointer falsde olarak diğer adresler true olarak dönüştürülür

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    5) C++'ta bir fonksiyonun çağrılma noktasına kadar derleyicinin o fonksiyonun prototipiyle ya da tanımlaamasıyla karşılaşmış olması gerekmektedir. C90'da 
	fonksiyon çağrısını gören derleyici eğer daha önce fonksiyon hakkında bir bilgi edinmemişse onun int geri dönüş değerine sahip olarak tanımlandığını varsayıyordu.
	Gerçi bu kural da C99 ile birlikte değiştirilmiştir. Bu bakımdan C99 C++ gibidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	foo();		// C90'da geçerli ancak C++'ta ve C99'da geçersiz

	return 0;
}

int foo(void)
{
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    6) C++'ta fonksiyon prototiplerinde parametre parantezinin içinin boş bırakılması ile için void yazılması aynı anlamdadır. Ancak C'nin tüm standartlarında bunlar
	farklı anlamlara gelir. C'de prototiplerde parametre parantezinin için boş bırakılması "bu fonksiyon herhangi bir sayıda parametreye sahip olabilir, bu bakımdan 
	bir kontrol uygulanmayacak" anlamına geliyordu. Halbuki C++'ta artık parametre paranteziin içinin boş bırakılmasıyla void yazılması aynı anlama gelmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo();

int main(void)
{
	foo(10, 20);		// C'de geçerli, C++'ta geçersiz

	return 0;
}

int foo(int a, int b)
{
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Öte yandan hem C'de hem C++'ta başından beri fonksiyon tanımlaması sırasında parametre parantezinin içinin boş bırakılması fonksiyonun parametreye sahip olmadığı 
	anlamına gelmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo()			// C'de de C++'ta da foo fonksiyonun parametresi yok void yazmakla aynı
{
	return 0;
}


int main(void)
{
	foo(10, 20);		// C'de ve C++'ta geçersiz!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    7) Hem C'de hem de C++'ta void göstericiye herhangi bir türden adres atanabilir. Ancak void bir adresin void olmayan göstericiye atanması C'de geçerli olduğu halde
	C++'ta geçersizdir. C++'ta void bir adres void olmayan bir göstericiye tür dönüştürmesi yapılarak atanmalıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a[10];
	void *pv;
	double *pd;

	pv = a;		// hem C'de hem C++'ta geçerli
	pd = pv;	// C'de geçerli, C++'ta geçersiz

	pd = (double *)pv;					// geçerli 
	pd = static_cast<double *>(pv);		// geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    8) C'de string'ler char türünden bir dizi kabul edilmektedir. Ancak string'lerin karakterlerinin güncellenmesi "tanımsız davranışa (undefined behavior)" yol açmaktadır.
	C++'ta string'ler const char türünden yapılmıştır. Dolayısıyla bir string'i char türden bir göstericiye atarken göstericinin türünün const olması gerekir. 
	char türden bir diziye ilkdeğer verirkenki iki tırnakların string belirtmediğini anımsayınız:

	char s[] = "Ali";		// geçerli
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	char *s;
	const char *t;

	s = "Ankara";		// C'de geçerli C++'ta geçersiz
	t = "Ankara";		// Hem C'de hem de C++'ta geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    9) C++11 ile birlikte Unicode string'ler ve karakter sabitleri de dile eklenmiştir. UNICODE UTF-8 için u8 öneki, UNICODE UTF-16 için u öneki ve UNICODE 
	UTF-32 için U öneki kullanılmaktadır. u önekli string'ler const char16_t türünden, U önekli string'ler const char32_t türünden ve u8 önekli string'ler de 
	const char8_t türünden bir dizi olarak ele alınmaktadır. C++20'ye kadar char8_t biçiminde bir tür yoktu. Bu tür C++20 ile eklenmiştir. Bu tür isimleri typedef değil anahtar sözcüklerdir. Bu türlerin hepsi işaretsi bir tamsayı 
	türü belirtmektedir. Bunların işaretli biçimleri de yoktur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	const char *s = "Ankara";					// default karakter tablosu 
	const char16_t *k = u"Ağrı Dağı";			// UTF-16
	const char32_t *t = U"Ağrı Dağı";			// UTF-32
	const char8_t *m = u8"Ağrı Dağı";			// UTF-8
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    10) C++'ta çeşitli biçimlerde ilkdeğer verme (initialization) setntakları bulunmaktadır. Örneğin bir diziye küme parantezleriyle ilkdeğer verilir:

	int a[] = {1, 2, 3};

	Bir sınıf nesnesi normal parantezlerle ilkdeğerlenir:

	Sample s(10, 20);

	İşte C++11 ile her durum için geçerli olan ilkdeğer verme sentaksı oluşturulmuştur. Buna "Uniform Initializer Syntax" denilmektedir. Bu sentaksta 
	hiç '=' kullanmadan doğrudan küme parantezleri içerisinde ilkdeğer verilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a{10};
	const char *b{"ali"};
	int c[]{1, 2, 3};
	int d{};				// d = 0

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Uniform Initializer Syntax ile ilkdeğer verme sırasında bilgi kaybına yol açabilecek dönüştürmeler geçerli değildir. Bilgi kaybına yol açabilecek dönüştürmelere
	C++11 standartlarında "narrowing conversion" denilmektedir. Büyük türden küçük türe yapılan dönüştürmelerde bilgi kaybı oluşmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a{10.2};			// geçersiz!
	int b = 10.2;			// geçerli
	int c[]{1, 2, 3.4, 5};	// geçersiz!

	long d{100};			// geçerli
	int e{d};				// geçersiz

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Uniorm Initializer Syntax'ta int türünden küçük olan türlere tamsayı türlerine ilişkin bir sabit ifadesi ile ilkdeğer verebiliriz. 
	Ancak sabit ifadesinin hedef türün sınırları içerisinde kalması gerekir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	short a{10};			// 10 int türden 

	int b{10};				// geçerli
	short c{b};				// geçersiz! b sabit ifadesi değil

	short d{50000};			// geçersiz! Sabit ifadesi short türünün sınırları dışında 
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında C++11 ile birlikte küme parantezlerinin hepsinde narrowing conversion yasaklanmıştır. Örneğin aşağıdaki gibi bir ilkdeğer verme C++11 öncesi 
	geçerli olduğu halde C++11 ile birlikte artık geçersizdir.

	int a[] = {10.2, 1, 2};		
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a[] = {10.2, 1, 2};		// C++11 ile birlikte artık geçerli değil

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	11) C++'ta const nesneler onlara verilen ilkdeğerler "sabit ifadesi (constant expression)" ise sabit ifadesi belirtirler. Halbuki C'de const nesneler hiçbir zaman 
	sabit ifadesi belirtmezler. Ayrıca C++'ta global const nesneler "internal linkage"a sahiptir. (Yani sanki static global gibi düşünülmelidir.)
	Tabii bir sabit ifadesi sabit ifadeleriyle de oluşturulabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

const int SIZE = 10;

int main(void)
{
	int a[SIZE];			// geçerli SIZE sabiti ifadesi ile ilkdeğer verilmiş bir const nesne
	
	int val;
	const int AA = 2;
	int b = 10;
	const int BB = b;

	cout << "Bir değer giriniz:";
	cin >> val;

	switch (val) {
		case AA:				// geçerli AA bir sabit ifadesi
			break;
		case BB:				// geçersiz! BB bir sabit ifadsi değil, çünkü ona verilen ilkdeğer sabit ifadesi değil
			break;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta global const nesneler internal linkage'a sahip olduğu için onlar adeta #define ile oluşturulan sembolik sabitler yerine kullanılabilmektedir. Derleyiciler
	const nesnelere verilen değerler sabit ifadesi ise onların adresleri de alınmadıysa optimizasyon süreci içerisinde onlar için hiç yer ayırmayabilirler.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    12) C++11 ile birlikte C++'a ismine "constexpr" denilen bir tür niteliyici (type qualifier) da eklenmiştir. constexpr bir nesne her zaman bir sabit ifadesi 
	biçiminde kullanılabilir. (const bir nesnenin sabit ifadesi olarak kullanılabilmesi için ona verilen ilkdeğerin sabit ifadesi belirtmesi gerektiğini anımsayınız.)
	Ancak constexpr nesnelere verilen ilkdeğerlerin de sabit ifadesi olması zorunludur.  Global constexpr nesneler de yine "internal linkage" sahiptirler.
	consexpr nesneler const nesneler olarak ele alınmaktadır. Dolayısıyla örneğin bir consexpr nesnein adresi ancak const bir göstericiye atanmak zorundadır. 

	C++'ta sembolik sembolik sabitlerin #define ile değil const ya da constexpr nesneler yoluyla oluşturulması daha iyi bir tekniktir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

constexpr int SIZE = 10;

int main(void)
{
	int a[SIZE];						// geçerli, SIZE bir sabit ifadesi

	constexpr int AA = SIZE + 2;		// geçerli, SIZE + 2 bir sabit ifadesi

	int b = 10;
	constexpr int CC = b + 2;			// geçersiz! b + 2 bir sabit ifadesi değil

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
   constexpr tür niteleyicisi fonksiyonlarda da kullanılabilmektedir. Bu tür fonksiyonlara constexpr fonksiyonlar denilmektedir. constexpr fonksiyonların 
   dile sokulmasından amaç bir fonksiyon çağrısının sabit ifadesi biçiminde ele alınabilmesini sağlamaktır. const niteleyicisinin böyle bir yeteneği yoktur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int foo()
{
	return 10;
}

constexpr int bar()
{
	return 10;
}

int main(void)
{
	int a[foo()];		// geçersiz! fonksiyon çağrıları sabir ifadesi oluşturmaz
	int b[bar()];		// geçerli, bar çağrısı sabit ifadesi oluşturur

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11'de constexpr fonksiyonların birkaç önemsiz bildirimin dışında tek bir satırdan oluşması gerekiyordu. Yani yalnızca return içerebiliyordu. Ancak daha sonra
	bu constexpr fonksiyonların sentaks ve semantiğinde neredeyse her standartta biraz oynama yapılmıştır. C++20'yi dikkate alırsak artık constexpr fonksiyonların içerisinde 
	if gibi for deyimler kullanılabilmektedir. Ayrıca constexpr fonksiyonların sabit ifadesi belirtmesi zorunlu değildir. Bunların sabit ifadesi belirtlebilmesi için
	return ifadelerinin sabit ifadesinden oluşması ve varsa parametrelerinin de sabit ifadesi argümanlarla çağrılması gerekir. Yani return ifadesi ne olursa olsun
	constexpr bir fonksiyon sabit ifadesi olan argümanla çağrılmamışsa sabit ifadesi belirtmez. C++17 ile birlikte constexpr fonksiyonlar inline kabul edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

using namespace std;

constexpr int square(int a)
{
	return a * a;
}

int main(void)
{
	int a[square(10)];		// geçerli, burada square(10) çağrısı sabit ifadesi belirtiyor
	int b{10};
	int c[square(b)];		// geçersiz artık square bir sabit ifadesi belirtimiyor
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	13) C++'ta C'de olmayan ismine "referans (reference)" denilen adres tutan yeni bir tür de bulunmaktadır. C++11 ile birlikte ismine "sağ taraf değeri referansları
	(RValue references)" denilen bir referans türü de eklenmiştir. Böylece C++11 ve ötesinde referanslar "sol taraf değeri referansları (lvalue references)" ve
	"sağ taraf değeri referansları (rvalue references)" olmak üzere ikiye ayrılmıştır. Biz kurusumuzda C++11 terminolojisini kullanacağız. 

	Biz "referans" dediğimizde hem sol taraf değeri referanslarını hem de sağ taraf değeri referanslarını kastedeceğiz. Ancak bunları ayırmamız gerekriğinde açıkça
	"sol taraf değeri referansı" ya da "sağ taraf değeri referansı" diyeceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sol taraf değeri referansı dekleratörde & atomuyla tanımlanır. Bu tanımlama sırasında ilkdeğer verilesi zorunludur. Örneğin:

	int &r;		// geçersiz! İlkdeğer verme zorunlu

	int a = 10;
	int &r = a;		// geçerli ilkdeğer verilmiş. 

	Sol taraf değeri referanslarında ilkdeğer olarak verilen ifadenin aynı türden bir sol taraf değeri olması gerekir. Örneğin:

	int &r = 10;		// geeçersiz! Verilen ilkdeğer bir nesne belirtimiyor
	
	long a = 10;
	int &r = a;			// geçerisiz verilen ilkdeğer farklı türden

	int a = 10;
	int &r = a;			// geçerli aynı türden bir nesne ile ilkdeğer verilmiş. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Teknik olarak referanslarla göstericiler çok benzerdir. Referanslar "düzeyi yüksek bir gösterici" gibidir. Referans içerisn kodların eşdğer gösterici 
	karşılıkları konunun daha iyi anlaşılmasına yardımcı olmaktadır. Örneğin:

	int a = 10;
	int &r = a;

	Bu işlemin eşdeğer gösterici karşılığı şöyledir:

	int a = 10;
	int *r = &a;

	Görüldüğü gibi "bir referansa bir nesne ile ilkdeğer veridliğinde derleyici o nesnenin adresini kendisi referansa yerleştirmektedir." 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir referans ilkdeğer verildikten sonra kullanıldığında her zaman artık refere ettiği nesnenin kullanıldığı kabul edilir. Örneğin:

	int a = 10;
	int &r = a;

	r = 20;

	Bu işlemin gösterici eşdeğeri şöyledir:

	int a = 10;
	int *r = &a;
	*r = 20;
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir referans ilkdeğer verilen nesneyi gösterir. Artık referansın başka bir nesneyi göstermesi sağlanamaz. Halbuki göstericiler herhangi bir zaman başka bir 
	nesneyi gösterir duruma getirilebilirler. Referanslar C++'a "güvenli bir gösterici fikriyle" sokulmuştur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a = 10;
	int &r = a;

	cout << r << endl;

	r = 20;

	cout << a << endl;
			
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir referansın adresi alındığında biz referansın kendi adresini almış olmayız. Zaten bunun da bir yolu yoktur. Biz referansın refere ettiği nesnenin adresini almış 
	oluruz. Örneğin:

	int a = 10;
	int &r = a;
	int *pi;

	pi = &r;		// a'nın adresi alınıyor

	Bu işlemin eşdeğer gösterici karşılığı şöyledir:

	int a = 10;
	int *r = &a;
	int *pi;

	pi = &*r;		// a'nın adresi alınıyor

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a = 10;
	int &r = a;
	int *pi;

	pi = &r;		

	*pi = 20;

	cout << a << endl;		// 20
	cout << r << endl;		// 20
		

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    const bir referans tanımlanabilir. const referanslar gösterdiği yer const olan const göstsericiler gibidir. Yani örneğin:

	int a = 10;
	const int &r = a;

	Bu işlemin eşdeğer gösterici karşılığı şöyledir:

	int a = 10;
	const int *pi = &a;

	const bir referans ile o referansın refere ettiği nesneyi değiştiremeyiz. Örneğin:

	int a = 10;
	const int &r = a;

	r = 20;		// geçersiz! referans const
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C'de ve C++'ta ilkdeğer verme işlemi anlamına gelen üç temel durum vardır:

	1) Tanımlama sırasında '=' ile değer atama. Ya da Uniform İnitilizer Syntax. Örneğin:

	int a = 10;
	int b{10};

	2) Fonksiyon çağırırken argümanlardan parametre değişkenlerine yapılan kopyalama parametre değişkenine ilkdeğer verme anlamına gelir. Örneğin:

	void foo(int a)		// int a = 100 gibi düşünülmeli
	{
		// ....
	}

	foo(10)

	3) return işlemi aslında geri dönüş değeri için yaratılan nesneye ilkdeğer verme işlemidir. Örneğin:

	int foo()
	{
		// ...

		return ifade;
	}
	//...
	x = foo() * 2;

	Aslında burada şu işlemler arka planda yapılmakatadır:

	int temp = return ifadesi;

	x = temp * 2
	temp yok edilecek

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyonların parametre değişkenleri birer sol taraf referansı olabilir. Böyle fonksiyonlar referansla aynı türden bir sol taraf değeri ile (yani nesne
	belirten ifadeyle) çağrılmalıdır. Bu çağırma sırasında derleyici argümanda belirtilen nesnenin adresini alarak referansa yerleştirir. Artık fonksiyonda
	referansı kullandığımızda argümanda belirtilen nesneye erişmiş oluruz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &r);

int main(void)
{
	int a = 10;

	foo(a);
	cout << a << endl;			// 20
			
	return 0;
}

void foo(int &r)		// int &r = a
{
	cout << r << endl;			// 10
	r = 20;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örneğin göstericilerle oluşturulmuş eşdeğer gösterici karşılığı aşağıdaki gibidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int *r);

int main(void)
{
	int a = 10;

	foo(&a);
	cout << a << endl;
			
	return 0;
}

void foo(int *r)		// int *r = &a
{
	cout << *r << endl;
	*r = 20;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İki int nesne içerisindeki değerleri yer değiştiren swap isimli fonksiyonu referans kullanarak yazabiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void swap(int &a, int &b)
{
	int temp = a;
	a = b;
	b = temp;
}

int main(void)
{
	int a = 10, b = 20;

	swap(a, b);

	cout << "a = " << a << ", " << "b = " << b << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta sol taraf değeri referanslarının göstericilerden en önemli farkı şudur: Bir referansa aynı türden bir nesne ile ilkdeğer verdiğimizde artık derleyici 
	o nesnenin adresini referansa yerleştirir. Artık referans o nesnesyi gösterir hale gelir. O referansın başka bir nesneyi göstermesi mümkün değildir. Halbuki
	göstericilere farklı nesnelerin adreslerini atayarak onların farklı nesneleri göstermesini sağlayabiliriz. Böylece refeanslar daha güvenli bir gösterici olarak 
	kullanılabilmektedir. O halde aslında bir referansın eşdeğer gösterici karşılığı adeta kendisi const olan const bir gösterici gibidir. Örneğin:

	int a = 10;
	int &r = a;

	Bu kodun eşdeğer gösterici karşılığı şöyle ifade edilebilir:

	int a = 10;
	int * const r = a;

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir yapıyı referans yoluyla fonksiyona aktaranbiliriz. Bu durumda yapının elemanlarına referans yoluyla erişirken ok operatörü değil nokta operatörü
	kullanılır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

struct DATE {
	int day;
	int month;
	int year;
};

void disp_date(const DATE &r)
{
	cout << r.day << '/' << r.month << '/' << r.year << endl;
}

int main(void)
{
	struct DATE d = { 10, 12, 2001 };

	disp_date(d);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kodun eşdeğer gösterici kaşılığı aşağıdaki gibidir:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

struct DATE {
	int day;
	int month;
	int year;
};

void disp_date(const DATE * const r)
{
	cout << (*r).day << '/' << (*r).month << '/' << (*r).year << endl;
}

int main(void)
{
	struct DATE d = { 10, 12, 2001 };

	disp_date(&d);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyonun geri dönüş değeri bir sol taraf değeri türünden referans olabilir. Bu durumda return ifadesinin aynı türden bir nesne belirten bir ifade olması gerekir. 
	Biz böyle fonksiyonları çağırdığımızda elde ettiğimiz ifade return ifadesindeki nesne haline gelmektedir. Örneğin:

	int a = 10;

	int &foo()		// int &temp = a
	{
		return a;
	}

	foo() = 20;		// temp = 20

	Burada aartık fonksiyon çağrısı bir sol taraf değeri belirtmektedir. Görüldüğü gibi C'de fonksiyon çağrılaraı her zaman sağ tarafdeğeri belirtir. AncakC++'ta
	fonksiyonun geri dönüş değeri sol taraf değeri referansı ise artık fonksiyon çağrısı sol taraf değeri belirtir. Fonksiyon çağrısına bir değer atadığımızda aslında biz
	return ifadesindeki nesneye değer atamış oluruz. Tabii nasıl bir fonksiyon yerel bir nesnenin adresi ile geri dönmemeli ise benzer biçimde aynı durum referanslar
	için de geçerlidir. Yani fonksiyonun geri dönüş değeri bir referans ise biz return ifadesinde yerel bir nense kullanmamalıyız (fonksiyon bittiğinde yerel nesnelerin 
	stack'ten boşaltıldığını anımsayınız.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int a{10};

int &foo()		// int &temp = a
{
	return a;
}

int main(void)
{
	cout << a << endl;		// 10

	foo() = 20;		

	cout << a << endl;		// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kodun eşedeğer gösterici karşılığı aşağıdaki gibidir:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int a{10};

int *foo()		// int * const temp = &a
{
	return &a;
}

int main(void)
{
	cout << a << endl;		// 10

	*foo() = 20;		

	cout << a << endl;		// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++ standartlarında bir referansa ilk değer verildiğinde ilkdeğer verilen nesnesnin adresinin referansa yerleştirilmesine 
	söz konusu ilkdeğerin "referans'a bind edilmesi" de denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    const bir sol taraf değeri referansını biz bir sağ taraf değeri ile ilkdeğer vererek yaratabiliriz. Örneğin:

	int &r = 10;				// geçersiz!
	const int &r = 10;			// geçerli

	Bu durumda verilen ilkdeğer önce referans ile aynı türden geçici bir nesneye yerleştirilir. Sonra bu geçici nesne referansa bind edilir. Yani yukarıdaki 
	ilkdeğer vermenin eşdeğeri şöyledir:

	int temp = 10;
	const int &r = temp;

	Burada geçici nesnenin ömrü referans kadardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	const int &r = 10;

	cout << r << endl;		// geçici nesne kullanılıyor		

	r = 20;					// error! Referans const

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sol taraf değeri referansını farklı türden bir nesneyle ilkdeğer vererek tanımlayamayız. Örneğin:

	double a = 10.2;
	int &r = &a;		// error!

	Ancak referans const ise bu mümkündür. Bu durumda yine derleyici ilkdeğer olarak verilen nesneyi referansla aynı türden bir geçici nesnenin içine yerleştirir.
	Bu geçici nesneyi referansa bind eder. Örneğin:

	double a = 10.2;
	const int &r = a;

	Bu işlemin eşdeğeri şöyledir:

	double a = 10.2;
	int temp = a;
	const int &r = temp;

	Tabii eğer ilkdeğer verme "uniform initializer" sektasıyla yapılıyorsa bilgi kaybına yol açabilen daraltıcı dönüştürmelere izin verilmemektedir. Örneğin:

	{
	double a = 10.4;
	const int &r{a};		// error!

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Eskiden C++'ta ifadeler ya "lvalue" ya da "rvalue" olurdu. Ancak C++11 ile birlikte bazı nedenlerden dolayı bu kavramlarda bazı değişikliklere gidilmiştir. 
	C++11'de bir ifadenin nesne belirtip belirtmeme durumuna "value category" denilmektedir. Bu "value category" içerisine "xvalue (expiring value)" biçiminde 
	başka bir terim daha eklenmiştir. Eskiden rvalue olan ifadelere C++11 ile birlikte artık "prvalue (pure rvalue)" denilmiştir. xvalue ise hem bir sol taraf değeri
	hem de bir sağ taraf değeri olarak düşünülmüştür. Bu durumda C++11'De "value category" kavramı iki ana kategoriye ayrılmıştır: glvalue (general lvalue) ve rvalue.
	glvalue ise "lvalue" ya da "xvalue" olabilmektedir. rvalue ise "prvalue" ya da "xvalue" olabilmektedir. 

		glvalue     rvalue
		/  \	   /  \
	   /    \     /    \
	lvalue   xvalue    prvalue


--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte ismine "sağ taraf değeri referansları (rvalue references)" denilen başka bir referans türü daha dile eklenmiştir. Böylece eski referansların
	da isimleri "sol taraf değeri referansları (lavlue references)" biçiminde değiştirilmiştir. Sağ taraf değeri referansları dekleratörde && atomlarıyle belirtilir. 
	(Burada && atomları kesinlikle referansın referansı gibi bir anlama gelmemektedir.)

	Bir sağ taraf değeri referansına bir sağ taraf değeri ile (yani belirtmeyen bir ifade ile) ilkdeğer verilmek zorundadır. Örneğin:

	int a = 10;
	int &&r = a;		// error! a bir sağ taraf değeri değil
	int &&r = 10;		// geçerli, a bir sağ taraf değeri

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sağ taraf değeri referansına bir sağ taraf değeri ile ilkdeğer verdiğimizde derleyici o sağ taraf değerini referansla aynı türden bir geçici nesnenin
	içerisine yerleştirir ve referansa o geçici nesnenin adresi atar. Örneğin:

	int &&r = 10;

	Bu işlemin eşdeğeri şöyledir:

	int temp = 10;
	int &&r = temp'in adresi

	Pekiyi aynı işlemi zaten const olan sol taraf değeri referansı ile de yapabiliyorduk. O halde değişen ne var? Buradaki tek fark sağ taraf değeri referansının const 
	olmaması ve dolayısıyla o geçici nesneyi değiştirebilmesidir. 
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sağ taraf değeri referansları aslında C++11'e sınıf nesnelerinin içerisindeki bilgileri taşımak için eklenmiştir. Buna İngilizce "move semantics" denilmektedir. 
	Taşıma semantiği ileride sınıflar konusunda ele alınacaktır. 

	Sağ taraf değeir referansları sol taraf değeri belirtirler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
kalınan yer
#include <iostream>

using namespace std;

int main(void)
{
	int &&r = 10;
	int &k = r;			// r bir sol taraf değeridir

	k = 20;


	cout << r << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sağ taraf değeri referansına yine biz farklı bir sol taraf değeri ile de ilkdeğer verebiliriz. Bu durumda farklı türden nesne önce aynı türden derleyici 
	tarafından yaratılan bir geçici değişkene atanır. Sonra bu geçici değişkenin adresi sağ taraf değerine ilişkin referansa yerleştirilir. Örneğin:

	double d = 12.3;
	int &&r = d;			// geçerli!
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun parametre değişkeni sağ taraf değeri referansı olabilir. Bu durumda fonksiyon bir sağ taraf değeri argüman yapılarak çağrılmak zorundadır.  
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &&r)
{
	cout << r << 10;
}

int main(void)
{
	int a = 10;

	foo(a);		// error! 
	foo(20);	// geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun geri dönüş değeri sağ taraf taraf değeri referansı olabilir. Böyle fonksiyonlar çağrıldığında xvalue belirtirler. Bu konu ileride 
	ele alınacaktır. Ancak bu tür durumlarda da yaratılacak geçici nesne fonksiyonun yerel değişkeni biçiminde yaratılır. Dolayısıyla aşağıdaki gibi 
	bir işlem "tanımsız davranışa (undefined behavior)" yol açmaktadır:

	int &&foo()
	{
		return 10;		// dikkat temporary yerel bir nesne olarak yaratılacak
	}

	Pekiyi bu durumda fonksiyonun geri dönüş değerinin sağ taraf değeri referansı olmasının ne anlamı vardır? İşte aslında ilerideki konularda da görüleceği gibi 
	bir sol tafa değeri "sanki bir sağ taraf değeri imiş gibi" geri döndürülmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int &&foo()
{
	return 10;				// dikkat! yerel bir nesnenin adresi ile geri dönülüyor
}

int main(void)
{
	int &&r = foo();		// foo() bir xvalue belirtiyor

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	14) C++'ta dinamik bellek yönetimi için new ve delete isimli iki operatör eklenmiştir. new operatörü iki biçimde kullanılabilir:

	1) new <tür>
	2) new <tür><[uzunluk ifadesi]>

	Birinci biçimde heap'te ilgili türdne tek bir elemanlık yer tahsis edilir. İkinci biçimde ilgili türden belirtilen uzunlukta yer tahsis edilir. new
	operatörü tahsis edilen alanın başlangı adresini ilgi türden bize verir. New operatörü ile tahsis etmiş olduğumuz alan içerisinde çöp değerler vardır. 
	new operatörü normal kullanımda başarıszlık durumunda "bad_alloc" isimli bir exception fırlatmaktadır. Dolayısıylşa programcı tahsisatın başarıını NULL gösteri ile
	kontrol etmez. Böyle bir kontrol yapmayınız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;


int main(void)
{
	int *pi;

	pi = new int[10];

	for (int i = 0; i < 10; ++i)
		pi[i] = i;

	for (int i = 0; i < 10; ++i)
		cout << pi[i] << ' ';
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new ile yapılan dinamik tahsisat delete operatörü ile serbest bırakılır. delete operatörünün de iki sentaktik biçimi vardır:

	1) delete <adres>
	2) delete [] <adres>

	Eğer new ile köşeli parantezsiz tahsisat yapılmışsa bunun boşaltımı köşeli parantezsiz delete yapılır. Eğer new ile köşeli parantezli bir tahsisat yapılmışsa
	bunun bhoşaltımı köşeli parantezlei delete ile yapılır. 

	Tahsis edilen alan delete ile boşaltılmazsa Windows, MAC OS X, Linux gibi yaygın işletim sistemlerinin hepsinde program bittiğinde bu alanlar boşaltılmaktadır. 
	Çünkü işletim sistemlerinde genel oalrak "heap alanı prosese özgüdür". Yani her prosesin heap alanı diğerlerinden farklıdır. Yani bir programda yapılan dinamik tahsisatın
	diğer çalışmakta olan programlara hiçbir etkisi yoktur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int *pi;

	pi = new int[1];

	delete [] pi;			// doğru

	pi = new int[10];

	delete[] pi;			// doğru

	pi = new int;			
	delete pi;				// doğru

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte new ile tahsis edilen alana küme paramtezleriyle ilkdeğer verilebilmektedir. Örneğin:

	pi = new int[3] {10, 20,30};

	Az sayıda elemana bu biçimde ilkdeğer verilebilir. Bu durumda geri elemanların hepsi sıfırlanmaktadır. Örneğin:

	pi = new int[10] {1};		// geri kalanelemanlar 0

	Küme parantezinin içi boş da bırakılabilir. Bu durumda tüm elemanlar sıfırlanır. Örneğin:

	pi = new int[10] {};	// tüme elemanlar sıfırlanır

	Bu biçimde köşeli parantezlerin içi boş bırakılabilir. Bu duurmda derleyici verilen ilkdeğerleri sayar ve dinamik diziin o kadar elemandan oluştuğnu kabul eder. 
	Örneğin:

	pi = new int[] {10, 30, 40};		// 3 elemanlık tahsisat yapılıyor


--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{0,
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    new operatörü ile biz bir gösterici dizisi de tahsis edebiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	const char **names;

	names = new const char *[] {"ali", "veli", "selami", NULL};

	for (int i = 0; names[i] != NULL; ++i)
		cout << names[i] << endl;

	delete[] names;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	15) C++'ta C'nin tüm standart fonksiyonları kullanılabilir. Ancak bu konuda birkaç ayrıntı vardır. Birincisi C++'ta C'nin başlık dosyalarının ismi değiştirilmiştir. 
	C'nin standart bir başlık dosyası <x.h> olmak üzere bunun C++'taki ismi <cx> biçimindedir. Uzantının olmadığına ve başlık dosyalarının başına 'c' harfi getirildiğine 
	dikkat ediniz. İkinci farklılık standart C fonksiyonlarının std isim alanına taşınmış olmasıdır. 

	C++'ta <cx> biçiminde belirttiğimiz başlık dosyalarındaki isimlerin aynı zamanda global isim alanında bulunup bulunmayacağı derleycicileri yazanların isteğine 
	bırakılmıştır. Ancak C++'ta biz <x.h> biçimindeki başlık dosyalarını da include edebiliriz. Bu başlık dosyalarındaki isimler bu durumda	global isim alanına yerleştirilmiş olmak zorundadır. 
	Fakat <x.h> dosyalarının aynı zamanda std isim alanına da yerleştirilip yerleştirilmeyeceği derleyicileri yazanların isteğine bırakılmıştır.
	Ancak C++'ta <x.h> biçiminde C dosyalarının include edilmesi kötü bir tekniktir.

	Her ne kadar C++ C'nin standart fonksiyonlarını destekliyorsa da ayrıca C++'ın kendine özgü "template" tabanlı bir standart kütüphanesi de vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <cstdio>

using namespace std;

int main(void)
{
	printf("This is a test\n");		// printf std isim alanının içeisinde

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    16) C++'ta makrolara benzer ismine "inline fonksiyon" denilen fonksiyonlar da bulunmaktadır. Aslında inline fonksiyon kavramı çok uzun süredir çeşitli derleyicilerde 
	bir eklenti (extension) biçiminde bulunuyordu. Ancak C++'ta resmi olarak bulundurulmuştur. C++'tan sonra inline fonksiyonlar C99 ile birlikte C'ye de sokulmuştur. 
	Ancak C++'ın inline fonksiyonlarıyla C99'un inline fonksiyonları arasında semantik farklılıklar vardır. Aynı zamanda örneğin derleycilerin eskiden eklenti biçiminde
	bulundurduğu inline semantikleri de farklıdır. 

	Bir fonksiyon "inline" anahtar sözcüğü kullanılaak inline yapılabilir. Örneğin:
	
	inline void foo()
	{
		//...
	}

	inline bir fonksiyon çağrıldığında derleyici bir fonksiyon çağrısı yerine inline fonksiyonun iç kodunu çağrılan yere enjekte edebilmektedir. Böylece fonksiyon
	çağrısının bazı maliyetleri ortadan kaldırılabilmektedir. Bir fonksiyon çağrıldığında derleyiciler normal olarak fonksiyonu CALL makine komutuyla çağırmaktadır. CALL işleminden
	önce argümanlar fonksiyonun parametre değişkenlerine kopyalanır. Fonksiyonda da geri dönüşü sağlamak için RET makine komutu gerekir. Yine fonksiyonun stack üzerinde 
	işlemler yapabilmesi için "stack frame düzenlemesine" gereksinim duyulabilmektedir. Bu düzenleme de birkaç makine komutu ile yapılmaktadır. İşte fonksiyonların 
	CALL işlemi yerine iç kodlarının çağrılan yere enjekte edilmesi tüm bu makine komutlarını elimine edebilmektedir. Ancak tabii inline bir fonksiyonun çokça çağrılması
	neticesinde bir kod büyümesi söz konusu olabilir. O halde kısa (örneğin bir iki satırlık) fonksiyonların inline yapılması uygun bir yöntemdir. 

	inline belirleyicisi "bir emir değil rica" niteliğindedir. Yani biz bir fonksiyonu inline yaptığımızda derleyici onun iç kodunu enjekte etmek zorunda değildir. inline
	fonksiyona yine derleyici normal fonksiyon muamelesi yapabilir. Bu konuda herhangi bir uyarı mesajı da vermeyebilir. inline konusu derleyicilerde genel olarak 
	optimizasyon konusu ile ilişkilendirilmiştir. Yani derleyicimizin optimizasyon seçeneklerini yeteri kadar açmazsak derleyicimiz inline açım yapmaz. 
	Microsoft derleyicilerinde en azından /O2 g++ ve clang++ derleyicilerinde -O2 seçeneği "inline açım (inline expansion) için uygulanmalıdır. 

	Biz derleyicilerde optimizasyon seçeneklerini açsak bile derleyiciler "döngü içeren, iç içe çok fazla if deyiminin bulunduğu, uzun kodları" kodları
	inline olarak açmak istemezler. Bazı kodlar (örneğin özyineleme içeren) inline olarak açılamamaktadır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

inline int square(int a)
{
	return a * a;
}

int main(void)
{
	int result;
	int val;

	cout << "Bir değer giriniz:";
	cin >> val;

	result = square(val);		// result = val * val
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    inline fonksiyonlar tipik olarak başlık dosyalarına yerleştirilirler. Çünkü derleyicinin her derleme işlemi sırasında inline açım yapabilmesi için 
	inline fonksiyonun tanımlamasını görmesi gerekir. Yani inline fonksiyonların kütüphanelere yerleştirilmesinin bir anlamı yoktur. Pekiyi inline fonksiyonların 
	birden fazla modülde tanımlanmış olması link aşamasında bir problem oluşturur mu? 

	Standartlara göre bir fonksiyon bir modülde inline olarak tanımlanmışsa o fonksiyonu kullanan her modül fonksiyonu yine inline olarak aynı biçimde tanımlamak zorundadır. 
	Bu aynı biçimde tanımlama tipik olarak inline fonksiyonun bir başlık dosyasına yerleştirilip modüllerden include edilmesi ile sağlanabilir. İşte derleyici eğer 
	inline fonksiyonu inline olarak açarsa ve fonksiyonun adresi de herhangi bir biçimde kodda kullanılmadıysa bu durumda derleyici fonksiyonun derlenmiş halini hiç 
	object modüle yazmayabilir. Ancak derleyici inline fonksiyon için inline açım yapmamışsa mecburen fonksiyonu object dosyaya yazacaktır. Bu biçimde projeyi oluşturan
	tüm modüllerde bu fonksion object dosyaya yazılacağına göre link aşamasında bir sorun oluşmayacak mıdır? İşte linker farklı object dosyalarda aynı inline fonksiyonun
	tanımlaması ile karşılaştığında onun herhangi bir object dosyadaki tek bir kopyasını çalıştırılabilen dosyaya yazmaktadır. Bunun için modern object dosya formatlarında "common" 
	bölümler ya da attribute'lar bulunmaktadır. 

	C++'ta inline fonksiyonlar (static inline yapılmadıktan sonra) yine "external linkage'a" sahiptirler. Biz bir inline fonksiyonun adresini alabiliriz. 
	Bu durumda derleyici inline açım yapıyor olsa bile mecburen fonksiyon tanımlamasını yine object dosyaya yerleştirir. Benzer biçimde biz inline bir fonksiyonun 
	farklı modüllerde adresini alsak bile bu adreslerin hepsi aynı olmak zorundadır. Bu durum static olmayan inline fonksiyonun "external linkage'a" sahip olduğunu açık biçimde 
	göstermektedir. 

	Özetle: Programcı birkaç satırlık fonksiyonların hızlı çalışmasını istiyorsa onu inline yapabilir. inline fonksiyonlar tipik olarak başlık dosyalarına yerleştirilirler. 
	Böylece projeyi oluşturan her modül onları aynı biçimde görebilir. Eğer inline açım yapılırsa çalıştırılabilir dosyada bu inline fonksiyon hiç bulunmayabilir. 
	Eğer inline açım yapılmamışsa bu fonksiyonların çalıştırılabilen dosyada tek kopyası bulunur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	17) C++11 ile birlikte auto anahtar sözcüğü otomatik tür belirleme için bir "tür belirleyicisi (type specifier)" haline getirilmiştir. Eskiden bu auto anahtar sözcüğü 
	(hala C'de böyle) işlevi olmayan "storage class specifier" olarak bulundurulan bir anahtar sözcüktü. C++11 ile birlikte buna yeni bir işlev yüklenmiştir. 

	Bir değişken auto anahtar sözcüğü ile tanımlanıyorsa ona ilkdeğer verilmek zorundadır. Örneğin.

	auto int a;		// geçersiz!

	Derleyici auto anahtar sözcüğü ile tanımlanmış bir nesnenin türünü ona verilen ilkdeğerden hareketle belirler. Ona verilen ilkldeğer hangi türdense auto yerine
	sanki o türün yazılmış olduğunu kabul eder. Örneğin:

	void foo()
	{
		//...
	}
	//...
	int main(void)
	{
		auto a = 123;		// int a = 123;
		auto b = 12.3;		// double b = 12.3;
		auto c = foo;		// void (*c)() = foo;

		return 0;
	}

	auto tür belirleyici ile birden fazla değişken tanımlanabilir. Ancak onlara verilen ilkdeğerin hepsinin aynı türden olması gerekir. Örneğin:

	auto a = 10, b = 20;		// geçerli
	auto c = 10, d = 2.3;		// error!

	auto özellikle karmaşık kullanıcı tanımlı türlerin ifade edilmesi konusunda programcıya pratiklik sağlamaktadır. Örneğin:

	vector<int> v;
	auto iter = v.begin();		// vector<int>::iterator iter = v.begin();

	auto belirleyici ile yer belrleyicileri ve tür niteleyicileri birlikte kullanılabilir. Bu durumda tür tespiti "şablon türlerin tespit edilmesi (template argument deduction)"
	sürecinde olduğu gibi yapılmaktadır. Örneğin:

	int a = 10;
	auto &r = a, b = 20;					// auto = int
	const auto *s = "ali", ch = 'a';		// auto = char
	auto k = "veli"							// auto = const char *

	C++14 ile birlikte fonksiyonun geri dönüş değeri için de auto kullanılabilir hale gelmiştir. Fonksiyonun geri dönüş değerinin türü yerine auto kullanılırsa
	derleyici geri dönüş değerinin türünü return ifadesindeki türe bakarak belirler. Örneğin:

	auto foo()		// auto = int
	{
		return 10;
	}

	Burada foo fonksiyonun geri dönüş değerinin int türden olduğu anlaşılmaktadır. Tabii fonksiyon içerisinde birden fazla kez return deyimi kullanılmışsa return 
	ifadelerinin tür tespitinin yapılabilmesi için aynı türden olması gerekir. Örneğin:

	auto foo(int a)		
	{
		if (a > 0)
			return 3.14;

		return 3;		// error
	}

	auto void tür tespiti için de kullanılabilir. Eğer fonksiyonda hiç return kullanılmamışsa ya da tüm return deyimlerinde bir ifade bulundurulmamışsa bu durumda
	fonksiyonun geri dönüş değerinin void olduğu tespit edilir. Örneğin:

	auto foo(int a)			// auto = void
	{
		if (a < 0)
			return;

		cout << "foo" << endl;
	}

	C++20 ile birlikte fonksiyonun parametre değişkeninde de auto kullanılabilir. Ancak bu kullanım fonksiyonun "gizli bir biçimde şablon olduğu" anlamına gelmektedir. 
	Örneğin:

	auto foo(auto a)
	{
		cout << a << endl;
	}

	int main(void)
	{
		foo(10);		// auto = int
		foo(20.2);		// auto = double
	
		return 0;
	}


--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    18) C++11 ile birlikte C++'a "aralık tabanlı for döngüsü (range based loop)" ismiyle yeni bir for döngüsü eklenmiştir. Aslında bu tarz for döngüleri 
	zaten Java gibi C# gibi dillerde "foreach" döngüsü ismiyle bulunuyordu. Aralık tabanlı for döngüsünün genel biçimi şöyledir:

	for (<tür> <değişken ismi> : <dizi ismi ya da dolaşılabilir nesne>)
		<deyim>

	Aralık tabanlı for döngüleri şöyle çalışmaktadır: Bir dizi ya da dolaşılabilir (iterable) bir nesnenin her elemanı için döngü bir kez yinelenir. Her yinelemede 
	dizinin ya da dolaşılabilir nesnenin sıradaki elemanı döngü değişkenine yerleştirilir ve döngü deyimi çalıştırılır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a[] = { 10, 20, 30, 40, 50 };

	for (int x : a)
		cout << x << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı tabanlı for döngüsünde herhangi bir türden dizi ya da bir string kullanılabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	const char *names[] = { "ali", "veli", "selami", "ayşe", "fatma" };

	for (char ch : "ankara")
		cout << ch;
	cout << endl;

	for (const char *name : names)
		cout << name << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngüleri iteratör desteği olan dolaşılabilir (iterable) sınıf nesneleri ile de kullanılabilmektedir. Buradaki değişkenin faaliyet alanı for 
	döngüsü ile sınırlıdır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main(void)
{
	vector<int> v{ 10, 20, 30, 40, 50 };

	for (int x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngülerinde döngü değişkeni bir sol taraf değeri referansı da olabilir. Bu durumda ilgili elemanın adresi referansa yerleştirilecektir.
	Dolayısıyla biz diziyi ya da dolaşılabilir nensnedeki elemanları bu yolla güncelleyebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a[] { 1, 2, 3, 4, 5 };

	for (int &r : a)
		r *= r;

	for (int x : a)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aralık tabanlı for döngüsünde döngü değişkeninin türü yerine "auto" anahtar sözcüğü yazılabilir. Bu durumda eğer dolaşılan bir dizi ise dizinin türüne dayalı
	tür tespiti yapılır. Eğer dolaşılan nesne dolaşılabilir bir nesne ise burada itertörün türüne göre tür tespiti yapılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main(void)
{
	int a[] = { 1, 2, 3, 4, 5 };
	const char *names[] = { "ali", "veli", "selami", "ayşe", "fatma" };

	for (auto x : a)			// auto = int
		cout << x << " ";
	cout << endl;

	for (auto &r : a)			// auto = int
		cout << r << " ";
	cout << endl;

	for (auto name : names)		// auto = const char *
		cout << name << " ";
	cout << endl;

	for (const auto *name : names)		// auto = char
		cout << name << " ";
	cout << endl;

	auto v = vector<int>{ 1, 2, 3, 4, 5 };

	for (auto x : v)		// auto = int
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    19) C++'ta yapılar, sınıflar enum türleri için tür bilgisi ifade edilirken "struct", "class"  ve "enum" anahtar sözcüklerinin kullanımı zorunlu değildir. Halbuki C de bir yapı 
	türü struct anahtar sözcüğü ve yapının ismiyle belirtilmektedir. Örneğin:

	struct Sample {
		int a;
		int b;
		int c;
	};
	
	Burada  oluşturulan yapının türü C'de "struct Sample" biçimindedir. C++'ta yalnızca "Sample" ismi de tür ismi olarak kullanılabilmektedir. Tabii C++'ta istenirse
	"struct Sample" biçiminde de tür ifade edilebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

struct Sample {
	int a;
	int b;
	int c;
};

int main(void)
{
	struct Sample s;		// geçerli ve C'de türün ismi struct Sample
	Sample k;				// geçerli, C++ta yalnızca yapı ismi belirtilebilir
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    20) C'de enum türleri ile int türü arasında bir farklılık yoktur. Yani C'de bir enum türünden nesne sanki int türden bir nesneymiş gibi derleyiciler tarafından ele alınmaktadır. 
	Ancak C++'ta her enum türü bağımsız farklı türdür. C++'ta bir enum nesnesi için herhangi bir tamsayı türünün uzunluğu kadar yer ayrılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

enum Day {
	Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
};

int main(void)
{
	enum Day e;			// C'de enum Day tamamen int anlamına gelmektedir. Halbuki C++'ta ayrı bir tür belirtir. 
	Day k;				// enum ismi C++'ta tür belirtirken hiç kullanılmayabilir. 

	e = Sunday;
	k = Monday;

	cout << e << endl;
	cout << k << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C'de enum türleri tamamen int türünden kabul edildiği için int türü nerelerde işleme sokuluyorsa oralarda işleme sokulabilmektedir. Halbuki C++'ta enum türlerinden
	diğer türlere otomatik tür dönüştürmesi vardır ancak diğer türlerden enum türlerine otomatik tür dönüştürmesi yoktur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

enum Day {
	Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
};

int main(void)
{
	Day day;
	int val;

	day = 1;							// error! int türündne enum türüne otomatik dönüştürme yok
	day = static_cast<Day>(1);			// geçerli

	day = Monday;						// geçerli, enum sabitleri ilgili enum türündendir.
	val = day;							// geçerli enum türlerinden diğer türlere otomatik dönüştürme var.

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte enum türlerinin "ilişkin olduğu tamsayı türü (underlying integer type)"  ':' sentaksıyla belirtilebilmektedir. Örneğin:

	enum Color : unsigned char 
	{
		Red, Green, Blue
	}

	Bu belirlemeyle artık derleyici bu enum türünden nesne için tam olarak burada belirtilen tamsayı türü kadar yer ayırır ve bu enum türünden bir nesne işlemlere sokulurken 
	sanki bu nesne bu enum türünün ilişkin olduğu tamsayı türündenmiş gibi işleme sokulmaktadır.  Yukarıdaki Color isimli enum nesnesi için 1 byte yer ayrılacaktır. 
	Bu nesne arka planda sanki unsigned char türünden bir nesneymiş gibi davranacaktır. Tabii enum sabitlerine (enumartors) ilişkin olunan 	tamsayı türünün sınırları 
	dışında değer verilemez. 

	C++'ta bir enum türü için ':' sentaksıyla o enum türünün ilişkin olduğu tamsayı türü belirtilmemişse o enum türünün ilişkin olduğu tamsayı türü 
	derleyicinin belirlediği herhangi bir tamsayı türünden olabilir. Ancak o enum sabitinin tüm enum sabitleri int ya da unsigned int türünün sınırları içerisinde
	kalıyorsa bu tür int ya da unsigned int türünden büyük olamaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Enum türlerinde belirtilen enum sabitleri bu enum türü hangi faaliyet alanına yerleştirilmişse o faaliyet alanında kabul edilmektedir. Bu durum isim 
	kirliliğine yol açabilmektedir. 

	Aşağıdaki örnekte enum sabitleri enum türü global alana yerleştirildiği için global değişken gibi işlem görmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

enum Day 
{
	Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
};

int main(void)
{
	Day d = Sunday;			// geçerli
	//...

	return 0;
}

void foo()
{
	Day d = Thursday;		// geçerli
	//...
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte C++'a ismine "faaliyet alanlı enum (scoped enumeration)" denilen yeni bir enum türü daha eklenmiştir. Faaliyet alanlı enum türleri 
	"enum class" ya da "enum struct" anahtar sözcükleriyle bildirilmektedir. Bu iki bildirim arasında bir farklılık yoktur. 
	Örneğin:

	enum class Color
	{
		Red, Green, Blue
	}

	Artık bu enum türündeki Red, Green, Blue enum sabitlerini doğrudan kullanamayız. Örneğin:

	Color color = Red;		// error!

	Faaliyet alanlı enum sabitleri enum ismi ve :: operatörü ile niteliklendirilerek kullanılmak zorundadır. Örneğin:

	Color color = Color::Red;		// geçerli

	Faaliyet alanlı enum türleri otomatik olarak diğer türlere dönüştürülememektedir. Örneğin:

	Color color = Color::Red;

	int val = color;				// error!

	Örneğin:

	auto val = Color::Red + 1;		// error!

	Eğer böyle bir gereksimin varsa tür dönüştürme operatörü kullanılmalıdır. Örneğin:

	int val = static_cast<int>(color);		// geçerli

	Yine faaliyet alanlı enum türlerine ilişkin tamsayı türü ':' sentaksıyla açıkça belirtilebilir. Örneğin:

	enum class Color : unsigned char {
		Red, Green, Blue
	};
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    21) C++'ta C'de olmayan uzmanlaşmış tür dönüştürme operatörleri vardır. C'nin "(tür) operand" biçimindeki tür dönüştürme operatörü C++'ta aslında aynı biçimde
	kullanılabilmektedir. C'nin bu operatörü C++'ta geçerli olan her şeyi dönüştürebilmektedir. Bu da programcıları dikkatsizliğe sevk edebilmektedir. İşte C++'ta
	farklı tarzda tür dönüştürmeleri için farklı operatörler bulundurulmuştur. C++2ta C tarzı tür dönüştürmesi yerine bu özel operatörlerin kullanılması iyi bir tekniktir.
	c++'ın özel tür dönüştürme operatörleri şunlardır:

	static_cast
	const_cast
	reinterpret_cast
	dynamic_cast

	Bu operatörler şablon senktası biçimde kullanılır. Yani dönüştürülecek tür açısal parantezler içerisinde belirtilir. Dönüştürülecek ifade de paranteze alınır. 
	Örneğin:

	val = static_cast<int>(color);
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	static_cast "standart dönüştürmeler (standard conversion)" için kullanılmaktadır. Standart dönüştürme demekle aritmetik türler arası dönüştürmeler, enum tamsayı 
	dönüştürmeleri, void * dönüştürmeleri, türemiş sınıftan taban sınıfa adres dönüştürmeleri kastedilmeketdir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void *foo()
{
	return NULL;
}

enum Color {
	Red, Green, Blue
};

int main(void)
{
	double a = 10.2;
	int val;
	int *pi;
	Color color;

	val = static_cast<int>(a);		// Zaten operatöre gerek yok
	pi = static_cast<int *>(foo());		// void *'dan diğer adres türlerine 
	color = static_cast<Color>(2);		// geçerli, static_cast bu dönüştürmeyi yapar
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	const_cast adres dönüştürmelerin const'luğu atmak için (const away cast) kullanılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a[] = { 1, 2, 3, 4, 5 };
	const int *pi1;
	int *pi2;

	pi1 = a;						// const gösteriye const olmayan bir adres atanabilir
	pi2 = pi1;						// geçersiz!
	pi2 = (int *)pi1;					// geçerli ama C++'ta kötü teknik
	pi2 = const_cast<int *>(pi1);				// geçerli, adreslerde const'luğu atma için const_cast tercih edilmeli. 

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    reinterpret_cast farklı türlerdeki adres arasında ve adres türleriyle aritmetik türler arasında tür dönüştürmeleri için kullanılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main(void)
{
	int a[] = { 1, 2, 3, 4, 5 };
	unsigned char *pc;
	unsigned long addr;

	pc = a;											// error!
	pc = (unsigned char *)a;						// geçerli amaa kötü teknik
	pc = reinterpret_cast<unsigned char *>(a);		// iyi teknik

	addr = a;										// error
	addr = (unsigned long)a;						// geçerli ama kötü teknik
	addr = reinterpret_cast<unsigned long>(a);		// iyi teknik

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Hem adresteki const'luğu atmak hem de adresi farklı türe dönüştürmek için iki operatör birlikte kullanılmalıdır. Örneğin:

	const int *pi;
	char *pc;
	//...

	pc = reinterpret_cast<char *>(const_cast<int *>(pi));

	ya da şöyle de yapılabilirdir:

	pc = const_cast<char *>(reinterpret_cast<const char *>(pi));

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	dynamic_cast operatörü sınıflarla ilgili işlem yapmaktadır. Bu operatör ileride ele elınacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	22) C++'ta parametre değişkenleri default değer alabilmektedir. Fonksiyon çağrılırken default değer alan parametre değişkenleri için argüman girilmeyebilir. 
	Bu durumda sanki argüman olarak o default değerlerin girilmiş olduğu kabul edilir. Eğer default değer alan parametre değişkenleri için argüman girilmişse bu durumda
	bu default değerler dikkate alınmaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a = 100, int b = 200)
{
    cout << "a = " << a << ", b = " << b << endl;
}

int main(void)
{
    foo();              // foo(100, 200)
    foo(10);            // foo(10, 100)
    foo(10, 20);        // foo(10, 20)

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir parametre değişkeni default değer almışsa onun sağındakilerin hepsinin default değer almış olması gerekir. Örneğin aşağıdaki fonksiyonun tanımlaması geçerli değildir:

	void foo(int a = 10, int b)
	{
		//....
	}

	Yani default değer alan parametrelerin parametre listesinin sağında birikmiş olması gerekmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Parametre değişkenine verilen default değerin sabit ifadesi olması gerekmez. Ancak isim aramsında bulunuyor olması gerekir. Örneğin:

	int g_x = 10;

	void foo(int a, int b = g_x)
	{
		//...
	}

	Verilen ilkdeğerler değişkenin türüne uygun olması koşuluyla herhangi bir türden olabilir. 

	Ancak bir parametre değişkenine verilen default değerde diğer parametre değişkenleri kullanılamaz. Örneğin:

	void foo(int a, int b = a + 1)		// geçersiz!
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void dispmsg(const char *msg = "Ok")
{
    cout << msg << endl;
}

int main(void)
{
    dispmsg();
    dispmsg("error");

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Default değer alan parametre değişkenlerine sahip fonksiyonlarda default değerler prototipte belirtilebilirler (genellikle böyle yapılır). Default değerler
	hem prototipte hem de tanımlamada belirtilemezler. Ya prototipte (tercih böyle olmalıdır) ya da tanımlamada belirtilmelidirler. Örneğin:

	void foo(int a = 10, int b = 20);
	void bar(double = 3.14);

	void foo(int a = 10, int b = 20)		// error!
	{
		//...
	}

	void bar(double a)						// geçerli
	{
		//...
	}

	Bazı default değerler prototipte, bazıları ise tanımlama sırasında belirtilebilirler. Ancak bu durumdan kaçınmak gerekir:

	void foo(int a, int b = 10);

	void foo(int a = 20, int b)		// geçerli, ama kötü teknik!
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void dispmsg(const char *msg = "Ok");

int main(void)
{
    dispmsg();
    dispmsg("error");

    return 0;
}

void dispmsg(const char *msg)
{
    cout << msg << endl;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Parametre değişkenlerine verilen default değerlerin yaygın kullanılan değerlerden olması gerekir. Aksi takdirde parametre değişkenin default değer 
	almasının bir anlamı yoktur. Parametre değişkenlerine herhangi bir değeri default değer olarak vermek kötü bir tekniktir. Örneğin:,
	
	int add(int a = 10, int b = 20)
	{
		return a + b;
	}

	Burada verilen default değerlerin diğer değerlerdne hiçbir farklılığı yoktur. Dolayısıyla böyle bir kullanım kötü bir tekniktir. Fakat örneğin:

	void disp_number(int a, int base = 10);

	Burada fonksiyonun ikinci parametresi birinci parametresindeki int değerin kaçlık sistemde ekrana yazdırılacağını belirtiyor olsun. Burada verilen default değer
	anlamlıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    23) C++'ta parametrik yapılar farklı olmak koşuluyla aynı faaliyet alanında aynı isimli birden fazla fonksiyon bulunabilir. Bu duruma "function overloading" 
	denilmektedir. Halbuki C'de hiçbir durumda aynı isimli birden fazla fonksiyon bulunamamaktadır. Parametrik yapıların farklı olması demek parametrelerin türce veya
	sayıca farklı olması demektir. Parametre değişkenlerinin isimlerinin ve fonksiyonların geri dönüş değerlerinin türlerinin bu bağlamda bir önemi yoktur. Önemli olan 
	parametre değişkenlerinin türlerinin farklı olmasıdır. Örneğin aşağıdaki foo fonksiyonları C++'ta birlikte bulunabilir:

	void foo(int a)
	{
		//...
	}

	void foo(double a)
	{
		//...
	}

	void foo(int a, int b)
	{
		//...
	}

	void foo()
	{
		//...
	}

	Ancak aşağıdaki fonksiyonlar bir arada bulunamazlar:

	void bar(int a)
	{
		//...
	}

	void bar(int b)
	{
		//...
	}

	int bar(int c)
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aynı isimli bir fonksiyon çağrıldığında o fonksiyonlardan hangisinin çağrıldığının tespit edilmesi sürecine "overload resolution" denilmektedir. Overload resolution
	işleminin bazı ayrıntılı kuralları vardır. Ancak en basit haliyle şu söylenebilir: Çağrılma ifadesindeki argümanların türleriyle tam uyuşan bir fonksiyon varsa 
	o fonksiyon çağrılır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a)
{
	cout << "int" << endl;
}

void foo(long a)
{
	cout << "long" << endl;
}

void foo(double a)
{
	cout << "double" << endl;
}

void foo(int a, int b)
{
	cout << "int, int" << endl;
}

void foo(const char *s)
{
	cout << "const char *" << endl;
}

int main(void)
{
	long x = 100;

	foo(10);			// int
	foo(10.2);			// double
	foo("ankara");		// const char *
	foo(x);				// long
	foo(10, 20);		// int, ints

	return 0;                                                                 
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çağrılma ifadesindeki argümanların türleriyle tam uyuşan bir fonksiyon yoksa derleyici bazı kurallara göre mevcut fonksiyonların içerisinden birini seçebilmektedir
	ya da çağrıyı geçersiz kabul edebilmektedir. İşte bu noktada "overload resolution" işleminin bazı ayrıntıları devreye girmektedir. Overload resolution işlemi
	üç aşamada yürütülmektedir:

	1) Önce aday fonksiyonlar (candidate functions) belirlenir.
	2) Aday fonksiyonların içerisinden uygun (viable) olanlar seçilir. 
	3) Uygun olanlar arasında en uygun olan (the best viable) seçilmeye çalışılır. 

	- İlgili faaliyet alanında çağrılma ifadesi ile aynı isimli olan tüm fonksiyonlar aday fonksiyonlardır. 

	- Çağrılma ifadesindeki argümanların sayısı ile aynı sayıda parametre değişkenine sahip olan ve her argümandan parametre değişkenine otomatik (implicit) tür 
	dönüştürmesinin mümkün olduğu fonksiyonlar uygun fonksiyonlardır. (yani uygun fonksiyon demek "eğer fonksiyon tek başına bulunsaydı çağrılabilirdi" demektir.)

	- En uygun fonksiyon her argüman parametre deönüştürmesi diğer uygun fonksiyonlara göre ya daha iyi olan ya da daha kötü olmayan fonksiyondur. Eğer böyle tek bir 
	fonksiyon varsa o fonksiyon en uygun fonksiyon olarak seçilir. Eğer bu biçimde birden fazla fonksiyon varsa ya da hiçbir fonksiyon yoksa çağırma işlemi error ile 
	sonuçlanır. Otomatik dönüştürmeler (implicit conversions) arasında kalite farklılıkları vardır. Kalite farklılıklarının özet durumu iyiden kötüye doğru şöyledir:

		- Aynı türe yapılan dönüştürmeler (burada aslında dönüştürme de söz konusu değildir) en iyi durumdur. 
		- int türden küçük olan türlerin int türüne dönüştürülmesi (integral promotion) ya da float türünden double türüne yapılan dönüştürmeler (floating point promotion) ikinci iyi durumu oluşturmaktadır. 
		- C++'ın temel türleri arasındaki dönüştürmelerin hepsi standart dönüştürmelerdir (standard conversion). Bu üçğnc kaliteyi oluşturur. Örneğin int --> long 
		dönüştürmesi, int --> shor dönüştürmesi, int --> double dönüştürmesinin hepsi standart dönüştürmedir ve aynı kalitededir. 
		- Bir sınıf nesnesinin başka türe dönüştürülmesine ya da temel türlerin sınıf türlerine dönüştürülmesine "kullanıcı tanımlı tür dönüştürmeleri (user defined conversions)" denilmektedir. 
		Bu da son kaliteyi oluşturur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a, long b)					// 1
{
    cout << "int, long" << endl;
}

void foo(long a, long b)				// 2
{
    cout << "long, long" << endl;
}

void foo(double a, long b)				// 3
{
    cout << "double" << endl;
}

void foo(int a, int b)					// 4
{
    cout << "int, int" << endl;
}

void foo(double a, double b)			// 5
{
    cout << "double, double" << endl;
}

void foo(char a, short b)				// 6
{
    cout << "char, short" << endl;
}

void foo(int a, const char *s)			// 7
{
    cout << "int , const char *" << endl;
}

void foo(int a)							// 8
{
    cout << "int" << endl;
}

void bar(int a)							// 9
{
    cout << "bar, int" << endl;
}

int main(void)
{
    int a = 10;
    long b = 20;

    foo(a, b);		// int, long
    foo('a', 'b');	// ambiguity error!
    foo(10L, 2.3);  // ambiguity error!

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int a, int b)          // 1
{
    cout << "int, int" << endl;
}

void foo(double a, int b)       // 2
{
    cout << "double, int" << endl;
}

void foo(long a, long b)    // 3
{
    cout << "long, long" << endl;
}

int main(void)
{
    foo('a', 3.2);   // int, int
    //foo(3.2, 10L);   // ambiguity error
    foo('a', 'b');   // int, int

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyonun ismi ve sırasıyla parametre türlerinden oluşan dizilime "fonksiyonun imzası (function signature)" denilmektedir. İmzaya geri dönüş değerinin
	dahil olmadığına dikkat ediniz. Örneğin:

	void foo(int a, double b);

	Bu fonksiyonun imzası "foo, int, double" biçimindedir. Aynı imzaya sahip aynı faaliyet alanında birden fazla fonksiyon bulunamaz. Aşağıdaki iki fonksiyonun 
	imzası farklıdır:

	void foo(int a, long b);
	void foo(long a, int b);

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Overload resolution işleminde gösterici ve referanslardaki "top level olmayan" const ve volatile niteleyicisi kaliteyi etkilemektedir. Her zaman kendi niteleyicine dönüştürme
	daha iyidir. Örneğin:

	void foo(const int *pi);		// 1
	void foo(int *pi);				// 2

	const int a = 10;
	foo(&a);						// 1 seçilir, çünkü 2 zaten uygun (viable) bile değil

	int b = 10;
	foo(&b);						// int * --> int * dönüştürmesi, int * --> const int * dönüştürmesinden daha iyidir. 1 numaralı fonksiyon seçilir. 

	void bar(int &r);				// 1
	void bar(const int &r);			// 2

	int a = 10;
	bar(a);							// 1 tercih edilir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &r)                // 1
{
    cout << "int &" << endl;
}

void foo(const int &r)          // 2
{
    cout << "const int &" << endl;
}

int main(void)
{
    int a{10};

    foo(a);         // 2

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sol taraf değeri referansına ilişkin parametreye sahip bir fonksiyon ile aynı türden parametreye sahip bir fonksiyon birlikte bulunabilir. Bunların imzaları 
	farklıdır. Ancak çağrım sırasında iki anlamlılık htaları ortaya çıkabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(int &r)                // 1
{
    cout << "int &" << endl;
}

void foo(int a)          		// 2
{
    cout << "int" << endl;
}

int main(void)
{
    int a = 10;
    
    foo(a);     // ambiguity error!
    foo(10);    // 2 seçilir çünkü 1 uygun fonksiyon değil

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aynı isimli default değer alan fonksiyonlar eğer parametre türleri farklıysa bir arada bulunabilirler. Ancak bunların çağrılması sırasında iki anlamlılık hataları 
	ortaya çıkabilir. Örneğin:

	void foo(int a = 10, int b = 20);		// imzası: foo, int, int
	void foo(int a);						// imzası: foo, int
	//...
	foo(10, 20);							// geçerli, ilk fonksiyon çağrılır.
	foo();									// geçerli, ilk fonksityon çağrılır. İkinci fonksiyon uygun (viable) değil
	foo(10);								// embiguity error! İki fonksiyon da uygun ve en uygun fonksiyon yok
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    24) C++'ta global "isim kirliliğini (name pollution)" engellemek için "isim alanları (namespaces)" biçiminde bir özellik bulunmaktadır. Bir projede farklı firma ya da kurumların
	kütüphanelerinin bir arada kullanıldığı durumlarda "isim çakışmaları (name collision)" oluşabilmektedir. Örneğin A firmasının kütüphanesi ile B firmasının kütüphanesini
	birlikte kullanırken bu iki firma tesadüfen bir yapı ya da sınıfa aynı isimleri vermiş olabilirler. Bu önemli bir problemdir. İşte isim alanları bu problemleri ortadan
	kaldırmak için düşünülmüştür. 

	Bir isim alanı bildiriminin genel biçimi şöyledir:

	namespace <isim> 
	{
		// namespace içindeki eleman bildirimleri
	}

	Aynı isim alanı içerisinde aynı isimli birden fazla değişken tanımlanamaz. Ancak farklı isim alanlarında aynı isimli değişkenler tanımlanabilmektedir. Farklı isim alanlarındaki 
	aynı isimli fonksiyonlar için "overload" terimi kullanılmaz. Çünkü "overload" aynı faaliyet alanındaki fonksiyonlar için kullanılmaktadır. Yerel bir bloğun içerisinde isim alanı oluşturulamaz.
	İsimn alanları global bölgede oluşturulur.

	Bir isim alanı içerisindeki bir isme isim alanı ismi ve :: operatörü ile erişilir. :: operatörü iki operandlı araek bir operatördür. Bu operatöre 
	"çözünürlük operatörü (scope resolution operator)" denilmektedir. Örneğin:

	CSD::foo();

	bigi bir ifadede bir z foo fonksiyonunun CSD isim alanı içerisinde olduğunu belirtmekteyiz.

	Her kurum global isimlerini kendine özgü bir isim alanı içerisinde oluşturursa global isim kirliliği büyük ölçüde engellenmiş olur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
    int a = 10;

    void foo()
    {
        cout << "CSD::foo" << endl;
    }
}

namespace Other
{
    int a = 20;

    void foo()
    {
        cout << "Other::foo" << endl;
    }
}

int main(void)
{
    cout << CSD::a << endl;
    cout << Other::a << endl;

    CSD::foo();
    Other::foo();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İç içe isim alanları söz konusu olabilir. Bu durumda içteki isim alanınıun elemanlarına birden fazla çözünürlük operatörü kullanılarak erişilebilir. Örneğin:
	
	CSD::Util::bar();

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
    int a = 10;

    void foo()
    {
        cout << "CSD::foo" << endl;
    }

    namespace Util
    {
        void bar()
        {
            cout << "CSD::Util::bar" << endl;
        }
    }
}

int main(void)
{
   CSD::foo();
   CSD::Util::bar();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İç bir isim alanı C++17 ile birlikte artık hamlede bildirilebilmektedir. Örneğin:

	namespace A::B::C 
	{
		//...
	}

	bildirimi aşağıdaki ile eşdeğerdir:

	namespace A
	{
		namespace B 
		{
			namespace C
			{
				//...
			}
		}
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A::B::C
{
    void foo()
    {
        cout << "A::B::C::foo" << endl;
    }
}

int main(void)
{
   A::B::C::foo();
   
    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aynı isim alanını birden fazla kez bildirmek tamamen geçerli bir durumdur. Bu durum isim alanına ekleme yapıldığı anlamına gelir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A
{
    void foo()
    {
        cout << "A::foo" << endl;
    }
}

namespace A                 // geçerli
{
    void bar()
    {
        cout << "A::bar" << endl;
    }
}

int main(void)
{
    A::foo();
    A::bar();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii farklı isim alanlarının içerisindeki aynı isim alanları aslında farklı isim alanlarıdır. Burada ekleme işlemi söz konusu değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
    namespace A
    {
        void foo()
        {
            cout << "A::foo" << endl;
        }
    }
}

namespace A
{
    void bar()
    {
        cout << "A::bar" << endl;
    }
}

int main(void)
{
    CSD::A::foo();
    A::bar();

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Hiçbir isim alanının içerisinde olmayan global bölge de bir isim alanı belirtmektedir. O bölgeye "global isim alanı (global namespace)" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
    void foo()                  // global isim alanı içerisindeki CSD isim alanının içerisinde
    {
        cout << "A::foo" << endl;
    }
}

void foo()                  // global isim alanının içersinde
{
    cout << "foo" << endl;
}

int main(void)
{
    CSD::foo();     // CSD'nin içerisindeki foo çağrılıyor
    foo();          // global isim alanı içerisindeki foo çağrılıyor

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir fonksiyonun prototipi bir isim alanı içerisinde bildirilip tanımlaması onu kapsayan herhangi bir isim alanında isim alanı ismi belirtilerek yapılabilir.
	Tabii tanımlama yapılırken isim alanları belirtilmelidir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A
{
	namespace B
	{
		void foo();
		void bar();
		void tar();
		//...

		void B::foo()
		{
			cout << "A::B::foo" << endl;
		}
	}

	void B::bar()
	{
		cout << "A::B::bar" << endl;
	}
}

void A::B::tar()
{
	cout << "A::B::tar" << endl;
}

int main(void)
{
	A::B::foo();
	A::B::bar();
	A::B::tar();
	
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta çözünürlük operatörünün sol tarafı boş bırakılırsa isimler her zaman global isim aalanında aranır. Yani çözünürlük operatörünün iki operabd'lı ve tek operand'lı
	biçimleri vardır. Çözünürlük operatörünün tek operand'lı biçimi isim aramasını global isim alanında yapmaktadır.

	::foo();

	Burada global isim alanındaki foo çağrılmıştır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo()
{
	cout << "foo" << endl;
}

namespace CSD
{
	void foo()
	{
		cout << "CSD::foo" << endl;
	}

	void bar()
	{
		foo();		// CSD::foo
		::foo();	// global isim alanındaki foo
	}
}

int main(void)
{
	CSD::bar();

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon çağrıldığında önce isim araması yapılır. İsim bulunursa o faaliyet alanındaki aynı isimli fonksiyonlar aday fonksiyon olarak overload resolution
	işlemine sokulur. Daha üst isim alanlarındaki fonksiyonlar aday fonksiyon olarak seçilmezler. Yani overload işlemi aynı isim alanındaki aynı isimli fonksiyonların
	bulunması anlamına gelmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace A
{
	void foo(const char *str)
	{
		cout << "A::foo const char *" << endl;
	}

	namespace B
	{
		void foo(double a)
		{
			cout << "A::B::foo double" << endl;
		}

		namespace C
		{
			void foo(int a)
			{
				cout << "A::B::C::foo int" << endl;
			}

			void bar()
			{
				foo(12.3);		// A::B::C::foo çağrılıyor
				foo("ankara");	// error;
			}
		}
	}
}

int main()
{
	A::B::C::bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın standart kütüphanesi ve C++'ta C'nin standart kütüphanesi içerisindeki tüm öğeler "std" isimli bir isim alanı içerisine yerleştirilmiştir. Bu nedenle
	bu isimler kullanılırken isimlerin "std" ismi ile niteliklendirilmesi gerekir. Aksi takdirde isimler global isim alanında aranır ve o isim alanında
	bulunamayacaklardır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

int main(void)
{
	std::cout << "this is a test" << std::endl;
	
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
   25) Gereksiz niteliklendirmeyi elimine edebilmek için "using namespace direktifi" denilen bir direktiften faydalanılmaktadır. 
   using namespace direktifinin genel biçimi şöyledir:

	using namespace <isim alanı ismi>;

	Burada isim alanı ismi tek bir isimden olabileceği gibi :: operatörü kullaılarak iç bir isim alanı biçiminde de olabilir. Örneğin:

	using namespace CSD;
	using namespace CSD::Util
	using namespace std;

	using namespace direktifi bir isim alanına ya da yerel bir bloğa yerleştirilebilir (bir sınıf içerisine yerleştirilemez). Tabii using namespace direktifinde belirtilen 
	isim alanının daha önce derleyici tarafından görülmüş olması gerekmektedir. 

	using namepspace direktifinde iki isim alanı söz konusudur. Birincisi direktifin yerleştirildiği isim alanı, ikincisi direktifte belirtilen isim alanı. 
	Eğer direktif bir yerel bloğa yerleştirilmişse direktifin yerleştirildiği isim alanı o yerel bloğu kapsayan isim alanıdır. 

	Derleyici using namespace direktifini gördüğünde önce direktifin yerleştirildiği isim alanı ile direktifte belirtilen isim alanını kapsayan en dar isim alanını tespit eder. 
	Örneğin:

	namespace A
	{
		namespace B
		{
			//...
		}

		using namespace B;
		//...
	}

	Burada direktifin yerlşetirildiği isim alanı A'dır. Direktifte belirtilen isim alanı ise B'dir. İkisini kapsayan en dar isim alanı A'dır. Örneğin:

	using namespace std;

	Burada direktifin yerleştirildiği isim alanı global isim alanıdır. Direktifte belirtilen isim alanı ise std isim alanıdır. İkisini de kapsayan en dar isim alanı global 
	isim alanıdır. Örneğin:

	namespace A
	{
		namespace B
		{
			namespace C
			{

			}
		}

		using namespace B::C;
		//...
	}

	Burada direktifin yerleştirildiği isim alanı A, direktifte belirtilen isim alanı A::B::C'dir. İki isim alanını kapsayan en dar isim alanı A'dır.
	Direktif şöyle etki gösterir: Sanki direktifte belirtilen isim alanının içerisindekiler direkttifin yerleştirildiği ve direktifte belirtilen isim alanı kapsana en 
	dar isim alanına enjekte edilmektedir. Ancak bu enjekte edilme niteliksiz isim aramaları (unqualified name lookup) sırasında (yani doğrudan yazılan isimlerin aranması sırasında)
	etkili olmaktadır. Ayrıca bu etki yalnızca direktifin yerleştirildiği faaliyet alanında oluşturulmaktadır. Örneğin:
	
	#include <iostream>

	using namespace std;

	int main()
	{
		cout << "this is a test" << endl;

		return 0;
	}

	Burada sanki std isim alanı içerisindeki her şey global isim alanındaymış gibi bir etki oluşturulmuştur. Böylece cout ve endl isimleri aslında std ieim alanında olduğu 
	halde derleyici tarafından bulunacaktır.
	
	Aşağıdaki örnekte direktifin yerleştirildiği isim alanı A::B::C isim alanıdır. Direktifite belirtilen isim alanı std isim alanıdır. İki isim alanını kapsayan en dar 
	isim alanı global isim alanıdır. O halde std isim alanı içerisindeki isimler sanki global isim alanındaymış gibi bir etki oluşturulacaktır. Ancak bu etki
	yalnızca direktifin yerleştirildiği (A::B::C) isim alanındaki armalar için oluşturulmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

namespace A
{
	namespace B
	{
		namespace C
		{
			using namespace std;

			void foo()
			{
				cout << "A::B::C::foo" << endl;		// geçerli
			}
		}
	}
}

int main(void)
{

	cout << "this is a test" << endl;		// error!
	
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace direktifinin yerleştirildiği isim alanı ile direktifteki isim alanında aynı isimler bulunursa ve bu isimler kullanılırsa bu durumda isim araması sırasında
	sorun ortaya çıkar. Örneğin std isim alanı içerisinde bulunan cout ismi global isim alanında olsaydı. Bu durumda using namespace std direktifi uygulandığında
	cout isminin hangi cout olduğu anlaşılamayacaktı. Bu tür durumlarda using namespace direktifini kullanmayıp ve açıkça niteliklendirme yapılabilir. Ya da yalnızca çalışan isimler 
	için niteliklendirme yapılabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
	void foo()
	{
		cout << "CSD::foo" << endl;
	}

	void bar()
	{
		cout << "CSD::bar" << endl;
	}
}

void foo()
{
	cout << "foo" << endl;
}

using namespace CSD;

int main(void)
{
	bar();			// geçerli
	foo();			// error! Hangi foo anlaşılamaz!
	CSD::foo();		// geçerli
	CSD::foo();
	
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    using namespace direktifi yerel bloklara da yerleştirilebilir. Bu durumda yukarıda açıkladığımız etki yalnızca o yerel blokta etkiş gösterir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

int main(void)
{
	using namespace std;

	cout << "this is a test" << endl;


	return 0;                                                               
}

void foo()
{
	cout << "this is a test" << endl;		// error!
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii niteliksiz isim arama sırasında (bu konuda ileride ele alınacaktır) isimlerin enjekte edildiği isim alanına sıra gelene kadar isim daha önceki isim alanlarında 
	bulunuyor olabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD
{
	void foo()
	{
		cout << "CSD::foo" << endl;
	}
}

namespace A
{
	void foo()
	{
		cout << "A::foo" << endl;
	}

	namespace B
	{
		using namespace CSD;

		namespace C
		{
			void bar()
			{
				foo();			// A::foo()
			}
		}
	}
}

int main(void)
{

	A::B::C::bar();

	return 0;                                                               
}

void foo()
{
	cout << "this is a test" << endl;		// error!
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace direktifi yerel bloğa da yerleştirilebilir. Bu durumda direktifin yerleştirildiği isim alanı yerel bloğun içinde bulunduğu isim alanıdır. 
	Ancak bu etki yalnızca o yerel blokta geçerli olur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

int main()
{
	using namespace std;

	cout << "test1" << endl;		// geçerli

	return 0;
}

void foo()
{
	cout << "test2" << endl;		// error!
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace direktifi geçişlidir. A isim alanında B isim alanı için using namespace direktifi yapılmış olsun. Biz de A isim alanına using namespace direktifi uygulayalım. 
	Bu durumda sanki biz hem A isim alanına hem de B isim alanına using namespace direktifi uygulamış gibi oluruz. Örneğin:

	namespace A 
	{
		//...
	}

	namespace B
	{
		using namespace A;
		//...
	}

	using namespace B;

	İşlemi aşağıdaki ile eşdeğerdir:

	namespace A 
	{
		//...
	}

	namespace B
	{
		//...
	}

	using namespace B;
	using namespace A;

	Bu biçimde geçişlilik devam eder. 


--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;


namespace A 
{
	void foo()
	{
		cout << "A::foo" << endl;
	}
}

namespace B 
{
	using namespace A;

	void foo()
	{
		cout << "B::foo" << endl;
	}

	namespace C	
	{
		using namespace B;

		void bar()
		{
			foo();		// B::foo
		}
	}
}

int main()
{
	B::C::bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    İsim :: operatörü ile nitelikli olarak bir isim alanında aranıyorsa ve isim o isim alanında bulunamazsa o isim alanındaki using direktifleri 
	ile belirtilen isim alanlarında da aranır. (Eğer isim o isim alanında bulunursa using direktifinde belirtilen isim alanlarına hiç bakılmaz.)
	Burada da kademeli geçişlilik söz konusudur.  

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <chrono>

using namespace std;
using namespace std::chrono;

namespace A 
{

	void foo()
	{
		cout << "A::foo" << endl;
	}
}

namespace B 
{
	using namespace A;

	void foo()
	{
		cout << "B::foo" << endl;
	}
}

namespace C
{
	using namespace B;

	void foo()
	{
		cout << "C::foo" << endl;
	}
}

int main()
{
	C::foo();		// C::foo çağrılacak. C'de foo olmasaydı B::foo çağrılırdı, B'de de foo olmasaydı A::foo çağrılırdı

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    26) using namespace direktifinin dışında C++'ta ayrıca bir de "using bildirimi" denilen bir bildirim de vardır. using bildirimi bir isim alanındaki ismi bir faaliyet alanına
	sokmak için kullanılmaktadır. Bu nedenle bu bir direktif değil bildirimdir. Çünkü bildirimlerde yeni bir isim bir faaliyet alanına katılmaktadır. using bildiriminin 
	genel biçimi şöyledir:

	using <isim alanı ismi>::<isim>, [...];

	Buradaki isim alanı ismi iç bir isim alanı (nested namespace) belirtebilir. Örneğin:

	using std::cout, std::endl;
	//...
	cout << "this is a test" << endl;

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using std::cout, std::endl;

int main(void)
{
	int a;

	cout << "this is a test" << endl;

	cin >> a;		// error!
		
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    27) C++11 ile birlikte C++'a "using type alias" diye isimlendirilen typedef işleminin using anahtar sözcüğüyle yapılmasına ilişkin bir özellik de eklenmiştir. using tür 
	bildirimimin genel biçimi şöyledir:

	using <yeni isim> = <tür>;

	using ile tür ismi oluşturmanın typedef ile tür ismi oluşturmaktan neredeyse hiçbir farkı yoktur (template konusuna ilişkin çok küçük bazı farklılıklar söz konusudur).
	Bir using ile tek bir tür ismi bildirilebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

using I = int;		// eşdeğeri typedef int I;
using PI = int *;	// eşdeğeri typedef int *PI;
using RI = int &;	// eşdeğeri typedef int &RI;
using IA = int[3];	// eşdeğeri typedef int IA[3];

int main(void)
{
	I a;
	PI pi;

	a = 10;

	cout << a << endl;

	pi = &a;
	cout << *pi << endl;

	RI b = a;
	cout << b << endl;

	IA ia{ 1, 2, 3 };

	for (int x : ia)
		cout << x << " ";
	cout << endl;
		
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    						C++'ın Nesne Yönelimli Programlama Tekniği İle Doğrudan İlgili Olan Farklılıkları ve fazlalıkları

	Bu bölümde biz artık C++'ı "nesne yönelimli (object oriented)" bir dil yapan sınıf ve onunla ilgili konuları ele alacağız.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ı Nesne Yönelimli bir dil yapan en önemli özellik "sınıflar (classes)" konusudur. Sınıflar C'deki yapılara benzer olmakla birlikte yalnızca data değil aynı zamanda
	fonksiyon da içeren veri yapılarıdır. Yani C'deki yapılar yalnızca data içerirken C++'taki sınıflar aynı zamanda fonksiyon da içermektedir. Zaten C'deki yapılar da artık C++'ta
	sınıf ile aynı anlamdadır. C++'ta bir sınıf hem data hem fonksiyon içermek zorunda değildir. Bu durumda sınıf kavramı aslında C'deki yapılar üzerinde bir fazlalık
	gibi değerlendirilebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf bildiriminin genel biçimi şöyledir:

	class <isim> {
		<data ve fonskiyon bildirimleri>
	};

	struct <isim> {
		<data ve fonksiyon bildirimleri>
	};

	Örneğin:

	class Sample {
	//...
	};

	struct Sample {
		//...
	};

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta bir sınıfın içerisindeki fonksiyonlara "üye fonksion (member function)" denilmektedir. Halbuki Java, C#, Python gibi dillerde buna "metot (method)" denilmektedir. 
	C++'ta bir sınıf "public", "protected" ve "private" olmak üzere üç bölümden oluşmaktadır. Bir bölüm, bölüm belirten anahtar sözcük ve ':' atomu ile başlatılır, 
	başka bir bölüm belirten anahtar sözcüğe kadar devam eder. Sınıf bildirimi içerisinde bu bölüm belirten anahtar sözcükler birden fazla kez kullanılabilirler. Örneğin:

	class Sample {
	public:
		//...
	protected:
		//...
	private:
		//...
	public:
		//...
	private:
		//...
	};

	Sınıf isimleri pek çok programcı tarafından "Pascal tarzı (Pascal casting)" ile isimlendirilmektedir. Pascal tarzında her sözcüğün ilk harfi büyük harf ile yazılır.
	Biz de kursumuzda bu isimlendirmeyi tercih edeceğiz. Ancak C++'ın standart kütüphanesindeki sınıf isimleri "klasik C tarzı (snake casting)" ile isimlendirilmiştir.

	Bir sınıf bildirimine hiçbir bölüm belirten anahtar sözcük ile başlanmazsa bu durumda sınıf bildirimi class anahtar sözcü ile yapılmışsa default bölüm "private",
	struct anahtar sözcüğü ile yapılmışsa default bölüm "public" biçimdedir. Bunun dışında sınıf bildiriminin class ya da struct anahtar sözcüğüyle yapılmasının bir farkı yoktur.
	struct bildiriminde C ile uyumu korumak amacıyla default bölüm public yapılmıştır.

	Biz bu bölümlerin ne anlam ifade ettiğini görene kadar sınıf elemanlarını hep public bölüme yerleştireceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıfın üye fonksiyonlarının yalnızca prototipleri sınıf bildirimi içerisinde belirtilebilir. Tanımlamaları o sınıfın içinde bulunduğu isim alanında ya da o isim alanını 
	kapsayan isim alanlarından birinde yapılabilir. Fonksiyon tanımlaması sınıf dışında yapılırken fonksiyon isminin sınıf ismi ile :: operatörü ile niteliklendirilmesi gerekir. 
	Genel biçim şöyledir:

	<geri dönüş değerinin türü> <sınıf ismi>::<fonksiyon ismi>([prametre bildirimi])
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar(int a);
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar(int a)
{
	cout << "Sample::bar" << endl;
}

int main(void)
{
	//...
		
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir üye fonksiyonun tanımlaması sınıf içerisinde yapılabilir. Ancak bu durumda üye fonksiyon inline kabul edilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo()
	{
		cout << "Sample::foo" << endl;
	}

	void bar(int a)
	{
		cout << "Sample::bar" << endl;
	}
};

int main(void)
{
	//...
		
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta her sınıf bir tür de belirtir. Sınıflar türünden nesneler tanımlanabilir. Örneğin:

	class Sample {
		//...
	};

	Sample s;			// s nesnesi Sample türünden
	class Sample k;		// tür isminde class ve struct sözcükleri de kullanılabilir, ancak gereksizdir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesi içerisinde sınıfın üye fonksiyonları (member functions) yer kaplamaz. Üye fonksiyonlar mantıksal bakımdan sınıfla ilişkilendirilmiş durumdadır. 
	Üye fonksiyonlar tıpkı global fonksiyonlar gibi programın ".text" denilen bölümünde yer kaplarlar. Sınıf nesnesi içerisinde yalnızca sınıfın 
	"static olmayan veri elemanları (nonstatic data member)" yer kaplamaktadır. C++'ta sınıf içerisindeki data elemanlarına "veri elemanları (data member)" denilmektedir.
	Veri elemnanları static olabilir ya da static olmayabilir. Static veri elemanları ileri ele alınacaktır.

	Sınıf türünden türünden nesneler veri elemanlarından oluşan bileşik nesnelerdir. C++ standartlarına göre aynı bölüm içerisindeki veri elemanları ilk yazılan eleman 
	düşük adreste olacak biçimde ardışıl bir biçimde yerleştirilir. Ancak farklı bölümlerdeki elemanların birbirlerine göre durumu standartlarda derleyicileri
	yazanların isteğine bırakılmıştır. Fakat yaygın tüm derleyiciler bölüm farkı gözetmeksizin ilk yazılan eleman düşük adreste olacak biçimde ardışıl bir yerleşim 
	uygulmaktadır. Tabii yine derleyiciler C'de olduğu gibi elemanlar arasında hizalama amaçlı kontrollü boşluklar bırakabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar(int a);
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar(int a)
{
	cout << "Sample::bar" << endl;
}

int main(void)
{
	Sample s;	// s'in içerisinde yalnızca a ve b veri elemanları yer kaplıyor.

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Madem ki C++'ta artık fonksiyonlar sınıfların da içerisinde bulunabiliyorlar o zaman biz sınıfların ieçrisinde bulunmayan fonksiyonları vurgulamak için
	"global fonksiyonlar" diyeceğiz. Global fonksiyon demekle global isim alanı içerisinde bulunan fonksiyonları değil sınıf içerisinde bulunmayan herhangi bir isim alanı 
	içerisinde bulunan fonksiyonları kastedeceğiz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Üye fonksiyonlar global fonksiyonlar gibi doğrudan isim belirtilerek çağrılmazlar. Üye fonksiyonlar ilgili sınıf türünden bir nesne ile "." operatörü kullanılarak
	çağrılırlar. Örneğin:

	Sample s;

	s.foo();
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar();
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar()
{
	cout << "Sample::bar" << endl;
}

void foo()
{
	cout << "global foo" << endl;
}

void bar()
{
	cout << "global bar" << endl;
}

int main(void)
{
	foo();		// global foo
	bar();		// global bar

	Sample s;		// s nesnesi Sample türünden

	s.foo();		// Sample sınıfının üye fonksiyonu olan foo
	s.bar();		// Sample sınıfının üye fonksiyonu olan bar

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta "sınıf faaliyet alanı (class scope)" isminde yeni bir faaliyet alanı daha vardır. Sınıf faaliyet alanı sınıf bildiriminin içerisinde ve
	sınıfın tüm üye fonksiyonları içerisinde bir ismin doğrudan kullanılabilirliğini anlatmaktadır. Bu durumda C++'ta faaliyet alanları genişten dara doğru 
	şöyledir:

	- Dosya faaliyet alanı (file scope)
	- Sınıf faaliyet alanı (class scope)
	- Fonksiyon faaliyet alanı (function scope)
	- Block faaliyet alanı (block scope)

	Sınıfın tüm elemanaları yani sınıf bildirimi içerisinde bildirilen tüm isimler sınıf faaliyet alanı kuralına uyarlar. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar();
};

void Sample::foo()
{
	a = 10;			// geçerli, a sınıf faaliyet alanına ilişkin 
	b = 20;			// geçerli b sınıf faaliyet alanına ilişkin 
}

void Sample::bar()
{
	cout << a << endl;	// geçerli, a sınıf faaliyet alanına ilişkin 
	cout << b << endl;	// geçerli b sınıf faaliyet alanına ilişkin 

	foo();				// geçerli foo sınıf faaliyet alanına ilişkin
}

int main(void)
{
	//...

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf elemanlarına (yani veri elemanları ve üye fonksiyonları) o sınıf türünden bir nesneyle ve nokta operatörü kullanılarak nitelikli bir biçimde de 
	erişilebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar();
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar()
{
	cout << "Sample::bar" << endl;
}

int main(void)
{
	Sample s;

	s.a = 10;
	s.b = 20;

	cout << s.a << endl;
	cout << s.b << endl;

	s.foo();
	s.bar();

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir üye fonksiyonun içerisinde kullanılan sınıfın veri elemanları aslında o üye fonksiyon hangi nesne ile çağrılmışsa o nesnenin veri elemanlarıdır. 
	Zaten üye fonksiyonların nesne ile çağrılmasının nedeni budur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void foo();
	void bar();
};

void Sample::foo()
{
	a = 10;
	b = 20;
}

void Sample::bar()
{
	cout << a << endl;
	cout << b << endl;
}

int main(void)
{
	Sample s;

	s.foo();		// foo'nun içerisinde kullanıolan a ve b s'nin a ve b'si
	s.bar();		// bar'ın içerisinde kullanılan a ve b s'nin a ve b'si

	cout << s.a << " " << s.b << endl;

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi bir üye fonksiyonun içerisinde kullanılan sınıfın veri elemanlarının hangi nesnenin elemanları olduğu o fonksiyon çağrılmadan 
	bilinmemektedir. Biz üye fonksiyonu hangi nesne ile çağırırsak onun içerisinde veri elemanları o nesnenin veri elemanları olur. Örneğin:

	s.foo();
	k.foo();
	
	Burada foo içerisindeki veri elemanları birinci çağrıda s nesnesinin elemanları iken ikinci çağrıda k nesnesinin elemanları olmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void set(int x, int y);
	void disp();
};

void Sample::set(int x, int y)
{
	a = x;
	b = y;
}

void Sample::disp()
{
	cout << "a = " << a << ", b = " << b << endl;
}

int main(void)
{
	Sample s, k;

	s.set(10, 20);
	k.set(30, 40);

	s.disp();
	k.disp();
	
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın bir üye fonksiyonu başka bir üye fonksiyonunu doğrudan çağırabilir. Bu durumda çağıran üye fonksiyon hangi nesneyle çağrılmışsa
	çağrılan üye fonksiyonun da aynı nesneyle çağrılmış olduğu kabul edilir. 

	Aşağıdaki örnekte set üye fonksiyonu s nesnesi ile çağrılmıştır. Bu durumda set üye fonksiyonu içerisinde çağrılan disp üye fonksiyonunun da 
	s nesnesi ile çağrıldığı kabul edilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	void set(int x, int y);
	void disp();
};

void Sample::set(int x, int y)
{
	a = x;
	b = y;

	disp();
}

void Sample::disp()
{
	cout << "a = " << a << ", b = " << b << endl;
}

int main(void)
{
	Sample s;

	s.set(10, 20);

	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın üye fonksiyonları da overload edilebilir. Yani bir sınıf içerisinde parametrik yapıları farklı olan aynı isimli üye fonksiyonlar bulunabilir. 
	Bu durumda "overload resolution" işlemi daha önce açıkladığımız kurallarla yürütülmektedir. Örneğin:

	class Sample {
		public:
			void foo(int a);
			void foo(double a);
			void foo(const char *str);
			//...
	};

	Sample s;

	s.foo(10);		// foo(int)
	s.foo(12.3);	// foo(double)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın üye fonksiyonları sınıfın veri elemanları üzerinde işlem yapan fonksiyonlardır. Başka bir deyişle sınıfın veri elemanları aslında üye fonksiyonlar
	tarafından ortak kullanılan elemanlardır. Eğer bir üye fonksiyon sınıfın veri elemanları ile ilgili işlem yapmasaydı bu durumda o üye fonksiyon global bir fonksiyon gibi de
	yazılabilirdi.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesi yaratıldığında derleyici tarafından otomatik olarak çağrılan sınıfın özel üye fonksiyonlarına "yapıcı fonksiyonlar (constructors)" denilmektedir. 
	Yapıcı fonksiyonlar tipik olarak birtakım ilk işlemleri yapmak ve sınıfın veri elemanlarına birtakım ildeğerleri vermek için kullanılmaktadır. 

	Yapıcı fonksiyonlar sınıf ismiyle aynı isimli olan üye fonksiyonladır. Yapıcı fonksiyonlar da overload edilebilirler. Sınıfın parametresiz yapıcı fonksiyonuna özel olarak
	"default yapıcı fonksiyon (default constructor)" denilmektedir. 

	Yapıcı fonksiyonların geri dönüş değerleri diye bir kavramları yoktur. Bu nedenle yapıcı fonksiyonlarda geri dönüş değerlerinin türü yerine hiçbir şey yazılmaz.
	Geri dönüş değerinin türü yerine void yazmak da geçerli bir durum değildir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	Sample();
	Sample(int x, int y);
	
};

Sample::Sample()
{
	a = 0;
	b = 0;
}

Sample::Sample(int x, int y)
{
	a = x;
	b = y;
}

int main(void)
{
	
	return 0;                                                               
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesi eğer isimden sonra hiç parantez açılmadan tanımlanırsa bu durumda derleyici nesne için sınıfın default yapıcı fonksiyonunu (default constructor)
	çağırır. Örneğin:

	Sample s;

	Eğer isimden sonra parantezler açılırsa parantezlerin içerisine argümanlar yerleştirilir. Bu durumda overload resolution kuralına göre çağrılacak yapıcı fonksiyon
	tespit edilir. Örneğin:

	Sample s(10, 20);

	Bu durumda tüm aday fonksiyonlar sınıfın yapıcı üye fonksiyonlardır. Bunlar arasından uygun olanlar ve nihayet en uygun yapıcı fonksiyon seçilmeye çalışılır. 
	C++11 ile birlikte "uniform initializer" sentaks ile burada küme parantezleri de kullanılabilmektedir. Ancak uniform initializer sentaksında "narrowing conversion"a 
	izin verilmediğini anımsayınız. Örneğin:

	Sample s{10, 20};

	Burada "narrowing conversion" dikkate alınarak uygun fonksiyonlar tespit edilmemektedir. Önce en uygun fonksiyon overload resolution kurallarına göre bulunmakta 
	eğer bu en uygun fonksiyon narrowing conversion gerektiriyorsa error oluşmaktadır. 

	Default yapıcı fonksiyon çağrılacak biçimde nesne yaratma işlemi aşağıdaki gibi yapılamamaktadır:

	Sample s();

	Çünkü bu bir prototip bildirimidir. Tabii C++11 ile birlikte aşağıdaki tanımlama default yapıcı fonksiyonun çağrılması için geçerlidir:

	Sample s{};

	Çünkü böyle bir prototip bildirim sentaksı yoktur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	Sample();
	Sample(int x, int y);

};

Sample::Sample()
{
	cout << "default constructor" << endl;

	a = 0;
	b = 0;
}

Sample::Sample(int x, int y)
{
	cout << "int, int constructor" << endl;
	a = x;
	b = y;
}

int main(void)
{
	Sample s;
	Sample k(10, 20);

	cout << "ok" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yerel sınıf nesneleri için yapıcı fonksiyonlar programın akışı nesnenin tanımlandığı noktaya geldiğinde çağrılmaktadır. Ancak global sınıf nesneleri için yapıcı 
	fonksiyonlar akış main fonksiyonuna girmeden önce çalıştırılır. Global sınıf nesneleri için yapıcı fonksiyonların çağrılma sırası yukarıdan aşağıya doğrudur. 
	Ancak program birden fazla kaynak dosyadan oluşuyorsa bunlar arasındaki sıra "belirsiz (unspecified)" bırakılmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;
	int b;

	Sample();
	Sample(int x, int y);
};

Sample::Sample()
{
	cout << "default constructor" << endl;

	a = 0;
	b = 0;
}

Sample::Sample(int x, int y)
{
	cout << "int, int constructor" << endl;
	a = x;
	b = y;
}

Sample x;
Sample y(10, 20);

int main(void)
{
	cout << "main begins..." << endl;

	Sample k(30, 40);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yapıcı fonksiyonların içerisinde kullandığımız sınıfın veri elemanlarının o anda henüz yaratılmış olan nesnenin veri elemanları olduğuna dikkat ediniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Date {
public:
	int day, month, year;

	Date(int d, int m, int y);
	void disp();
};

Date::Date(int d, int m, int y)
{
	day = d;
	month = m;
	year = y;
}

void Date::disp()
{
	cout << day << '/' << month << '/' << year << endl;
}

int main(void)
{
	Date d{ 10, 12, 2007 };

	d.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Eğer programcı sınıf için hiçbir yapıcı fonksiyon yazmamışsa (standart terminolojisi ile sınıfın "user provided" yapıcı fonksiyonu yoksa) bu durumda derleyici 
	sınıf için default yapıcı fonksiyonu public bölümde içi boş olarak inline biçimde kendisi tanımlar. Böylece biz bir sınıf için hiçbir yapıcı fonksiyon yazmadıysak
	o sınıf türünden default yapıcı fonksiyonun çağrılacağı bir nesne tanımlayabiliriz. Eğer biz bir sınıf için herhangi bir yapıcı fonksiyon yazmışsak bu durumda
	derleyici default yapıcı fonksiyonu kendisi yazmamaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
	//...
};

class Mample {
public:
	Mample(int a)
	{}
};

int main(void)
{
	Sample s;		// geçerli, default yapıcı fonksiyon derleyici tarafındna yazılmış
	Mample k;		// geçersiz! sınıf için programcı yapıcı fonksiyon yazdığından dolayı artık derleyici 
					// default yapıcı fonksiyonu kendisi yazmaz.

	Mample m(10);	// geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte "explicitly defaulted constructor" biçiminde bir kavram dile eklenmiştir. Bir default yapıcı fonksiyon için prototipten sonra " = default"
	sentaksı kullanılırsa bu sentaks derleyiciye "default yapıcı fonksiyonu içi boş olarak sen yaz" anlamına gelmektedir. Örneğin:

	class Sample {
	public:
		Sample() = default;
		Sample(int a, int b);
		//...
	};

	Burada sınıfın başka bir yapıcı fonksiyonu olduğu için derleyici default yapıcı fonksiyonu kendiliğinden yazmayacaktır. İşte " = default" 
	sentaksı bunu sağlamaktadır. Tabii "= default" dentaksı yerine bir zaten içi boş bir default yapıcı fonksiyonu kendimiz de oluşturabilirdik. Ancak teknik anlamda 
	aşağıdaki yazım arasında bazı ince farklılıklar vardır:

	Sample() = default;
	Sample() {}

	Bu farklılıklar hakkında henüz bir açıklama yapmayacağız.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yine C++11 ile birlikte "deleted constructor" sentaksı da dile eklenmiştir. Bir default yapıcı fonksiyonda " = delete" sentaksı kullanılırsa artık derleyici 
	sınıfın programcı tarafından yazılmış olan bir yapıcı fonksiyonu olmasa bile sınıfın default yapıcı fonksiyonunu kendisi yazmaz. 

	Tabii default yapıcı fonksiyonun bu biçimde silinmesi fazlaca karşılaşılan bir durum değildir ve böyle bir duruma çok seyerek gereksinim duyulmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = delete;
	//...
};

int main(void)
{
	Sample s;		// geçersiz!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesinin yaşamı sona ererken yani sınıf nesnesi bellekten yok edilirken derleyici tarafından otomatik olarak çağrılan üye fonksiyona
	"yıkıcı fonksiyon (destructor)" denilmektedir. Yıkıcı fonksiyonların isimleri ~sınıf_ismi biçimindedir. (~ ile sınıf ismi bitişik yazılmak zorundadır).
	Yıkcı fonksiyonların da geri dönüş değerleri biçiminde bir kavramları yoktur. Yani bunların da geri dönüş değerleri yerine bir şey yazılmaz. Yıkıcı fonksiyonlar
	overload edilemezler. Yıkıcı fonksiyonlar parametresiz biçimde bulunurlar. 

	Yıkıcı fonksiyonlar yapıcı fonksiyonlar tarafından yapılan birtakım ilk işlemleri geri almak amacıyla kullanılmaktadır. Ancak yıkıcı fonksiyonlara yapıcı 
	fonksiyonlar kadar gereksinim duyulmamaktadır. Çünkü bir sınıf nesnesi için o nesne yok edilirken yapılacak özel bir şeyler	olmayabilir. 
	Eğer programcı sınıfı için yıkıcı fonksiyon yazmamışsa sınıf için yıkıcı fonksiyon derleyici tarafından public bölümde inline olarak
	içi boş bir biçimde yazılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample();
	~Sample();
	//...
};

Sample::Sample()
{
	cout << "default constructor" << endl;
}

Sample::~Sample()
{
	cout << "dstructor" << endl;
}

int main(void)
{
	Sample s;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin yapıcı fonksiyon ieçrisinde new operatörü ile bir bellek tahsisatı yapılmış olabilir, bu tahsisat yıkıcı fonksiyon içerisinde delete operatörüyle
	free hale getirilebilir. 

	Aşağıdaki örnekte String sınıfının str isimli veri elemanı için sınıfın yapıcı fonksiyonunda bir tahsisat yapılmıştır. Bu tahsisat sınıfın yıkıcı fonksiyonunda 
	serbest bırakılmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cstring>

using namespace std;

class String {
public:
	char *str;

	String();
	String(const char *s);
	~String();

	void disp();
};

String::String()
{
	str = new char[1]{ '\0' };
}

String::String(const char *s)
{
	str = new char[strlen(s) + 1];
	strcpy(str, s);
}

String::~String()
{
	delete[] str;
}

void String::disp()
{
	cout << str << endl;
}

int main(void)
{
	String s("ankara");

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta ilerideki konuları da kapsayacak biçimde yapıcı ve yıkıcı fonksiyonların çağrılma sıraları ile ilgili temel bir kural vardır: "C++'ta her zaman yapıcı fonksiyonlarla 
	yıkıcı fonksiyonlar ters sırada çağrılırlar." Örneğin a, b, c nesnelerinin yapıcı fonksiyonlarının bu sırada çalıştırılmış olduğunu varsayalım.,
	Bunların yıkıcı fonksiyonları c, b, a biçiminde çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Yerel sınıf nesneleri için yıkıcı fonksiyonlar programın akışı o yerel nesnenin tanımlandığı bloktan çıkarken çağrılmaktadır. Eğer o blokta birden fazla yerel sınıf nesnesi 
	tanımlanmışsa bunların yıkıcı fonksiyonları ters sıra çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;

	Sample(int x);
	~Sample();
};

Sample::Sample(int x)
{
	a = x;
	cout << "constructor: " << a << endl;
}

Sample::~Sample()
{
	cout << "destructor: " << a << endl;
}

int main(void)
{
	Sample s(10), k(20);

	{
		Sample m(30);
		Sample r(40);

		cout << "nested block ends..." << endl;
	}
	
	cout << "main ends..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Global sınıf nesneleri için yıkıcı fonksiyonlar akış main fonksiyonundan çıktıktan sonra yapıcı fonksiyonlara göre yine ters sırada çağrılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int a;

	Sample(int x);
	~Sample();
};

Sample::Sample(int x)
{
	a = x;
	cout << "constructor: " << a << endl;
}

Sample::~Sample()
{
	cout << "destructor: " << a << endl;
}

Sample x(100);

int main(void)
{
	cout << "main begins..." << endl;

	Sample s(10), k(20);

	{
		Sample m(30);
		Sample r(40);

		cout << "nested block ends..." << endl;
	}
	
	cout << "main ends..." << endl;

	return 0;
}

Sample y(200);

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte sınıfların yıkıcı fonksiyonları da "defaulted" ve "deleted" yapılabilmektedir. Zaten bir sınıf için yıkıcı fonksiyon 
	yazılmamışsa derleyici tarafından onun içi boş olarak yazılacağını belirtmiştik. O halde bir yıkıcı fonksiyonun defaulted yapılmasının anlamı ne olabilir?
	İşte bazı ince konular için bu durum gerekli olabilmektedir. Yine bir yıkıcı fonksiyonun "deleted" yapılması ise çok seyrek bazı durumlarda gerekebilmektedir.
	Yıkıcı fonksiyon deleted yapılırsa artık biz o sınıf türünden nesneyi yok edemeyiz. Çünkü yok ederken yıkıcı fonksiyon çağrılmaktadır. Bu tür durumlarda hata 
	link aşamasında değil derleme aşamasında ortaya çıkmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	//...
	Sample() = default;
	~Sample() = delete;
};

int main(void)
{
	Sample s;		// geçersiz!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın yapıcı fonksiyonları nesneyle normal bir üye fonksiyon gibi çağrılamaz. Ancak yıkıcı fonksiyonları normal bir üye fonksiyon gibi çağrılabilmektedir. Örneğin:

	class Sample {
		//...
	};
	//...

	Sample s;

	s.Sample();		// geçersiz! yapıcı fonksiyonlar açıkça çağrılamazlar
	s.~Sample();	// geçerli, yıkıcı fonksiyonlar diğer üye fonksiyonlar gibi çağrılabilirler. 

	Tabii yıkıcı fonksiyonların açıkça çağrılması dikkat edilmesi gereken özel bir durumdur. Çünkü progracı yıkıcı fonksiyonları açıkça çağırdıktan sonra yine 
	nesne hayatını kaybederken derleyici tarafından çağrılacaktır. Bu durumda bu fonksiyonun iki kez çağrılması sorunlara yol açabilecektir. 
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın veri elemanları tüm üye fonksiyonlar içerisinden doğrudan kullanılabilmektedir. İşte bu durum faaliyet alanı bakımından bu veri elemanı isimlerinin yanlışlıkla
	gizlenmesi sonucunu doğurabilmektedir. Örneğin bir üye fonksiyonun parametre değişkeni sınıfın bir veri elemanının ismiyle aynı olursa biz bu üye fonksiyon içerisinde
	artık sınıfın bu veri elemanına erişemeyiz: Çünkü C ve C++'ta aynı blokta birden fazla aynı isimli değişken faaliyet gösteriyorsa o blokta dar faaliyet alanına
	sahip olan değişkenlere erişilebilmektedir. Yine bir üye fonksiyonu inceleyen kişi oradaki değişkenin bir veri elemanı ya da bir yerel değişken olup olmadığını çabuk anlarsa
	kodu daha iyi anlamlandırır. İşte bu ndenlerden dolayı C++ programcıları sınıfın veri elemanlarını özel öneklerle ya da soneklerle isimlendirmektedir. Örneğin Microsoft 
	sınıfların veri elemanlarını m_xxxx biçiminde m_ öneki ile isimlendirmektedir. Bazı programcılar da d_ önekini tercih ederler. Biz de kursumuzda bundan sonra sınıfın bütün 
	veri elemanlarını m_xxxx biçiminde m_ öneki ile isimlendireceğiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Date {
public:
	int m_day, m_month, m_year;

	Date(int d, int m, int y);
	void disp();
};

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

int main(void)
{
	Date date(10, 12, 1995);

	date.disp();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfların public, protected ve private bölümleri sınıf elemanlarına nereden erişilebileceği üzerinde etkili olmaktadır. Sınıflardaki erişim kuralları şöyledir:

	1) Sınıfın elemanlarına o elemanlar hangi bölümde olursa olsun sınıf bildirimi içerisinde ve sınıfın üye fonksiyonları içerisinde doğrudan erişilebilir. 

    2) Sınıfın public bölümü dışarıdan erişime açık olan bölümüdür. Sınıfın public bölümündeki elemanlara o sınıf türünden nesnelerle ya da referanslarla "." opeatörünü kullanarak, 
	ya da o sınıf türünden göstericilerle "->" operatörünü kullanarak her yerden erişebiliriz. Biz şimdiye kadar sınıfın bütün elemanlarını public bölümde
	aldık.

	3) Sınıfın private bölümündeki elemanlara sınıfın üye fonksiyonu olmayan bir fonksiyon içerisinde o sınıf türünden bir nesne, referans ya da gösterici yoluyla "." ya da 
	"->" operatörünü kullanarak erişemeyiz. Yani private bölümdeki elemanlar sınıfın dışından erişime kapalıdır. 

	4) Sınıfın protected bölümü dışarıdan (yani sınıfın üye fonksiyonu olmayan fonksiyonlardan) erişime kapalı ancak türemiş sınıf erişimine açık bölümüdür. 
	Sınıfın protected bölümündeki elemanlara türemiş sınıfın üye fonksiyonları doğrudan erişebilmektedir. Ancak private bölümdeki elemanlara türemiş sınıfın üye fonksiyonları 
	tarafından da erişilememektedir. 

	Sınıfın en korunaklı bölümü private bölümdür. Bu bölümdeki elemanlara yalnızca sınıfın üye fonksiyonları tarafından yani sınıfın kendisi tarafından erişilebilmektedir. 
	Sınıfın herkese açık bölümü public bölümdür. public bölümdeki elemanlara sınıfın dışından (yani sınıfın üye fonksiyonu olmayana fonksiyonlardan) o sınıf türünden nesne ya da
	gösterici yoluyla erişilebilmektedir. 
	Sınıfın protected bölümü dışarıdan erişilemeyen ancak türemiş sınıflar tarafından erişilebilen bölümüdür. Sınıfın bölümleri korunaklılık durumuna göre public, protected, 
	private biçimindedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	int m_a;
	void foo();
protected:
	void bar();
private:
	int m_b;
	void tar();
};

void Sample::foo()
{
	cout << "Sample::foo" << endl;
}

void Sample::bar()
{
	cout << "Sample:bar" << endl;
}

void Sample::tar()
{
	cout << "Sample::tar" << endl;
}

int main(void)
{
	Sample s;

	s.foo();		// geçerli, foo public bölümde
	s.tar();		// geçersiz! tar private bölümde

	s.m_a = 10;		// geçerli, m_a public bölümde
	s.m_b = 20;		// geçersiz! m_b private bölümde

	s.bar();		// geçersiz! bar protected bölümde

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf türünden nesne yaratırken o sınıfın yapıcı ve yıkıcı fonksiyonlarının o anda erişilebilir olması gerekmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
	Sample();
	//...
};

Sample::Sample()
{
	//...
}

int main()
{
	Sample s;		// error! yapıcı fonksiyon private bölümde, erişilebilir değil!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    NYPT (Nesne Yönelimli Programlama Tekniğinin) birtakım anahtar kavramların birleşimi olarak düşünülebilir. Bu anahtar kavramlar birbirleriyle 
	iç içe geçmiş durumdadır. NYPT'nin anahtar kavramlarından biri "kapsülleme (encapsulation)" denilen kavramdır. Kapsülleme bir olguyu bir sınıfla temsil edip, 
	sınıfın dış dünyayı ilgilendirmeyen, iç işleyişe ilişkin kısımlarının private bölüme yerleştirilerek dış dünyadan gizlenmesi anlamına gelmektedir. Kapsülleme 
	aslında gerçek dünyada da karşılaştığımız bir olgudur. Örneğin arabanın önemli fakat kullanıcıyı ilgilendirmeyen öğeleri kaput içerisine gizlenmiştir. Biz televizyonu
	yalnızca public bölümü temsil eden kumandayla kullanırız. Televizyonun iç devreleri çerçeve içerisinde gizlenmiştir. Bir bankaya gittiğimizde biz yalnızca
	public bölümdeki memurlarla işlerimizi yürütürüz. Bankanın temizliği ile, yönetmi ile, oradaki kişilerin birbirleriyle ilişkileri ile kafamızı yormayız. 
	Bunlar o sınıfın private bölümündeki öğelerdir. 

	Bir sınıf için iki bakış açısı önemlidir: Sınıfı kullananların bakış açısı ve sınıfı yazanların bakış açısı. Sınıfı kullananlar yalnızca public bölüm ile ilgilenirler. 
	Sınıfı yazanlar ise sınıfın her bölümünü bilmek durumundadırlar. Sınıfın kullanıcı için dokümantasyonu yapılırken private bölüm açıklanmaz. Yalnızca public ve protected 
	blümlerin dokümantasyonu yapılır. 

	Örneğin Sample isimli bir sınıf yazacak olalım. Bu sınıfın do_something_important isimli bir üye fonksiyonu olsun. Bu fonksiyon da işlemlerini yapmak için işin bazı
	kısımlarını yapan foo, bar, tar üye fonksiyonlarını çağırıyor olsun. Birisibin bu foo, bar, tar fonksiyonlarını çağırmasının bir anlamı olmadığı gibi bunları
	çağırması sorunlara da yol açabilir. Budurumda bizim foo, bar, tar fonksiyonlarını sınıfın private bölümünde gizlememiz uygun olur.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	void do_something_important();
private:
	void foo();
	void bar();
	void tar();
};

void Sample::do_something_important()
{
	//...
	foo();
	//..
	bar();
	//...
	tar();
	//...
}

int main(void)
{
	Sample s;

	s.do_something_important();
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Programcılar tarafından genel olarak sınıfın veri elemanları iç işleyişe ilişkin oldukları gerekçesiyle sınıfın private bölümünde gizlenmektedir. Bu duruma
	NYPT'de "veri elemanlarının gizlenmesi (data hiding)" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>

using namespace std;

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();
private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

int main(void)
{
	Date d;

	d.disp();

	Date k{10, 12, 2005};

	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın veri elemanlarını private bölüme yerleştirince artık bunlara dışarıdan erişemeyiz. Ancak erişmek istersek ne yapaliriz? İşte private veri elemanlarına
	dışarıdan erişebilmek için sınıfın public bölümüne o elemanların içeriisndeki değerleri alan "getter" üye fonksiyonlar, o elemanların içerisine değer yerleştiren 
	"setter" üye fonksiyonlara gereksinim duyulmaktadır. Bu tür fonksiyonlara "erişimci fonksiyonlar (accessors)" denilmektedir. Erişimci fonksiyonlar genellikle (her zaman değil)
	küçük fonksiyonlar olma eğilimindedir. Bu nedenle bunların inline olarak yazılabilirler. 

	getter fonksiyonların isimleri programcılar tarafından ilgili veri elemanı xxx olmak üzere getxxx, get_xxx, getXxx ya da xxx() biçiminde verilebilmektedir. Deve notasyonu C++'ta
	sıkça kullanılmaktadır. Ancak C++'ın standart kütüphanesinde klasik alt tireli yazım tercih edilmiştir. Benzer biçimde setter fonksiyonların isimleri de 
	setxxx, set_xxx, setXxx viçiminde verilebilmektedir. C++'ta farklı parametrik yapılara ilişkin aynı isimli fonksiyonlar bulunabildiğine göre getter ve setter fonksiyonların
	isimleri de aynı olabilir. Bazı programcılar her iki erişimciye de aynı ismi verebilmektedir. Örneğin sınıfın m_day elemmanına erişmek için erişimciler şöyle de isimlendirilebilmektedir:

	int day();				// getter
	void day(int day);		// setter

	Yukarıdaki Date sınıfı için erişimci fonksiyonları aşağıdaki gibi yazabiliriz. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>

using namespace std;

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();

	int day() 
	{ 
		return m_day; 
	}

	void set_day(int day)
	{
		m_day = day;
	}

	int month()
	{
		return m_month;
	}

	void set_month(int month)
	{
		m_month = month;
	}

	int year()
	{
		return m_year;
	}

	void set_year(int year)
	{
		m_year = year;
	}

private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

int main(void)
{
	Date d;

	d.disp();

	cout << d.day() << '/' << d.month() << '/' << d.year() << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın veri elemanlarını private bölüme yerleştirmenin gerekçelerinden biri şudur: Sınıfın veri elemanları tür ve isim bakımından sıkça değiştirilme potansiyelindedir.
	Eğer onlar sınıfın public bölümüne yerleştirilseler onları programcı doğrudan kullanabileceği için onlarda yapılacak değişiklik onları kullanan kodları geçersiz 
	hale getirecektir. Ancak veri elemanları prvate bölüme yerleştirildiğinde ve onlara public getter/setter fonksiyonlarla erişildiğinde onlarda değişikler yapıldığında bu 
	getter/setter fonksiyonların içi yeniden düzenlenerek onları kullanmış olan kodların bu değişiklikten etkilenmemesi sağlanabilmektedir. 

	Yukarıdaki Date sınıfında biz tarih bilgisini üç int nesne yerine 11 elemanlı bir char dizide "mm/dd/yyy" biçiminde bir yazı olarak tutmak isteyelim. Bu durumda
	bizim amacımız daha önce yazılmış olan kodların bu değişiklikten etkilenmemesini sağlamak olmalıdır. İşte biz de bunun için sınıfın üye fonksiyonlarının içini değiştirirz. 
	Bu değişikliği sınıfı kullanan kişiler fark etmezler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>
#include <cstdlib>

using namespace std;

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();

	int day() 
	{ 
		return atoi(m_date);
	}

	void set_day(int day)
	{
		sprintf(m_date, "%02d", day);
		m_date[2] = '/';
	}

	int month()
	{
		return atoi(m_date + 3);
	}

	void set_month(int month)
	{
		sprintf(m_date + 3, "%02d", month);
		m_date[5] = '/';
	}

	int year()
	{
		return atoi(m_date + 6);
	}

	void set_year(int year)
	{
		sprintf(m_date + 6, "%04d", year);
	}

private:
	char m_date[11];		// "dd/mm/yyyy"
};

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	sprintf(m_date, "%02d/%02d/%04d", pt->tm_mday, pt->tm_mon + 1, pt->tm_year + 1900);
}

void Date::disp()
{
	cout << m_date << endl;
}

Date::Date(int day, int month, int year)
{
	sprintf(m_date, "%02d/%02d/%04d", day, month, year);
}

int main(void)
{
	Date d;

	d.disp();

	cout << d.day() << '/' << d.month() << '/' << d.year() << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Eğer biz veri elemanlarını sınıfın private bölümüne yerleştirip onlara değer atamayı setter fonksiyonlarına yaptırırsak bu durumda onlara atanacak değerin
	sınamasını bu setter fonksiyonları içerisinde yapabiliriz. Sınamanın başarısz olduğu durumda bir exception fırlatılabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>
#include <stdexcept>

using namespace std;

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();

	int day()
	{
		return m_day;
	}

	void set_day(int day)
	{
		if (day < 1 || day > 31)
			throw invalid_argument("invalid day");

		m_day = day;
	}

	int month()
	{
		return m_month;
	}

	void set_month(int month)
	{
		if (month < 1 || month > 12)
			throw invalid_argument("invalid month");

		m_month = month;
	}

	int year()
	{
		return m_year;
	}

	void set_year(int year)
	{
		m_year = year;
	}

private:
	int m_day;
	int m_month;
	int m_year;
};

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

int main(void)
{
	Date d;

	d.set_day(40);		// eception oluşacak!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen sınıfın veri elemanları arasında birtakım ilişkiler söz konusu olabilir. Yani bir veri elemanının değerini değiştirdiğimizde başka veri elemanlarının değerlerini 
	ona göre değiştirmek durumunda kalabiliriz. İşte bu tür durumlarda sınıfın veri elemanlarını public bölüme yerleştirirsek bu durumda tüm ilişkiyi programcının bilmesi 
	ve uygulaması gerekir. Halbuki bu veri elemanlarını private bölüme yerleştirirsek bu ilişki setter fonksiyonlarında arka planda oluşturulabilir. 

	Aşağıdaki örnekte Circle sınıfının m_radius elemanı m_area elemanı ile ilişkilidir. set_radius işleminde m_area elemanı da değiştirilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Circle {
public:
	Circle(double x, double y, double radius)
	{
		m_x = x;
		m_y = y;
		m_radius = radius;
		m_area = 3.14159 * radius * radius;
	}

	void set_radius(double radius)
	{
		m_radius = radius;
		m_area = 3.14159 * radius * radius;
	}

	void foo();		// m_area'yı kullanıyor
	void bar();		// m_area'yı kullanıyor
	void tar();		// m_area'yı kullanıyor

private:
	double m_x;
	double m_y;
	double m_radius;
	double m_area;
};

int main(void)
{
	Circle c(1, 2, 3);

	c.set_radius(4);
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen sınıfın bir veri elemanı üzerinde işlem yaparken arka planda başka birtakım işlemlerin de yapılması gerekebilir. Örneğin SerialPort isimli bir sınıfta
	seri porun hızı sınıfın public bir m_baudrate elemanında tutuluyor olsun. Biz şimdi bu elemana değer yerleşirdiğimizde seri portu hızı değişmeyecektir. 
	Seri portun hıznını değiştirmek için UART işlemcisiin programlanması gerekir. Ancak biz m_baudrate elemanını private bölümde tutup onu set_baudrate fonksyonu ile
	set etmeye kullanıcıyı zorlarsak set_baudrate fonksiyonu içerisinde biz UART işlemcisini de programlayabiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıda açıkladığımız dört gerekçenin hiçbiri bizim geçerli olmayabilir. Yani biz sınıfın veri elemanlarını değiştirmeyeceğmizden eminsek, o veri elemanları 
	üzerinde sınır kontrolü gerekmiyorsa ya da bunun programcı tarafından yapılmasını istiyorsak, o veri elemanı başka bir veri elemanı ile ilişkili değilse, 
	o veri elemanını kullanırken başka işlemler yapmamız gerekmiyorsa o zaman pekala biz veri elemanlarımızı public bölüme yerleştirebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf tipik olarak iki kaynak dosya biçiminde yazılmaktadır. Sınıfın ismi X olmak üzere "x.hpp" ve "x.cpp". Sınıfın bildirimleri "x.hpp" dosyası içerisine yerleştirilir. 
	Sınıfın üye fonksiyonları ise "x.cpp" dosyasına yerleştirilir. Böylece sınıfın kullanılacağı her yerde "x.hpp" dosyası include edilir. "x.cpp" dosyası derlenerek 
	kütüphanelere yerleştirilebilir. Ya da object modül biçiminde link aşamasında yeniden derlenmeden kullanılabilir. X sınıfı Y sınıfını kullanıyorsa bu durumda
	"y.hpp" dosyası tipik olarak "x.hpp" dosyası içerisinde include edilir. 

	Ancak programcılar birkaç sınıf için ortak bir başlık dosyası ve cpp dosyası da oluşturabilmektedir. Örneğin X, Y, Z sınıflarınının bildirimleri "xyz.hpp"
	dosyası içerisine, bunların üye fonksiyon tanımlamaları da "xyz.cpp" içerisine yerleştirilebilmektedir.

	using nanespace direktiflerinin başlık dosyalarının içerisine yerleştirilmesi kötü bir tekniktir. 

	Örneğin Dare sınıfını aşağıdaki gibi iki dosya olarak organize edebiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp();

	int day() { return m_day; }
	void set_day(int day) {	m_day = day; }

	int month() { return m_month; }
	void set_month(int month) {	m_month = month; }
	int year() { return m_year;	}
	void set_year(int year)	{ m_year = year; }
private:
	int m_day;
	int m_month;
	int m_year;
};

#endif

// date.cpp

#include <iostream>
#include <ctime>
#include "date.hpp"

using namespace std;

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp()
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

// app.cpp

#include <iostream>
#include "date.hpp"

using namespace std;

int main(void)
{
	Date d;

	d.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Basit bir String sınıfını iki dosya biçiminde aşağıdaki gibi organize edebiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	void disp();

	~String();

private:
	char *m_str;
	std::size_t m_len;
};

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = new char[1]{'\0'};
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

void String::disp()
{
	cout << m_str << endl;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main(void)
{
	String s("ankara");

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ın standart kütüphanesinde zaten hazır bir biçimde bulunan yazısal işlemleri yapmak için yazılmış olan bir string sınıfı vardır. Standart string sınıfı
	aslında basic_string isimli bir şablon sınıfın char türünden açılımı biçiminde typedef edilmiştir. string sınıfı <string> başlık dosyası içerisinde bildirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının const char * parametreli yapıcı fonksiyonu bizden bir yazı alıp onu dinamik bir biçimde tahsis etmiş olduğu char türden dizi içerisinde tutar. 
	cout nesnesi zaten standart string nesnelerini de yazdırabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");

	cout << s << endl;		// ankara

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının diğer çok kullanılan yapıcı fonksiyonu bizden bir sayı ve bir karakter alır. Nesneyi o karakterden o sayıda lacak biçimde oluşturur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s(10, 'a');		// aaaaaaaaaa

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının + operatör fonksiyonu iki yazıyı birleştirip yeni bir string nesnesi vermektedir. Operatör fonksiyonları ileride ele alınacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara"), k("izmir"), result;

	result = s + k;
	
	cout << result << endl;			// ankaraizmir

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının + operatör fonksiyonu char türden bir gösterici ile toplama işlemi de yapabilmektedir. Bu durumda operatör fonksiyonu C tarzı ile bir yazı ile
	string nesnesinin toplanmasına olanak sağlar. u da yine yazıların birleştirilmesi anlamına gelir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara"), result;

	result = s + "izmir";
	
	cout << result << endl;			// ankaraizmir

	result = "izmir" + s;

	cout << result << endl;			// izmirankara

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının karşılaştırma operatör fonksiyonları da bulunmaktadır. (Ancak C++20 ile birlikte == operatör fonksiyonu dışındakiler kaldırılmış, yer,ine <=> 
	operatör fonksiyonu eklenmiştir.) Bu operatör fonksiyonları hem iki string nesnesi üzerinde işlem yapabilmekte hem de bir string nesnesi ile C tarxı bir string üzerinde de
	işlem yapabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s;

	cout << "Enter password:";

	cin >> s;

	if (s == "maviay")
		cout << "ok" << endl;
	else
		cout << "incorrect password!" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'taki string sınıfı Java, C#, Python gibi dillerdeki string sınıfları gibi "değiştirilemez (immutable)" değildir. Biz C++'ta bir string nesnesiin karakterlerini
	değiştirebiliriz. Ona yeni karakterler ekleyebiliriz. Onun bazı karakterlerini silebiliriz. Örneğin append isimli overload edilmiş metotlar string'in sonuna yazı ve karakter
	eklemek için kullanılabilmektedir. Yani append metotları ile şu eklemeleri yapabiliriz:

	1) string'e C tarzı string ekleyebiliriz. Bunun için sınıfın cons har * parametreli append fonksiyonu vardır. 
	2) string'e başka bir string nesnesini ekleyebiliriz. 
	3) string'e belli bir sayıda bir karakterden ekleyebiliriz. 
	4) string'e C tarzı C string'in ilk n karakterini ekleyebiliriz. 
	5) string'e başka bir string'in belli bir indeksinden itibaren n tane karakterini ekleyebiliriz. 

	Ayrıca iteratör yoluyla ekleme yapan append üye fonksiyonları da vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara"), k("eskisehir");

	s.append("izmir");			// 1
	s.append(k);				// 2
	s.append("erzurum", 3);		// 3
	s.append(10, 'x');			// 4
	s.append(k, 3, 2);			// 5

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının erase isimli üye fonksiyonları string'ten karakter silmek için kullanılarlar. iki parametreli erase fonksiyonu belli bir indeksten itibaren 
	n tane karakteri silmektedir. Bu iki parametre de girilmezse yazının tamam silinmektedir. Birinci parametre girilip ikinci parametre girilmezse o indeksten itibaren 
	yazının geri kalanı silinmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	
	s.erase(2, 3);

	cout << s << endl;			// ana

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    [] operatörü ile string nesnesinin belli bir karakterine erişilebilir. O karakter değiştirilebilir. Bu işlem sınıfın [] operatör fonksiyonu ile yapılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	
	cout << s[2] << endl;
	s[2] = 'x';

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aralık tabanlı for döngüleri ile string'i dolaşabiliriz. Bu durumda string'in karakterlerini elde ederiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	
	for (char ch : s)
		cout << ch;
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii aralık tabanlı for döngüsünde referans da kullanabiliriz. Bu durumda bu referans string içerisindeki karakterleri gösterir. Yani onun güncellenmesi 
	string'in karakterlerinin güncellenmesi anlamına gelecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <cctype>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	
	for (auto &ch : s)
		ch = toupper(ch);

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın += operatör fonksiyonları bir string'e başka bir string'i ya da yazıyı eklemek için kullanılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	
	s += "izmir";		// s = s + "izmir;
	s += "bursa";		// s = s + "izmir;

	cout << s << endl;

	string k("van");

	s += k;

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	string sınıfının substr üye fonksiyonu belli bir indeksten itibaren string'in n tane karakterini bir string olarak elde etmek için kullanılmaktadır. İkinci parametre girilmezse
	string'in sonuna kadarki tüm karakterler elde edilir. İki parametre de girilmezse yazının aynısı elde edilmektedir. Bu da kopyalama anlamına gelir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	string result;

	result = s.substr(2, 2);
	cout << result << endl;			// ka
	
	result = s.substr(2);			
	cout << result << endl;			// kara
	
	result = s.substr();			
	cout << result << endl;			// ankara
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınfın replace isimli üye fonksiyonları string içeriisndeki yazının belli bir kısmını başka bir yazıyla yer değiştirmektedir. Yani bu belli kısım önce silinip
	sonra o yere insert işlemi yapılıyor gibi bir etki oluşturmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	string k("izmir");

	s.replace(2, 2, k);	

	cout << s << endl;	// anizmirra
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bu işlemi C tarzı string'lerle de yapabiliriz.  Overload edilmiş olan diğer replace üye fonksiyonları için dokümantasyona başvurabilirisiniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	char k[] = "izmir";

	s.replace(2, 2, k);

	cout << s << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının pek çpk overload edilmiş insert fonksiyonları vardır. Bu insert fonksiyonlarının bazıları şunlardır:

	1) string'in belli bir indeksine belli bir karakterden n tane insert eden fonksiyon
	2) string'in belli bir indeksine C tarzı bir string'i insert eden fonksiyon
	3) string'in belli bir indeksine başka bir string'i insert eden fonksiyon.

	Diğer overload edilmiş string fonksiyonları için dokümantasyonlara başvurunuz.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");

	s.insert(3, 2, 'x');			// 1
	cout << s << endl;				// ankxxara

	s = "ankara";

	s.insert(2, "izmir");			// 2
	cout << s << endl;				// anizmirkara

	s = "ankara";
	string k("izmir");

	s.insert(2, k);					// 3
	cout << s << endl;				// anizmirkara

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının find isimli üye fonksiyonları yazı içerisinde bir karakteri ya da başka bir yazıyı bulmak iin kullanılmaktadır. Eğer söz konusu karakter ya da yazı
	yazı içerisinde bulunursa bulunduğu yerin indeks numarasıyla geri döner bulunamazsa string::npos değeriyle geri döner. find fonksiyonlarının geri dönüş değerleri 
	string sınıfı içerisinde typedef edilmiş olan size_type türündendir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	string::size_type pos;

	pos = s.find('k');
	if (pos == string::npos)
		cout << "cannot find..." << endl;
	cout << pos;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	find işleminde arama belli bir indeksten itibaren de başlatılabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	string::size_type pos;

	pos = s.find('a', 2);
	if (pos == string::npos)
		cout << "cannot find..." << endl;
	cout << pos;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yazının belli bir indeksinden başlanarak belli bir yazı da aranabilir. Bu yazı C tarzı bir string olabileceği gibi başka bir string nesnesi de olabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("bugun hava cok guzel");
	string::size_type pos;

	pos = s.find("hava");
	if (pos == string::npos)
		cout << "cannot find..." << endl;
	cout << pos;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++ ile birlikte string kütüphanesine stoxxx biçiminde global fonksiyonlar da eklenmiştir. Bu fonksiyonların listesi şöyledir:
	
	stoi
	stol
	stoll
	stoul
	stoull
	stof
	stod
	stold

	Bu fonksiyonlar string nesnesi içeisindeki sayısal yazıyı ilgili C türünde dönüştürürler. (Yani bunlar atoi, atol, atof gibi standart C fonksiyonlarının yaptığı 
	işleri yapmaktadır.)

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("1234");
	string k("123.45");

	auto result = stoi(s);

	cout << result << endl;

	auto result2 = stod(k);
	cout << result2 << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yine C++11 ile birlikte string kütüphanesine dile bir grup overload edilmiş global to_string fonksiyonları eklenmiştir. Bu fonksiyonlar stoxxx fonksiyonlarının tersini yapmaktadır. 
	Yani parametreleriyle int, lng, double gibi değerleri alıp o sayıları string nesnesi biçiminde bize verirler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	int val = 1234;
	string s;

	s = to_string(val);
	cout << s << endl;

	s = to_string(12.34);
	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string sınıfının atama operatör fonksiyonları da vardır. Böylece biz bir string nesnesine "=" operatörü ile C tarzı bir string'i ya da başka bir string nesnesini atayabiliriz. 
	Bu durumda o string nesnesi artık atadığımız yazıyı tutuyor hale gelir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");

	cout << s << endl;		// ankara

	s = "izmir";

	cout << s << endl;		// izmir

	string k("hatay");

	s = k;

	cout << s << endl;		// hatay

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    string nesnesi içerisindeki yazının karakter uzunluğunu size ya da length üye fonksiyonu ile elde edebiliriz. Bu üye fonksiyonlar bize yazının uzunluğunu string::size_type
	türünden vermektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

int main(void)
{
	string s("ankara");
	string::size_type n;

	n = s.size();
	cout << n << endl;

	n = s.length();
	cout << n << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesinin adresi alınabilir. Bu adres aynı türden bir sınıf göstericisine atanabilir. Biz de bir sınıf göstericisi yoluyla sınıfın elemanlarına 
	gösterici ps olmak üzere (*ps).a gibi bir ifadeyle ya da ps->a ifadesiyle erişebiliriz. ps bir sınıf türündne gösterici foo da bu sınıfın bir üye fonksiyonu olsun. 
	Bu gösterici yoluyla foo fonksiyonu (*ps).foo() biçiminde ya da ps->foo() biçiminde çağrılabilir. Burada foo fonksiyonu ps göstericisinin gösterdiği yerdeki nesnenin 
	veri elemanlarını kullanıyor durumda olacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a)
	{
		m_a = a;
	}
	void disp()
	{
		cout << m_a << endl;
	}
	int a()
	{
		return m_a;
	}
	void set_a(int a)
	{
		m_a = a;
	}
private:
	int m_a;
};

int main(void)
{
	Sample s(10);
	Sample *ps;

	ps = &s;

	(*ps).disp();		
	ps->disp();

	ps->set_a(20);
	cout << ps->a() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    new operatör ile sınıflar türünden heap'te dinamik tahsisatlar yapılabilir. Bu durumda new operatörü önce o sınıfın elemanlarını içerecek uzunlukta dinamik 
	tahsisatı yapar. Sonra sınıfın uygun yapıcı fonksiyonunu çağırır. Dinamik tahsis edilmiş sınıf nesneleri delete operatöryle serbest bırakılmalıdır. delete operatörü de
	nesneyi heap'ten boşaltmadan önce sınıfın yıkıcı fonksiyonunu çağırır. new ile tahsisat aşağıdaki sentaktik biçimlerle yapılmaktadır:

	new Sample			// default yapıcı fonksiyon çağrılır
	new Sample()		// default yapıcı fonksiyon çağrılır
	new Sample(...)		// overload resolution işlemiyle seçilen fonksiyon çağrılır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a)
	{
		m_a = a;
	}
	void disp()
	{
		cout << m_a << endl;
	}
	int a()
	{
		return m_a;
	}
	void set_a(int a)
	{
		m_a = a;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}
private:
	int m_a;
};

int main(void)
{
	Sample *ps;

	ps = new Sample(10);
	ps->disp();

	delete ps;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi bir sınıf nesnesinin dinamik bir biçimde tahsis edilmesine neden gereksinim duyulmaktadır? İşte biz bir sınıf nesnesini programın belli bir notasında yaratıp
	belli bir noktasında yok etmek isteyebiliriz. Yerel sınıf nesneleriyle ve global sınıf nesneleriyle bunun yapılması mümkün değildir. 

	Aşağıdaki örnekte bu tema gösterilmiştir:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a)
	{
		m_a = a;
	}
	void disp()
	{
		cout << m_a << endl;
	}
	int a()
	{
		return m_a;
	}
	void set_a(int a)
	{
		m_a = a;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}
private:
	int m_a;
};

Sample *foo()
{
	cout << "foo" << endl;

	auto ps = new Sample(10);

	return ps;
}

int main(void)
{
	Sample *ps;

	ps = foo();
	ps->disp();

	delete ps;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıflar türünden referanslar oluşturulabilir. Bir sınıf türünden bir sol taraf değeri referansı aynı sınıf türünden bir nesne ile ilkdeğer verilerek tanımlanmalıdır. 
	Sınıf referanslarıyla sınıfın üye fonksiyonları "." operatörüyle çağrılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a)
	{
		m_a = a;
	}
	void disp()
	{
		cout << m_a << endl;
	}
	int a()
	{
		return m_a;
	}
	void set_a(int a)
	{
		m_a = a;
	}

private:
	int m_a;
};

int main(void)
{
	Sample s(10);
	Sample &r = s;

	r.disp();			// 10
	r.set_a(20);
	s.disp();			// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın üye fonksiyonları "const üye fonksiyonlar" yapılabilir. Bunun için fonksiyonun parametre parantezinden sonra "const" anahtar sözcüğü kullanılmaktadır. 
	Buradaki const anahtar sözcüğü hem prototipte hem de tanımlama sırasında bulundurulmak zorundadır. 

	Sınıfın const ye fonksiyonları sınıfın veri elemanlarını  kullanabilirler ancak değiştiremezler. Yani bir üye fonksiyonu const yapan programcı derleyiciye
	"o üye fonksiyon içerisinde sınıfın (static olmayan) bir veri elemanını değiştirmeyeceği sözünü"" vermektedir. 

	const bir üye fonksiyon içerisinde biz sınıfın yalnızca const üye fonksiyonlarını çağırabiliriz. Sınfın yapıcı ve yıkıcı fonksiyonları const yapılamazlar.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Number {
public:
	Number(int val = 0);
	void disp() const;
private:
	int m_val;
};

Number::Number(int val)
{
	m_val = val;
}

void Number::disp() const
{
	cout << m_val << endl;
}

int main(void)
{
	Number n;

	n.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf nesnesi const yapılabilir. const sınıf nesneleri için çağrılan yapıcı ve yıkıcı fonksiyonlar o nesnenin veri elemanlarında değişiklik yapabilirler. 
	Ancak bu istisna durum dışında const nesnenin veri elemanları herhangi bir biçimde değiştirilemezler. 

	cont bir sınıf nesnesi ile sınıfın yalnızca const üye fonksiyonları çağrılabilir. Çünkü const üye fonksiyonların sınıfın veri elemanlarını 
	değiştirmeyeceği derleyici tarafından zaten denetlenmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// number.hpp

#ifndef NUMBER_HPP_
#define NUMBER_HPP_

class Number {
public:
	Number(int val = 0);
	void disp() const;
	void set_val(int val);
private:
	int m_val;
};

#endif

// number.cpp

#include <iostream>
#include "number.hpp"

using namespace std;

Number::Number(int val)
{
	m_val = val;
}

void Number::disp() const
{
	cout << m_val << endl;
}

void Number::set_val(int val)
{
	m_val = val;
}

// app.cpp

#include <iostream>
#include "number.hpp"

using namespace std;

int main(void)
{
	const Number n(10);

	n.disp();			// geçerli
	n.set_val(20);		// error! const bir sınıf nesnesi ile sınıfın const olmayan üye fonksiyonları çağrılamaz.
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Programcı bir sınıf için üye fonksiyon yazarken üye fonksiyon eğer sınıfın veri elemanlarını değiştirmiyorsa onu const yapmalıdır. Aksi takdirde üye fonksiyon
	aslında const nesnelere çağrılabileceği halde çağrılamaz duruma gelir. Aynı durum const referanslar için, const göstericiler için de geçerlidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

void foo(const Number *pn)
{
	pn->disp();		// geçerli disp const
}

int main(void)
{
	Number  s(10);
	const Number &r = s;

	r.disp();		// geçerli, disp const

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	 Biz bir sınıf türünden nesneyi kendi sınıfı türünden bir nesneyle ilkdeğer vererek tanımlayabiliriz. Bu durumda yeni yarattığımız nesnenin veri elemanlarının 
	 ona ilkdeğer olarak verdiğimiz nesnenin veri elemanlarıyla aynı olmasını bekleriz. Örneğin:

	 Sample s;
	 Sample k = s;		

	 Burada k nesnesinin içeriğinin s nesnesinin içeriği ile aynı olmasını istiyoruz. Bu ilkdeğer verme işlemi şöyle de yapılabilirdi:

	 Sample s;
	 Sample k(s);

	 C++11'den sonra aşağıdaki gibi de yapılabilmektedir:

	 Sample s;
	 Sample k{s};

	 İşte bir sınıf nesnesinin kendisi ile aynı türden bir sınıf nesnesi ile ilkdeğer verilerek yaratıldığı durumlarda yaratılacak nesne için çağrılan sınıfların yapıcı 
	 fonksiyonlarına "kopya yapıcı fonksiyonları (copy constructors)" denilmektedir. 

	 Fonksiyon çağrılırken argümanlardan parametre değişkenlerine yapılan aktarımın parametre değişkenine ilkdeğer verme anlamına geldiğini anımsayınız. Benzer biçimde
	 fonksiyonların geri dönüş değerleri oluşturulurken return işleminin geri dönüş değeri için yaratılacak geçici nesneye ilkdeğer verme anlamına geldiğini de anımsayınız. 

	 C++'ta kopya yapıcı fonksiyonları şu durumlarda çağrılmaktadır:

	 1) Bir sınıf nesnesinin aynı sınıf türünden bir nesneyle ilkdeğer verilerek tanımlandığı durumlarda yeni tanımlanan nesne için kopya yapıcı fonksiyonu çağrılır.
	 2) Fonksiyonun parametre değişkeni bir sınıf türünden ise bu fonksiyon aynı sınıf türünden bir sınıf nesnesiyle çağrıldığında parametre değişkeni için de 
	 kopya yapıcı fonksiyonu çağrılır.
	 3) Fonksiyonun geri dönüş değeri bir sınıf türünden olabilir. Bu durumda return işleminde return anahtar sözcüğünün yanında aynı sınıf türünden bir nesne olmalıdır. 
	 İşte geri dönüş değeri için yaratılacak olan geçici nesne için sınıfın kopya yapıcı fonksiyonu çağrılır.

	 Sınıfın kopya yapıcı fonksiyonu sınıfın kendi türünden referans parametreli yapıcı fonksiyonudur. Sınıfın ismi T olmak üzere aşağıdaki parametrelere sahip yapıcı foksiyonların 
	 hepsi kopya yapıcı fonksiyon (copy contructor) olarak kullanılabilir:

	 - const T &
	 - T &
	 - volatile T &
	 - const volatile T &

	 Sınıfın en çok kullanılan kopya yapıcı fonksiyonu "const T &" parametreli yapıcı fonksiyonudur. 

	 Sınıfın kopya yapıcı fonksiyonu ne yapmalıdır? Madem ki kopya yapıcı fonksiyonu bir sınıf nesnesi aynı türden bir sınıf nesnesi ile ilkdeğer verilerek tanımlanırken
	 çağrılıyor o zaman kopya yapıcı fonksiyonunun ilkdeğer olarak verilen nesnenin içeisindeki değerlerin aynısını yaratılmakta olan nesnede oluşturması beklenir. 
	 
	 Kopya yapıcı fonksiyonu derleyici tarafından çağrıldığında ilkdeğer olarak verilen nesnenin adresi kopya yapıcı fonksiyonunun referans parametresine aktarılır. 
	 Kopya yapıcı fonksiyonunu yazan programcı da o nesnenin içeriğini yeni yaratılan nesnede oluşturmaya çalışır. 

	 Sınıfın başka sınıf türünden veri elemanlarının bulunduğu durumda sınıfın kopya yapıcı fonksyonu bu veri elemanları için kendi sınıflarının kopya yapıcı fonksiyonlarının
	 çağrılmasını sağlamalıdır. Bu işlemin nasıl yapılacağı ileri MIL sentaksı açıklanırken ele alınacaktır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

include <iostream>
#include <string>

using namespace std;

class Sample {
public:
	Sample(int a, int m);
	Sample(const Sample &r);

	void disp() const;
	int a() const {	return m_a;}
	int b() const { return m_b; }
private:
	int m_a;
	int m_b;
	string m_s;
};

Sample::Sample(int a, int b)
{
	m_a = a;
	m_b = b;
}

Sample::Sample(const Sample &r) 
{
	m_a = r.m_a;
	m_b = r.m_b;
}

void Sample::disp() const
{
	cout << "m_a = " << m_a << ", m_b = " << m_b << endl;
}

void foo(Sample k)		// k için kopya yapıcı fonksiyon çağrılır
{
	k.disp();
}

Sample bar()
{
	Sample s(30, 40);			


	return s;			// copy constructor çağrılır
}

int main(void)
{
	Sample s(10, 20);

	Sample k = s;		// copy constructor çağrılır

	s.disp();
	k.disp();

	foo(s);			// copy constructor çağrılır

	bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Programcı sınıfı için kopya yapıcı fonksiyonunu hiç yazmayabilir. Bu durumda derleyici sınıf için kopya yapıcı fonksiyonunu kendisi yazar. Derleyicinin
	kendisinin yazdığı kopya yapıcı fonksiyonu kaynak nesnenin veri elemanlarını hedef nesneye bire bir kopyalamaktadır. Bu işleme "memberwise copy" denilmektedir. 
	Yani yukarıdaki örnekte biz sınıf için kopya yapıcı fonksiyonunu hiç yazmasaydık da zaten derleyici bunu bizim yazdığımız gibi karşılıklı elemanları kopyalayacak
	biçimde yazacaktı. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int m);

	void disp() const;
	int a() const {	return m_a;}
	int b() const { return m_b; }
private:
	int m_a;
	int m_b;
	string m_s;
};

Sample::Sample(int a, int b)
{
	m_a = a;
	m_b = b;
}

void Sample::disp() const
{
	cout << "m_a = " << m_a << ", m_b = " << m_b << endl;
}

void foo(Sample k)		// k için kopya yapıcı fonksiyon çağrılır
{
	k.disp();
}

Sample bar()
{
	Sample s(30, 40);			


	return s;			// copy constructor çağrılır
}

int main(void)
{
	Sample s(10, 20);

	Sample k = s;		// copy constructor çağrılır

	s.disp();
	k.disp();

	foo(s);			// copy constructor çağrılır

	bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi madem derleyici biz yazmazsak da bizim için kopya yapıcı fonksiyonunu kendisi yazmaktadır. O halde bunu bizim yazmamızı gerektirecek bir durum var mıdır?
	İşte bazen derleyicinin kendisinin yazdığı kopya yapıcı fonksiyonu sınıfın karşıklı veri elemanlarını kopyaladığı için sorunlara yol açabilir. Örneğin sınıfın 
	bir gösterici veri elemanı varsa "memberwise copy" işlemi sırasında bu göstericinin içerisindeki adres hedefe kopyalanır. Böylece iki sınıf nesnesinin gösterici veri 
	elemanları aynı yeri gösterir durumda olurlar. Sonra bu nesneler için yıkıcı fonksiyonlar çağrıldığında bu yıkıcı fonksiyonlar aslında iki nesnenin ortak kullandığı alanı
	serbest bırakabilir. Bu da sorunlara yol açar. İşte bu tür durumlarda programcının sınıf için kopya yapıcı fonksiyonunu kendisinin "içerik kopyalaması" yapacak 
	biçimde yazması gerekir. İçerik kopyalaması göstericilerin içerisindeki adreslerin değil onların gösterdikleri yerdeki bilgilerin kopayalnmasıdır. 
	İçerik kopyalamasına Java ve C# gibi dillerde "derin kopyalama (deep copy)" da denilmektedir. 

	Örneğin biz daha önce basit bir String sınıfını aşağıdaki gibi oluşturmuştuk:


	class String {
	public:
		String();
		String(const char *str);
		void disp();

		~String();

	private:
		char *m_str;
		std::size_t m_len;
	};

	Burada m_str veri elemanı dinamik tahsis edilen alandaki yazıyı göstermektedir. İşte eğer biz bu sınıf için içerik kopyalaması yapmazsak derleyicinin yazdığı 
	kopya yapıcı fonksiyon "memberwise copy" yapacak ve bu da aşağıdaki gibi kodlarda hemen soruna yol açacaktır:

	void foo(String k)
	{
		//...
	}
	//...
	String s("ankara");

	foo(s);


	Aşağıdaki örnekte böyle bir String sınıfı için kopya yapıcı fonksiyonun nasıl yazılması gerektiği gösterilmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	void disp();

	~String();

private:
	char *m_str;
	std::size_t m_len;
};

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = new char[1]{'\0'};
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)			// copy constructor içerikl kopyalaması yapıyor
{
	m_str = new char[r.m_len + 1];
	strcpy(m_str, r.m_str);
	m_len = r.m_len;
}

void String::disp()
{
	cout << m_str << endl;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "String.hpp"

using namespace std;

void foo(String k)
{
	k.disp();
}

int main(void)
{
	String s("ankara");

	foo(s);

	s.disp();			// undefined behavior!

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi hangi durumlarda derleyicinin yazdığı kopya yapıcı fonksiyonu bir soruna yol açmaz? Eğer sınıfın bir gösterici veri elemanı yoksa muhtemelen derleyicinin 
	yazmış olduğu "memberwise copy" yapan kopya yapıcı fonksiyon bizim işimizi görecektir. Ancak yine de bazen gösterici olmayan veri elemanları da ortak alanları temsil 
	ediyor olabilir. Bu özel durumlara da dikkat etmek gerekir. 

	Örneğin aşağıdaki gibi bir Complex sayı sınıfı için programcının kopya yapıcı fonksiyonnuu kendisinin yazmasına hiç gerek yoktur. Zaten derleyicinin "memberwise copy"
	yapan kopya yapıcı fonksiyonu istenileni yapacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP
#define COMPLEX_HPP

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0)
	{
		m_real = real;
		m_imag = imag;
	}
	void disp() const;
private:
	double m_real;
	double m_imag;
};

#endif

// complex.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

void Complex::disp() const
{
	cout << m_real;

	if (m_imag)
		cout << '+' << m_imag << 'i';

	cout << endl;
}

// app.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

int main(void)
{
	Complex z(3, 2);
	Complex k = z;

	z.disp();
	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta T bir tür ismi (genellikle sınıf) olmak üzere T([argüman listesi]) biçminde bir ifade ""T türünden geçici nesne yarat" anlamına gelmektedir. Bu biçimde geçici nesne 
	yaratıldığında derleyici eğer yaratılan bir sınıf nesnesi ise bu nesne için uygun yapıcı fonksiyonunu çağırır. Sonra bu geçici nesne bu geçici nesnenin yaratıldığı ifade 
	bittiğinde yıkıcı fonksiyon çağrılarak yok edilir. Eğer bir ifadede birden fazla geçici sınıf nesnesi yaratılmışsa onların yıkıcı fonksiyonları yapıcı fonksiyonlarına göre ters
	sırada çağrılacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int val)
	{
		cout << "constructor: " << val << endl;
		m_val = val;
	}

	void disp() const
	{
		cout << m_val << endl;
	}
	~Sample()
	{
		cout << "destructor: " << m_val << endl;
	}

private:
	int m_val;
};

void foo(Sample s)
{
	s.disp();
}

int main(void)
{
	foo(Sample(10));		// Burada geçici nene yaratılır, bu geçici nesne fonksiyona aktarılır.

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	T bir sınıf belirtmek üzere T(...) biçiminde yaratılan geçici nesneler sağ taraf değeri (prvalue) belirtir. Dolayısıyla biz onu ancak const bir sol taraf değeri referansına 
	bind edebiliriz. Ya da bir sağ taraf değeri referansına bind edebiliriz. Örneğin:
		
	Sample &r = Sample(10);				// error! geçici nesne prvalue fakat referans const değil!
	const Sample &k = Sample(10);		// geçerli, geçici nesne prvalue ve referans const
	Sample &&m = Sample(10);			// geçerli, geçici nesne prvalue ancak referns rvalue referans

	BU tür durumlarda geçici nesne referansın ömrü kadar yaşamaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int val)
	{
		cout << "constructor: " << val << endl;
		m_val = val;
	}

	void disp() const
	{
		cout << m_val << endl;
	}
	~Sample()
	{
		cout << "destructor: " << m_val << endl;
	}

private:
	int m_val;
};

int main(void)
{
	const Sample &r = Sample(10);				
	
	cout << "continues..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta C++17'ye kadar bazı durumlarda derleyicinin kopya yapıcı fonksiyonunu çağırmayabileceği, nesneyi doğrudan hedefte yaratabileceği belirtilmiştir. Ancak 
	bu durum derleyicileri yazanların isteğine bırakılmıştır. Buna "kopya yapıcı fonksiyonun elimine edilmesi (copy elision)" denilmektedir. Ancak C++17 ile birlikte 
	bazı durumlarda artık "copy elision"steğe bağlı olmaktan çıkartılıp zorunlu hale getirilmiştir. (Yani derleyici bu özel durumlarda artık kopya yapıcı 
	fonksiyonunu elimine etmek zorundadır.)

	C++17 ile birlikte bir nesne sağ taraf değerine (prvalue) ilişkin bir nesne ile ilkdeğer verilerek yaratıldığında (yani tipik olarak bir geçici nesne ile ilkdeğer verilerek yaratıldığında) 
	yeni yaratılan nesne için kopya yapıcı fonksiyonu çalıştırılmaz. Doğrudan yeni nesne geçici nesne için çağrılacak yapıcı fonksiyonla ilkdeğer alır. Örneğin:

	Sample s = Sample(a, b, c);

	Burada normalde geçici nesne için yapıcı fonksiyon çağrılır, sonra s için kopya yapıcı fonksiyonu çağrılır. Ancak "copy elision" kuralı gereği bu işlem tamamen
aşağıdakine eşdeğer hale gelmektedir:

	Sample s(a, b, c);

	Örneğin:
	
	Sample s(Sample(Sample(Sample(a, b, c))));

	Bu işlem yine aşağıdakine eşdeğerdir:

	Sample s(a, b, c);

	Örneğin:

	Sample foo()
	{
		//...

		return Sample(a, b, c);
	}

	Sample s(foo());

	Burada return işleminde yaratılacak geçici nesne için kopya yapıcı fonksiyonu çalıştırılmaz. Doğrudan bu nesne a, b, c parametreli yapıcı fonksiyonla 
	yaratlır. Benzer biçimde aslında buradaki kodda yalnızca s için default yapıcı fonksiyon çağrılacaktır. 

	Bu biçimdeki "copy elision" C++17 öncesinde zorunlu değildi. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

class Sample {
public:
	Sample()
	{
		cout << "default constructor" << endl;
	}
	Sample(const Sample &r)
	{
		cout << "copy constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}
};

Sample foo()
{
	return Sample()
}

int main(void)
{
	Sample s = Sample();		// Yalnızca s için default yapıcı fonksiyon çalışıtırılır
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Ayrıca tüm C++ verisyonları dahil olmak üzere birkaç durumda da "isteğe bağlı (optional)" biçimde bir "copy elision" yapılabilmektedir. Bunlardan en önemli olanı 
	NRVO (Named Return Value Optimization) denilen durumdur. Bir fonksiyonun geri dönüş değeri bir sınıf türündense ve fonksiyonun return ifadesi o sınıf türünden 
	bir sınıf nesnesinin isminden oluşuyorsa bu durumda derleyici bu yerel sınıf nesnesi için yapıcı fonksiyonu çağırıp, geri dönüş değeri için kopya yapıcı fonksiyonu çağırmak yerine
	doğrudan bu yerel nesneyi zaten geri dönüş değeri ile aktarılacak geçici nesne biçiminde oluşturabilir. Dolayısıyla return işlemi sırasında kopya yapıcı fonksiyonu 
	çalıştırılmaz. Örneğin:

	Sample foo()
	{
		Sample s;

		//...

		return s;
	}

	Burada aslında s nesnesi zaten geri dönüş değeri için yaratılacak nesne biçiminde oluşturulabilir. Yani burada derleyici isterse geri dönüş değerine ilişkin nesneyi
	s gibi yaratabilir. Böylece kopya yapıcı fonksiyonu hiç çağrılmaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample()
	{
		cout << "default constructor" << endl;
	}
	Sample(const Sample &r)
	{
		cout << "copy constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl;
	}
};

Sample foo()
{
	Sample s;

	//...

	return s;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf başka bir sınıf türünden veri elemanlarına sahip olabilir. Örneğin Student öğrencilerin bilgilerini tutup onlar üzerinde işlem yapan bir sınıf olsun. 
	Öğrencinin ismi std::string sınıfı türünden bir nesne ile tutulabilir. Öğrencinin doğum tarihi Date isimli bir sınıf nenesi yoluyla tutulabilir:

	// student.hpp

	#ifndef PERSON_HPP_
	#define PERSON_HPP

	#include <string>
	#include "Date.hpp"

	class Student {
	public:
		//...
	private:
		int m_no;
		std::string m_name;
		Date m_bdate;
	};

	#endif

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Elemana sahip sınıf türünden bir nesne yaratıldığında eleman olan sınıf nesneleri o sınıfların kendi yapıcı fonksiyonları ile ilkdeğerlerini alır. Yani C++'ta
	elemana sahip sınıfın yapıcı fonksiyonları elemana ilişkin sınıfların yapıcı fonksiyonlarını çağırarak elemanlara ilkdeğerlerini vermektedir. Pekiyi elemana sahip sınıfın 
	yapıcı fonksiyonları elemana ilişkin sınıfın hangi yapıcı fonksiyonlarını ne zaman çağırmaktadır. İşte elemana sahip sınıfın yapıcı fonksiyonun elemana ilişkin sınıfın 
	hangi yapıcı fonksiyonunu çağıracağı MIL sentaksı denilen bir sentaks ile belirlenmektedir. MIL sentaksı yalnızca yapıcı fonksiyonlarda kullanıan bir sentakstır. 
	Elemana sahip sınıfın ismi T olmak üzere MIL sentaksının genel biçimi şöyledir:

	T::T(...) : eleman_ismi(argüman_listesi), eleman_ismi(argüman_listesi), eleman_ismi(argüman_listesi), ...
	{
		//...
	}

	Burada elemanlar için argüman listesine uygun yapıcı fonksiyonlar çağrılmaktadır. Buradaki argüman listesinde global değişkenler kullanılabilir, 
	elemana sahip sınıfın yapıcı fonksiyonlarının parametreleri kullanılabilir, sınıfın veri elemanları kullanılabilir.

	C++'ta her zaman elemana ilişkin sınıfların yapıcı fonksiyonları elemana sahip sınıfların yapıcı fonksiyonlarından daha önce çalıştırılır.
	Yani önce elemanlar için yapıcı fonksiyonlar çağrılır, sonra programın akışı elemana sahip sınıfın ana bloğundan içeri girer. Derleyiciler genellikle elemana ilişkin
	sınıf nesneleri için onların yapıcı fonksiyonlarını elemana sahip sınıfın yapıcı fonksiyonlarının başına yerleştirdikleri gizli bir çağırma kodu yoluyla çağırmaktadır.

	Elemanlar için yapıcı fonksiyonlar sınıf bildirimindeki sıraya göre çağrılmaktadır. MIL sentaksındaki sıranın hiçbir önemi yoktur. Örneğin:

	Student::Student(const char *name, int day, int month, int year, int no) : m_name(name), m_bdate(day, month, year)
	{
		m_no = no;
	}

	Burada m_name elemanı std::string türünden, m_bdate elemanı Date sınıfı türündendir. m_no ise int türdendir. Burada bildiriminde ilk belirtilen veri elemanı
	hangisiyse onun için yapıcı fonksiyon önce çağrılacaktır. MIL sentaksındaki sıranın bir önemi yoktur. 

	Sınıfın başka sınıf türünden bir veri elemanı MIL sentaksında belirtilmemişse o veri elemanı için o sınıfın default yapıcı fonksiyonu yine bildirimde belirtilen sırada
	çalıştırılmaktadır. Bu nedenle aşağıdaki gibi ilkdeğerleme işlemleri kötü bir tekniktir:

	Student::Student(const char *name, int day, int month, int year, int no) : m_bdate(day, month, year)
	{
		m_name = name;			// kötü teknik!
		m_no = no;
	}

	Burada m_name elemanı MIL sentaksında belirtilmemiştir. Bu durumda derleyici bu eleman için sınıfın default yapıcı fonksiyonunu çağırır. Elemanlar için yapıcı 
	fonksiyonlar çağrıldıktan sonra programın akışı ana bloğa girecek bu kez gereksiz bir biçimde m_name elemanı için std::string sınıfının atama operatör fonksiyonu çalıştırılacak 
	ve nihai değerler bu biçimde nesneye yerlştirilmiş olacaktır. Burada adeta nesneye iki kez değer yerleştirme durumu söz konusu olmaktadır. 
	
	Sınıfın temel türlere ilişkin (int, long double gibi) veri elemanları da MIL sentaksında belirtilebilir.

	Elemanlar için yapıcı fonksiyonlar sınıf bildirimindeki sıraya göre çağrılmaktadır. MIL sentaksındaki sıranın hiçbir önemi yoktur. Örneğin:

	Student::Student(const char *name, int day, int month, int year, int no) : m_name(name), m_bdate(day, month, year), m_no(no)
	{}

	Ancak temel türlere ilişkin veri elemanlarına MIL sentaksında değer atamak ile ana blok içerisinde değer atamak arasında bir etkinlik farkı yoktur. Yani derleyici 
	sınıfın temel türlere ilişkin veri elemanları için MIL sentaksında ilkdeğerleme yapılmadıysa zaten onlara herhangi bir değer yerleştirmez. Tabii işlemlerin yapılma sırası
	bakımından farklılık söz konusu olabilmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp 

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date();
	Date(int day, int month, int year);
	void disp() const;

	int day() { return m_day; }
	void set_day(int day) {	m_day = day; }

	int month() const { return m_month; } 
	void set_month(int month) {	m_month = month; }
	int year() const { return m_year;	}
	void set_year(int year)	{ m_year = year; }
private:
	int m_day;
	int m_month;
	int m_year;
};

#endif

// date.cpp

#include <iostream>
#include <ctime>
#include "date.hpp"

using namespace std;

Date::Date()
{
	time_t t;
	struct tm *pt;

	time(&t);
	pt = localtime(&t);

	m_day = pt->tm_mday;
	m_month = pt->tm_mon + 1;
	m_year = pt->tm_year + 1900;
}

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

// student.hpp

#ifndef PERSON_HPP_
#define PERSON_HPP

#include <string>
#include "Date.hpp"

class Student {
public:
	Student() = default;
	Student(const char *name, int day, int month, int year, int no);
	void disp() const;
private:
	int m_no;
	std::string m_name;
	Date m_bdate;
};

#endif

// student.cpp

#include <iostream>
#include "student.hpp"

using namespace std;

Student::Student(const char *name, int day, int month, int year, int no) : m_name(name), m_bdate(day, month, year)
{
	m_no = no;
}

void Student::disp() const
{
	cout << m_name << endl;
	m_bdate.disp();
	cout << m_no << endl;

}

// app.cpp 

#include <iostream>
#include "student.hpp"

using namespace std;

int main(void)
{
	Student student("Hasan Oz", 12, 11, 2001, 1234);

	student.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfın başka sınıf türünden veri elemanlarını get etmek için kullanılan getter fonksiyonları kopya yapıcı fonksiyonun çalıştırılmasına yol açabilmektedir. Örneğin:

	class Person {
	public:
		//...
		std::string name() const { return m_name;}
	private:
		std::string m_name;
		in m_no;
	};

	Burada name isimli getter fonksiyon bize string nesnesi verdiği için kopya yapıcı fonksiyonun çalıştırılmasına yol açacaktır. Bazen programcılar bunu 
	engellemek için getter fonksiyonunun geri dönüş değerini const referans almaktadır. Örneğin:

		class Person {
	public:
		//...
		const std::string &name() const { return m_name;}
	private:
		std::string m_name;
		in m_no;
	};

	Burada aslında name isimli getter fonksiyon m_name elemanının adresiyle geri dönmektedir. Referansın const yapılması fonksiyonun adresini aldığı nesneyi değiştirememesi için 
	gerekmektedir. Tabii bu tür durumlarda sınıfın veri elemanı olan nesnenin türü değiştilemez. Çünkü bu durumda getter fonksiyonlarını kullanan kodların da değiştirilmesi 
	gerekir. Ancak genel olarak getter fonksiyonlar yazılırken bu biçimde referanslaa geri dönmemek daha iyi bir tekniktir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
   Şimdi GUI işlemleri için kullanılabilecek bir Point sınıfı ve Rectangle sınıfı oluşturalım. Point sınıfı ekrandaki bir noktanın koordinatlarını tutup
   bazı faydalı işlemler yapmaktadır. Rectangle sınıfı ise dikdörtgenin sol-üst ve sağ-alt köşe koordinatlarını Point nesnesi olarak tutup birtakım faydalı 
   işlemler yapmaktadır. Bu tür Point ve Rectangle sınıfları GUI framework'lerinde benzer biçimlerde bulunmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// point.hpp 

#ifndef POINT_HPP_
#define POINT_HPP_

class Point {
public:
	// constructors
	Point() = default;
	Point(int x, int y) : m_x(x), m_y(y)
	{}

	//getter/settr
	int x() const { return m_x; }
	void set_x(int x) { m_x = x; }
	int y() const { return m_y; }
	void set_y(int y) { m_y = y; }
	
	// utilities
	void move(int x, int y);
	void move(const Point &pt);

	void move_delta(int dx, int dy);
	void move_delta(const Point &pt);

	void disp() const;
private:
	int m_x;
	int m_y;
};

#endif

// point.cpp

#include <iostream>
#include "point.hpp"

using namespace std;

void Point::move(int x, int y)
{
	m_x = x;
	m_y = y;
}

void Point::move(const Point &pt)
{
	m_x = pt.m_x;
	m_y = pt.m_y;
}


void Point::move_delta(int dx, int dy)
{
	m_x += dx;
	m_y += dy;
}

void Point::move_delta(const Point &pt)
{
	m_x += pt.m_x;
	m_y += pt.m_y;
}

void Point::disp() const
{
	cout << '(' << m_x << ',' << m_y << ')' << endl;
}

#ifndef RECTANGLE_HPP_
#define RECTANGLE_HPP_

#include "point.hpp"

class Rectangle {
public:
	// constructors
	Rectangle() : m_pt1(0, 0), m_pt2(0, 0)
	{}
	Rectangle(int x1, int y1, int x2, int y2) : m_pt1(x1, y1), m_pt2(x2, y2)
	{}
	Rectangle(const Point &pt1, const Point &pt2) : m_pt1(pt1), m_pt2(pt2)
	{}

	// utilities

	int width() const;
	int height() const;

	bool contains(int x, int y) const;
	bool contains(const Point &pt) const;

	void move_delta(int dx, int dy);
	void move_delta(const Point &pt);

	void disp() const;

private:
	Point m_pt1;
	Point m_pt2;
};

#endif

#include <iostream>
#include "rectangle.hpp"

using namespace std;

int Rectangle::width() const
{
	return m_pt2.x() - m_pt1.x();
}

int Rectangle::height() const
{
	return m_pt2.y() - m_pt1.y();
}

bool Rectangle::contains(int x, int y) const
{
	return x > m_pt1.x() && x < m_pt2.x() && y > m_pt1.y() && y < m_pt2.y();
}

bool Rectangle::contains(const Point &pt) const
{
	return pt.x() > m_pt1.x() && pt.x() < m_pt2.x() && pt.y() > m_pt1.y() && pt.y() < m_pt2.y();
}

void Rectangle::move_delta(int dx, int dy)
{
	m_pt1.move_delta(dx, dy);
	m_pt2.move_delta(dx, dy);
}

void Rectangle::move_delta(const Point &pt)
{
	m_pt1.move_delta(pt);
	m_pt2.move_delta(pt);
}

void Rectangle::disp() const
{
	cout << "x1 = " << m_pt1.x() << ", y1 = " << m_pt1.y() << ", x2 = " << m_pt2.x() << ", y2 = " << m_pt2.y() << endl;
}

// app.cpp 

#include <iostream>
#include "point.hpp"
#include "rectangle.hpp"

using namespace std;

int main(void)
{
	Rectangle rect(10, 10, 20, 20);

	if (rect.contains(15, 15))
		cout << "içeride" << endl;
	else
		cout << "içeride değil" << endl;
	
	cout << rect.width() << endl;
	cout << rect.height() << endl;


	Rectangle rect2(Point(12, 15), Point(20, 25));

	rect2.disp();

	return 0;
}


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	MIL sentaksı kopya yapıcı fonksiyonlarında da benzer biçimde kullanılmaktadır. Örneğin bir sınıfın başka sınıf türünden veri elemanları varsa ve biz bu 
	sınıf için kopya yapıcı fonksiyonunu yazıyorsak bu durumda bu kopya yapıcı fonksiyonu elemanların MIL sentaksıyla kopya yapıcı fonksyonlarını çalıştıracak biçimde
	yazılmalıdır. Aksi takdirde yine elemanlar için default yapıcı fonksiyon çalıştırılır. Tabii derleyicinin kendi yazdığı kopya yapıcı fonksiyonu zaten elemanlar için 
	onların kopya yapıcı fonksiyonlarını çağırmaktadır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp 

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date() = default;
	Date(int day, int month, int year);
	void disp() const;
	int day() const { return m_day; }
	int month() const { return m_month; }
	int year() const { return m_year; }

private:
	int m_day;
	int m_month;
	int m_year;
};

#endif

// date.cpp

#include <iostream>
#include "date.hpp"

using namespace std;

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

// person.hpp

#ifndef PERSON_HPP_
#define PERSON_HPP_

#include <string>
#include "date.hpp"

class Person {
public:
	Person(const char *name, const Date &bdate, int no);
	Person(const Person &person);
	void disp() const;

private:
	std::string m_name;
	Date m_bdate;
	int m_no;
};

#endif

#include <iostream>
#include "person.hpp"

using namespace std;

Person::Person(const char *name, const Date &bdate, int no) 
	: m_name(name), m_bdate(bdate), m_no(no)
{}

Person::Person(const Person &person) : m_name(person.m_name), m_bdate(person.m_bdate), m_no(person.m_no)
{
}

void Person::disp() const
{
	cout << m_name << ", " << m_bdate.day() << '/' << m_bdate.month() << '/' << m_bdate.year() << ", " << m_no << endl;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta const bir sol taraf değeri referans parametresine sahip bir fonksiyonla aynı isimli sağ taraf referans parametreli bir fonksiyon bir arada bulunabilir. Bu durumda
	overload resolution işlemi sırasında eğer fonksiyon bir sol taraf değeri ile çağrılırsa sol taraf değeri referansına ilişkin fonksiyon, sağ taraf değeri ile çağrılırsa
	sağ taraf değeri referansına ilişkin fonksiyon seçilir. Zaten böylesi bir durumda fonksiyon bir sol taraf değeri ile çağrıldığında sağ taraf değeri referansına sahip olan fonksiyon
	"uygun (viable)" olmayacaktır. Ancak fonksiyon bir sağ taraf değeri ile çağrıldığında her iki fonksiyon da "uygun (viable)" durumda olur. İşte bu durumda sağ taraf değeri 
	referansına sahip olan fonksiyon daha iyi bir dönüştürme sunmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void foo(const int &r)
{
	cout << "foo, const int &" << endl;
}

void foo(const int &&r)
{
	cout << "foo, const int &&" << endl;
}

int main(void)
{
	int a = 10;

	foo(a);			// const int & parametreli olan çağrılır
	foo(10);		// int && parametreli olan çağrılıe

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıfın sınıf ismi T olmak üzere aşağıdaki parametre yapısına sahip yapıcı fonksiyonlarına "taşıma yapıcı fonksiyonları (move constructors)" denilmektedir:
	
	- T && 
	- const T &&
	- volatile T &&
	- const volatile T &&

	Taşıma yapıcı fonksiyonlarının const parametreli olmasının anlamı yoktur. Dolayısıyla taşıma yapıcı fonksiyonları tipik olarak T && parametreli olur.

	Taşıma yapıcı fonksiyonları C++11 ile birlikte dile eklenmiştir. Zaten C++11 ile birlikte "sağ taraf değeri referanslarının" dile eklenmesinin asıl nedeni 
	"taşıma semantiği (move semantics)" denilen bu durumun sağlanması içindir. Örneğin:

	class Sample {
	public:
		Sample(const Sample &r);		// copy constructor
		Sample(Sample &&r);				// move constructor (C++11 ile birlikte)
		//...
	};

	Pekiyi taşıma yapıcı fonksiyonuna neden gereksinim duyulmaktadır? Bir sınıfın bir veri elemanı için dinamik tahsisat yaptığını düşünelim. Bu dinamik tahsisat
	yıkıcı fonksiyonda serbest bırakılacaktır. Bu tür durumda sınıfın aynı sınıf türünden hayatını kaybetmekte olan bir nesneyle ilkdeğer verilerek yaratılması işleminde kopya yapıcı fonksiyonun
	içerik kopyalaması yapacak biçimde programcı tarafından yazılması gerektiğini belirtmiştik. İşte bu kopya yapıcı fonksiyonu içerik kopyalaması için yeni bir alan tahsis etmek durumundadır. 
	Daha önce yazığımız String sınıfının kopya yapıcı fonksiyonunu yeniden gözden geçiriniz:

	String::String(const String &r)
	{
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
		m_len = r.m_len;
	}

	Ancak bazı durumlarda bir nesne zaten hayatını kaybederken onun kopya yapıcı fonksiyonu yoluyla yeni bir nesneye kopyalanması gereksiz olabilmektedir. Bu tür durumlar
	özellikle operatör fonksiyonlarında önemli bir performans kaybına yol açmaktadır. Halbuki hayatını kaybetmekte olan nesnenin kaynakları (yani onun tahsis ettiği alnlar vs.)
	o nesneden alınıp yeni nesneye taşınabilir. Böylece yeni yaratılan nesne gereksiz bir tahsisat yapmayacaktır. C++11'de hayatını kaybetmek üzere olan nesnelere xvalue
	denilmektedir. xvalue aslında rvalue gibi işlemlere sokulur. Ancak bunlar bellekte bir nesne de belirttikleri için aynı zamanda lvalue özelliğine de sahiptirler. 

	İşte C++'ta C++11 ile birlikte taşıma yapıcı fonksiyonları hayatını kaybetmekte olan nesnenin kaynaklarını alarak kullanmak için yazılmaktadır. Yaşamını kaybetmek
	üzere olan bir sınıf nesnesi yeni yaratılmakta olan bir sınıf nesnesine ilkdeğer verilmişse bu durumda yeni yaratılan sınıf nesnesi için o sınıfın varsa taşıma yapıcı fonksiyonu, 
	yoksa normal kopya yapıcı fonksiyonu çağrılmaktadır. Örneğin:

	String foo()
	{
		String s("istanbul");

		s.disp();

		return s;
	}

	Burada return s ifadesindeki s hayatını kaybetmekte olan bir sınıf nesnesidir. Bu sınıf nesnesi geri dönüş değeri için yaratılacak nesneye ilkdeğer olarak verilmiştir. 
	İşte bu durumda geri dönüş değeri için String sınıfının varsa taşıma yapıcı fonksiyonu çağrılır. Pekiyi bu String sınıfının taşıma yapıcı fonksiyonu nasıl yazılmalıdır?
	İşte taşıma yapıcı fonksiyonları kaynak taşıması yapacak biçimde yazılmalıdır. Örneğin:

	String::String(String &&r)
	{
		m_str = r.m_str;
		m_len = r.m_len;
		r.m_str = 0;
	}

	Biz bir sınıf için taşıma yapıcı fonksiyonunu yazmak zorunda değiliz. Bu durumda o sınıf için yine kopya yapıcı fonksiyonu çağrılacaktır. Ayrıca C++11'de 
	bir sınıf için programcı taşıma yapıcı fonksiyonunu yazmışsa ancak kopya yapıcı fonksiyonunu yazmamışsa artık kopya yapıcı fonksiyonu derleyici tarafından otomatik 
	yazılmamaktadır. 

	Programcı sınıfı için taşıma yapıcı fonksiyonunu yazmamışsa bazı koşullarda bu taşıma yapıcı fonksiyonu public inline olarak içerik kopyalaması yapacak biçimde yazılmaktadır.
	Ancak programcı kopya yapıcı fonksiyonunu sınıf için yazmışsa derleyici taşıma yapıcı fonksiyonu yazmamaktadır. Bu konuda bazı detaylar bulunmaktadır. 

	Aşağıdaki örnekte daha önce yazmış olduğumuz String sınıfına taşıma yapıcı fonksiyonu (move constructor) eklenmiştir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor
	void disp();

	~String();

private:
	char *m_str;
	std::size_t m_len;
};

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = new char[1]{'\0'};
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	m_str = new char[r.m_len + 1];
	strcpy(m_str, r.m_str);
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = 0;
}

void String::disp()
{
	cout << m_str << endl;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "String.hpp"

using namespace std;

String foo()
{
	String s("istanbul");

	s.disp();

	return s;			// move constructor çağrılır (copy elision da yapılabilir)
}

int main(void)
{
	String s = foo(); // C++17 ile birlikte copy elision zorunlu hale getirildi	

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen elimizde bir sınıf türünden sol taraf değeri belirten bir nesne bulunur. Ancak biz onu sağ taraf değeri referanslı bir fonksiyona göndermek isteyebiliriz. 
	Bu durumda bizim sol taraf değerini geçici bir nesne yaratmadan sağ taraf değeri haline getirmemiz gerekir. Bunun en temel yolu ilgili sol taraf değerini
	aynı türden bir sağ taraf değeri referansına dönüştürmektir. Örneğin:

	foo(static_cast<Sample &&>(s));

	gibi. 

	Aslında bu iş bir fonksiyona da yaptırırlabilir. Zaten C++11 ile birlikte bu işlemi yapan tanımlaması <utility> dosyasında bulunan move isimli şablon bir fonksiyon bulundurulmuştur.
	Bu durumdaaynı işlemi şöyle de yapabiliriz:

	foo(move(s));

	Bu durumda elimizde bir sınıf nesnesi varsa onun hayatını kaybetmesini beklemeden move fonksiyonunu kullanarak onu sağ taraf değeri referansına dönüştürüp
	taşıma yapıcı fonksiyonuna (ya da taşıma operatör fonksiyonuna) vererek kaynaklarını taşıyabiliriz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <utility>

using namespace std;

class Sample {
public:
	//...
};

void foo(const Sample &r)
{
	cout << "foo, const Sample &" << endl;
}

void foo(Sample &&r)
{
	cout << "foo, Sample &&" << endl;
}

int main(void)
{
	Sample s;

	foo(s);					// const Sample & parametreli olan çağrılır
		
	foo(Sample());			// Sample && parametreli olan çağrılır

	foo(static_cast<Sample &&>(s));		// Sample && parametreli olan çağrılır
	foo(move(s));						// Sample && parametreli olan çağrılır
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda biz return işlemi ile yaşamını kaybetmekte olan nesneler eğer bir sınıf türünden nesneye ilkdeğer olarak kullanılıyorsa zaten sınıfın taşıma yapıcı 
	fonksiyonun çağrılacağını belirtmiştik. Bu özel durumda sol taraf değerini move ile sağ taraf değerine dönüştürmemiz gerekmemektedir. 

	String foo()
	{
		String s("ankara");

		s.disp();

		return s;			// return move(s) ile aynı anlamda
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte C++'ın standart kütüphanesindeki bazı sınıflar için de taşıma yapıcı fonksiyonları eklenmiştir. Örneğin artık string, vector gibi sınıflar
	kaynak taşıması yapabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

string foo()
{
	string s("ankara");

	cout << s << endl;

	return s;			// string sınıfının move constructor'ı çağrılır
}

int main(void)
{
	string s;

	s = foo();			

	cout << s << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte sınıfın bir yapıcı fonksiyonun başka bir yapıcı fonksiyonunu çağırması mümkün hale getirilmiştir. Buna "delegating constructor" denilmektedir. 
	Aslında bu özellik Java, C# gibi dillerde zaten başından beri bulunmaktaydı. Ancak C++'a C++11 ile eklenmiştir. Bir yapıcı fonksiyonun diğerini çağırması 
	MIL sentaksı ile yapılmaktadır. Bu biçimdeki delege edilmiş yapıcı fonksiyon çağrılırken MIL sentaksına başka bir eleman yerleştirilemez. Örneğin:

	class Sample {
	public:
		Sample() : Sample(0)		// Burada MIL sentaksında başka öğe yerleştirilemez
		{
			//...
		}

		Sample(int a)
		{
			m_a = a;
			//...
		}
	private:
		int m_a;
	};

	Tabii bu durumda akış önce MIL sentaksında belirtilen yapıcı fonksiyona aktarılır. Bu yapıcı fonksiyon çalıştırıldıktan sonra akış asıl yapıcı fonksiyondan 
	ana bloğundan girer. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() : Sample(0, 0, 0)
	{
		cout << "Sample::Sample()" << endl;
	}

	Sample(int x, int y, int z)
	{
		cout << "Sample::Sample(int, int, int)" << endl;

		m_x = x;
		m_y = y;
		m_z = z;
	}

private:
	int m_x;
	int m_y;
	int m_z;
};

int main()
{
	Sample s;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir proje nesne yönelimli olarak modellenecekse önce projedeki kavramlar sınıflarla temsil edilir. Sonra bu kavramlar türünden gerçek nesneler yaratılır ve 
	program sınıflar kullanılarak yazılır. Örneğin bir hastane otomasyonunda "hastane", "doktor", "hemşire", "hasta" vs. gibi kavramlar birer sınıfla temsil edilmelidir. 
	Örneğin hastanemizde 10 doktor varsa biz 10 doktor nesnesi yaratırız. Tüm hastaneyi temsil eden bir tane hastane nesnesi yaratırız. 

	Ancak sınıflar da mantıksal bakımdan birbirleriyle ilişkili olabilirler. Sınıflar arasında dört temel ilişki biçimi vardır:

	1) İçerme ilişkisi (composition)
	2) Birleşme ilişkisi (aggregation)
	3) Türetme ilişkisi (inheritance)
	4) Çağrışım ilişkisi (association)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden bir nesne başka bir sınıf türünden bir nesnenin bir parçasını oluşturuyorsa bu iki sınıf arasında "içerme ilişkisi (compoistion)" 
	vardır. İçerme ilişkisi bire-bir olabileceği gibi bire-çok biçimde de olabilir. İçerme ilişkisi UML sınıf diyagramlarında içeren sınıf tarafında içi dolu bir 
	baklavacık (dimaond) ile gösterilmektedir. 

	İçerme ilişkisinin iki temel özelliği vardır:

	1) İçerilen nesne tek bir nesne tarafından içerilir. 
	2) İçeren nesne ile içerilen nesnenin ömürleri yaklaşık aynıdır.

	Bu durumda örneğin insan ile böbrek sınıfı arasında içerme ilişkisi vardır. Böbrekle insan aynı zamanda hayata başlarlar ve aynı zamanda yaşamlarını bitiriler. 
	Bir böbrek tek bir insanın böbreğidir. Aynı zamanda başka bir insanın böbreği değildir. Tabii bu tür modellemelerde tipik durumlar dikkate alınmalıdır. 
	Yani örneğin böbrek nakli tipik bir durum değildir. Böbrek naklinin yapılıyor olması bir böbreğin başkaları tarafından da tipik olarak kullanıldığı anlamına 
	gelmez. Örneğin "oda" ile "duvar" arasındaki ilişki içerme ilişkisi değildir. Her ne kadar oda ile duvarın yaşamları aynıysa da duvar yandaki odanın da duvarıdır. İnsan ile Böbrek 
	sınıfları arasındaki içermel ilişkisi bire-iki biçimindedir. Yani bir insanda iki böbrek bulunmaktadır. 

	C++'ta içerme ilişkisi iki biçimde oluşturulabilir:

	1) İçeren sınıfın private bölümünde içerilen sınıf türünden bir veri elemanı alınır. İçeren sınıf nesnesi yaratıldığında içerilen nesne de yaratılmış olacaktır.
	2) İçeren sınıfın private bölümünde içerilen sınıf türünden bir gösterici veri elemanı bulundurulur. İçeren sınıfın yapıcı fonksiyonunda da new operatörüyle bu veri elemanı 
	için dinamik tahsisat yapılır. Tabii bu tahsisat içeren sınıfın yıkıcı fonksiyonunda delete operatörü ile yok edilmelidir. 

	İçerme ilişkisine İngilizce aynı zamanda "has a" ilişkisi de denilmektedir. 

	Aşağıda içerme ilişkisinin birinci birinci biçimine ilişkin örnek görüyorsunuz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Motor {
    //...
};

class Araba {
    //...
private:
    Motor m_motor;
    //...
};

int main(void)
{
    Araba araba;        
    //...

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıda da içerme ilişkisinin ikinci biçimine ilişkin örnek görüyorsunuz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Motor {
    //...
};

class Araba {
public:
    Araba();
    ~Araba();
private:
    Motor *m_motor;
    //...
};

Araba::Araba()
{
    m_motor = new Motor();
    //...   
}

Araba::~Araba()
{
    //...
    delete m_motor;
}

int main(void)
{
    Araba araba;        
    //...

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Birleşme (aggregation) ilişkisinde bir sınıf türünden nesne başka bir sınıf türünden nesneyi kullanmaktadır. Ancak kullanılan nesne başka nesneler tarafından da
	kullnılıyor olabilir. Kullanan nesne ile kullanılanılan nesnenin yaşamları aynı olmayabilir. Genel olarak içerme ilişkisine uymayan kullanma ilişkisi birleşme
	ilişkisi biçimindedir. Örneğin Hastana ile Doktor sınıfları arasında, Bilgisayar ile Fare sınıfları arasında birleşme ilişkisi vardır. Birleşme ilişkisi 
	UML sınıf diyagramlarında kullanan sınıf tarafında içi boş bir baklavacık (dimaond) ile gösterilmektedir. Birleşme ilişkisi de bire-bir olabileceği gibi bire-çok
	olabilir. 

	Birleşme ilişkisi C++'ta tipik olarak kullanan sınıf içerisinde kulalnılan sınıfa ilişkin bir gösterici tutularak gerçekleştirilir. Tabii bu gösterici dışsarıda
	yaratılmış olan bir nesneyi gösterecektir. Bu sayede birden fazla nesne gösterici yoluyla aynı nesnesiyi kullanabilmektedir. 

	Birleşme ilişkisine İngilizce'de aynı zamanda "holds a" ilşkisi de denilmektedi. 

	Aşağıdaki örnekte Computer ile Mouse sınıfları arasındaki birleşme ilişkisi görülmektedir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

class Mouse {
    //...
};

class Computer {
public:
    Computer() : m_mouse(nullptr)
    {
        //...
    }

    void attach_mouse(Mouse *mouse)
    {
        m_mouse = mouse;
    }

    Mouse *detach_mouse()
    {
        Mouse *mouse = m_mouse;
        m_mouse = nullptr;

        return mouse;
    }
private:
    Mouse *m_mouse;
    //...
};

int main(void)
{
    Computer computer1;
    Computer computer2;
    //...
    Mouse *mouse1 = new Mouse();
    computer1.attach_mouse(mouse1);

    auto mouse = computer1.detach_mouse();
    computer2.attach_mouse(mouse);

    Mouse *mouse2 = new Mouse();
    computer1.attach_mouse(mouse2);

    delete mouse1;
    delete mouse2;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki bir satranç tahtasının NYPT ile modellenmesi örneği verilmiştir. Burada Board sınıfı tahtayıi Square sınıfı tahtanının karelerini ve Figure 
	sınıfı ise satranç taşlarını temsil etmektedir. Board sınıfı ile Square sınıfı arasında "içerme (composition)", Square sınıfı ile Figure sınıfı arasında ise
	"birleşme (aggregation)" ilişkisi vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

enum class Color {
    White, Black
};

enum class Type {
    King, Queen, Rook, Bishop, Knight, Pawn
};

class Figure {
public:
    Figure(Type type, Color color) : m_type(type), m_color(color)
    {}
    Type type() const { return m_type; }
    Color color() const { return m_color; }
    string to_string();
    friend ostream &operator <<(ostream &os, Figure *figure);
    //...
private:
    Type m_type;
    Color m_color;
};

class Square {
public:
    Square() = default;
    Square(Color color) : m_color(color)
    {}
    Color color() const { return m_color; }
    void set_color(Color color) { m_color = color;}
    Figure *figure() const { return m_figure; }
    void set_figure(Figure *figure) { m_figure = figure; }
    //...
private:
    Color m_color;
    Figure *m_figure;
};

string Figure::to_string()
{
    static const char *figure_names[] = {"King", "Queen", "Rook", "Bishop", "Knight", "Pawn"};

    string s;

    s += m_color == Color::Black ? "Black " : "White ";
    s += figure_names[static_cast<int>(m_type)];

    return s;       // move constructor çağrılacak
}

ostream &operator <<(ostream &os, Figure *figure)
{
    os << figure->to_string();

    return os;
}

class Board {
public:
    Board();
    Square &square(int row, int col)
    {
        return m_squares[row][col];
    }
private:
   Square m_squares[8][8];
};

Board::Board()
{
    for (int row = 0; row < 8; ++ row)
        for (int col = 0; col < 8; ++col) {
            m_squares[row][col].set_color((row + col) % 2 == 0 ? Color::Black : Color::White);
            m_squares[row][col].set_figure(nullptr);
        }

    m_squares[0][0].set_figure(new Figure(Type::Rook, Color::White));
    m_squares[7][0].set_figure(new Figure(Type::Rook, Color::Black));

    m_squares[0][1].set_figure(new Figure(Type::Knight, Color::White));
    m_squares[7][1].set_figure(new Figure(Type::Knight, Color::Black));

    m_squares[0][2].set_figure(new Figure(Type::Bishop, Color::White));
    m_squares[7][2].set_figure(new Figure(Type::Bishop, Color::Black));

    m_squares[0][3].set_figure(new Figure(Type::Queen, Color::White));
    m_squares[7][3].set_figure(new Figure(Type::Queen, Color::Black));

    m_squares[0][4].set_figure(new Figure(Type::King, Color::White));
    m_squares[7][4].set_figure(new Figure(Type::King, Color::Black));

    m_squares[0][5].set_figure(new Figure(Type::Bishop, Color::White));
    m_squares[7][5].set_figure(new Figure(Type::Bishop, Color::Black));

    m_squares[0][6].set_figure(new Figure(Type::Knight, Color::White));
    m_squares[7][6].set_figure(new Figure(Type::Knight, Color::Black));

    m_squares[0][7].set_figure(new Figure(Type::Rook, Color::White));
    m_squares[7][7].set_figure(new Figure(Type::Rook, Color::Black));

    for (int col = 0; col < 8; ++col) {
        m_squares[1][col].set_figure(new Figure(Type::Pawn, Color::White));
        m_squares[6][col].set_figure(new Figure(Type::Pawn, Color::Black));
    }
}

int main(void)
{
    Board board;

    cout << board.square(0, 0).figure()->to_string() << endl;

    cout << board.square(0, 5).figure() << endl;

    return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    NYPT'de "kalıtım (inheritance)" bir sınıfa ona dokunmadan ekleme yapmak için kullanılan bir yöntemdir. Elimizde A isimli bir sınıf bulunuyor olsun. 
	Biz bu sınıfa onu bozmadan birkaç üye fonksiyon eklemek isteyelim. İşte bu A sınıfından bir B sınıfını türetiriz. Ekleyeceğimiz üye fonksiyonları bu
	B sınıfına ekleriz. Burada ekleme yapmak istediğimiz A sınıfına "taban sınıf (base class)" eklemelerin yapıldığı B sınıfına da "türemiş sınıf (derived class)"
	denilmktedir. Türemiş sınıf hem taban sınıf gibi davranmakta hem de kendine özgü fazlalıklara sahip olmaktadır. Türemiş sınıftan da sınıflar türetilebilir. 
	Bu durumda türemiş sınıf onun taban sınıflarının tüm işlevselliklerine sahip olur. UML sınıf diyagramlarında türetme ilişkisi "türemiş sınıftan taban sınıfa doğru
	çekilen içi boş bir okla" temsil edilmektedir.

	C++'ta türetme ilişkisine İmgilizce "is a" ilişkisi de denilmektedir. 

	Bir sınıf birden fazla sınıfın taban sınıfı durumunda olabilir. Bu durum tamamen normal bir durumdur. Ancak bir sınıfın birden fazla taban sınıfa sahip olması 
	durumu özel bir durumdur. Buna NYPT'de "çoklu türetme (multiple inheritance)" denilmektedir. Java, C#, Swift gibi dillerin bazılarında çoklu türetme yoktur.
	Ancak C++, Object Pascal, Python gibi dillerde çoklu türetme vardır. 

	Türetmenin en önemli kullanım nedeni sınıfa onu bozmadan eklemeler yapmak ve kod tekrarını ortadan kaldırmaktır. İki sınıf ortak elemanlara sahipse
	bu sınıfların bağımsız yazılması durumunda gereksiz kod tekrarı oluşur. Halbuki bu ortak elemanlar bir taban sınıfta toplanırsa bu kod tekrarı ortadan 
	kaldırılmış olur. Örneğin B isimli bir sınıfta foo, bar ve tar fonksiyonları bulunuyor olsun. C isimli bir sınıfta da foo, bar ve zar fonksiyonları bulunuyor olsun.
	Burada foo ve bar fonksiyonları her iki sınıfta da tekrarlanmaktadır. Biz bu iki fonksiyonu taban bir A sınıfına yerleştirip B ve C'yi bu sınıftan türetirsek 
	kod tekrarını ortadan kaldırmış oluruz. 

	C++'ta türetme işlemleri özel bir setaksla yapılmaktadır. İzleyen bölümde türetme işlemlerinin nasıl yapıldığı açıklanacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Çağrışım ilişkisinde (association) bir sınıf bir sınıfı kullanmaktadır. Ancak bu kulanma onu bünyesine katarak (yani bir veri elemanında saklayarak) yapılmaz.
	Yalnızca üye fonksiyonlar tarafından yapılır. Yani kullanma bazı alanlarla sınırlıdır. Örneğin Hastane sınıfı gerektiğinde reklam yapacaktır. Bunun için sınıfın
	reklam_yap gibi bir üye fonksiyonu reklam şirketini kullanabilir. Bir ticari taksi ile şoför arasında bir birleşme ilişkisi vardır. Bunlarla taksinin sahibi 
	arasında bir birleşme ilişkisi vardır. Ancak taksi ile yolcu arasındaki ilişki yüzeyseldir. Bu ilişki çağrışım ilişkisi biçiminde ifade edilebilir.

	Çağrışım ilişkisi UML sınıf diyagramlarında kullanan sınıftan kullanılan sınıfa doğru ince bir çizgi ve bir okla temsil edilmektedir.  

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta türetme işleminin genel biçimi şöyledir:

	class <türemiş sınıf ismi> : [türetme biçimi] <taban sınıf ismi> {
		//...
	};

	Buradaki türetme biçimi "public", "protected" ya da "private" biçiminde olabilir. Türetme biçimi belirtilmezse türemiş sınıf class anahtar sözcüğü ile oluşturulmuşsa
	"private", struct anahtar anahtar sözcüğü ile oluşturulmuşsa "public" kabul edilir. En yaygın kullanılan türetme biçimi public türetmesidir. Java, C# gibi dillerde
	türetme biçimi yoktur. Ancak o dillerdeki türetme C++'taki "public türetmesi" gibidir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türetme işleminde türemiş sınıf hem taban sınıf gibi kullanılabilmekte hem de ek birtakım elemanlara sahip olabilmektedir. Aşağıdaki örnekte B sınıfı A'dan
	türetilmiştir. B sınıfı hem A gibi kullanılabilir hem de kendi elemanlarına sahiptir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;


class A {
public:
	void foo();
	void bar();
	//...
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void A::bar()
{
	cout << "A::bar" << endl;
}

class B : public A {
public:
	void tar();
	//....
};

void B::tar()
{
	cout << "B::tar" << endl;
}

int main()
{
	B b;

	b.foo();
	b.bar();
	b.tar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf veri elemanları bakımından da taban sınıfı içermektedir. Yani türemiş sınıf türünden bir nesne hem türemiş sınıfın veri elemanlarını hem de taban 
	sınıfın veri elemanlarını içerir. Standartlarda türemiş sınıf nesnesi içerisindeki veri eleman diziliminde taban sınıfın mı yoksa türemiş sınıfın mı
	veri elemanlarının düşük adreste bulundurulacağı konusunda bir belirlemede bulunulmamıştır. Ancak derleyicilerin hemen hepsi türemiş sınıf nesnesi yaratıldığında
	önce taban sınıf veri elemanlarını sonra türemiş sınıf veri elemanlarını ardışıl bir biçimde yerleştimektedir. Örneğin B sınıfı A sınıfından türetilmiş olsun.
	Biz de B sınıfı türünden bir nesne yaratmış olalım. Tipik organizasyon şöyledir:

	A-data-members
	B-data-members

	Dolayısıyla türemiş nesnesinin adresini aldığımızda önce onun taban kısmıyla karşılaşırız. Aşağıdaki örnekte taban ve türemiş sınıf içerisinde ikişer int 
	türen veri elemanı bulundurulmuştur. Bunların sizeof değerlerine dikkat ediniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	int m_x;
	int m_y;
};

class B : public A {
public:
	int m_z;
	int m_k;
};

int main()
{
	B b;

	cout << sizeof b << endl;			// 16

	b.m_x = 10;
	b.m_y = 20;
	b.m_z = 30;
	b.m_k = 40;

	cout << b.m_x << ", " << b.m_y << ", " << b.m_z << ", " << b.m_k << endl;		// 10, 20, 30, 40

	A a;

	cout << sizeof a << endl;		// 8


	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türemiş sınıflarda erişim kuralları türetme biçimine göre değişmektedir. Yukarıda da belirttiğimiz gibi en çok kullanılan türetme biçimi "public türetmesisir".

	public türetmesinde taban sınıfın public bölümü türemiş sınıfın public bölümüymüş gibi, taban sınıfın protected bölümü türemiş sınıfın protected bölümüymüş gibi
	işlem görür. Taban sınıfın private bölümü tamamen korunmuştur. Türemiş sınıf tarafından erişilemez. 

	public türetmesinden çıkan sonuçlar şunlardır:

	1) Türemiş sınıfın üye fonksiyonu içerisinde biz taban sınıfın public ve protected bölümlerindeki elemanlara doğrudan erişebiliriz. 
	2) Dışarıdan türemiş sınıf nesnesi, göstericisi ya da referansı yoluyla taban sınıfın yalnızca public bölümündeki elemanlara erişebiliriz.
	3) Taban sınıfın private bölümü tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez.

	Burada taban sınıfın protected bölümüne kendi sınıfı dışında yalnızca türemiş sınıfın üye fonksiyonları tarafından erişilebildiğine dikkat ediniz.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo()
	{
		cout << "A::foo" << endl;
	}
protected:
	void bar()
	{
		cout << "A::bar" << endl;
	}
private:
	void tar()
	{
		cout << "A::tar" << endl;
	}
};

class B : public A {
public:
	void zar()
	{
		cout << "B::zar" << endl;
		foo();		// geçerli
		bar();		// geçerli
		// tar();		// error!
	}

protected:
	void car()
	{
		cout << "B::car" << endl;
	}
private:
	void mar()
	{
		cout << "mar" << endl;
	}
};

int main()
{
	B b;

	b.foo();		// geçerli
	b.zar();		// geçerli

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	protected türetmesinde taban sınıfın public ve protected bölümleri türemiş sınıfın protected bölümüymüş gibi işlem görmektedir. Taban sınıfın private bölümü 
	tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez. 

	protected türetmesinden çıkan sonuçlar şunlardır:

	1) Türemiş sınıfın üye fonksiyonu içerisinde biz taban sınıfın public ve protected bölümlerindeki elemanlara doğrudan erişebiliriz. 
	2) Dışarıdan türemiş sınıf nesnesi, göstericisi ya da referansı yoluyla taban sınıfının hiçbir bölümüne erişemeyiz.
	3) Taban sınıfın private bölümü tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez.

	public ve protected türetmesi arasındaki fark taban sınıfın public bölümüne dışarıdan türemiş sınıf nesnesi, gösterici ve referansı yoluyla erişilebilmesi ancak 
	protected türetmesinde erişilememesidir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo()
	{
		cout << "A::foo" << endl;
	}
protected:
	void bar()
	{
		cout << "A::bar" << endl;
	}
private:
	void tar()
	{
		cout << "A::tar" << endl;
	}
};

class B : protected A {
public:
	void zar()
	{
		cout << "B::zar" << endl;
		foo();		// geçerli
		bar();		// geçerli
		// tar();	// error!
	}

protected:
	void car()
	{
		cout << "B::car" << endl;
	}
private:
	void mar()
	{
		cout << "mar" << endl;
	}
};

int main()
{
	B b;

	// b.foo();		// error!
	b.zar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	private türetmesinde taban sınıfın public ve protected bölümleri türemiş sınııfn private bölümüymüş gibi işlem görmektedir. 

	private türetmesinden çıkan sonuçlar sanki protected türetmesinden çıkan sonuçlarla aynı gibidir:

	1) Türemiş sınıfın üye fonksiyonu içerisinde biz taban sınıfın public ve protected bölümlerindeki elemanlara doğrudan erişebiliriz. 
	2) Dışarıdan türemiş sınıf nesnesi, göstericisi ya da referansı yoluyla taban sınıfının hiçbir bölümüne erişemeyiz.
	3) Taban sınıfın private bölümü tam olarak korunmuştur. Türemiş sınıf tarafından erişilemez.

	Her ne kadar protected türetmesiyle private türetmesinden çıkan sonuçlar aynı gibi gözküyorsa da bir dizi türetme yapıldığında arada farklılıklar oluşabilmektedir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir dizi türetme yapıldığında yukarıdaki kurallar geçişli biçimde devam etmektedir. Aşağıdaki gibi bir türetme şeması olsun:

	class A {
		//...
	};

	class B : public A {
		//...
	};

	class C : public B {
		//...
	};

	Burada C sınıfının bir üye fonksiyonu içerisinde biz hem A2nın public ve protected elemanlarını hem de B2nin public ve protected elemanlarını doğrudan
	kullanabiliriz. Yine dışarıdan C nesnesi, göstericisi ya da referansı tyoluyla hem A'nın hem B2nin hem de C'nin public elemanlarına erişebiliriz. 

	Şimdi B sınıfı A'dan private türetilmiş olsun:

	class A {
		//...
	};

	class B : private A {
		//...
	};

	class C : public B {
		//...
	};

	Burada biz artık C'nin üye fonksiyonları içerisinde A'nın public ve protected elemanlaırnı kullanamayız. Şimdi B sınıfı A'dan protected türetilmiş olsun:

	class A {
		//...
	};

	class B : protected A {
		//...
	};

	class C : public B {
		//...
	}; 

	Biz burada artık C2nin üye fonksiyonları içerisinde A'nın ve B'nin public ve protected bölümlerindeki elemanları doğrudan kullanabiliriz. 
	Görüldüğü gibi protected ve private türetmesi arasında bu tür durumlarda semantik farklılık oluşmaktadır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Tüm bunların ışığı altına sınıfların protected bölümleri için şunlar şöylenebilir: Sınıfın protected bölümü türemiş sınıfların üye fonksiyonları tarafından 
	doğrudan kullanılabilen ancak dışaıdan kullanılamayan bölümüdür. Biz bir elemanı protected bölüme neden yerleştiririz? İşte bizim yazdığımız sınıftan bir türetme
	yapılabileceğini öngörüp türemiş sınıfı yazanlara erişim kolaylığı sağlamak için bazı elemanları protected bölüme yerleştirebilriz. Ancak sınıfın protected 
	bölümünde bir değişiklik yapıldığında yalnızca o sınıfın içinin değil tüm türemiş sınıfların içlerinin yeniden yazılması gerekir. Bu nedenle bazı teorisyenler
	protected bölümün hiç kullanılmaması gerektiğini de düşünmektedir. Tabii bir sınıfta public bölüm gibi protected bölümün de dokümantasyonu yapılmalıdır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıfın "taban sınıfları (base classes)" denildiği zaman yukarıya doğru onun bütün taban sınıfları anlaşılır. Bir sınıfın "doğruan taban sınıfları (direct base class)"
	denildiğinde ise o sınıfın hemen bir yukarısındaki taban sınıfları anlaşılır. Bir sınıfın "dolaylı taban sınıfları (indirect base classes)" ise o sınıfın doğurdan 
	taban sınıflarının taban sınıfları anlaşılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta (Java ve C#'ta da böyle) türemiş sınıf türünden bir nesne yaratıldığında türemiş sınıfın uygun yapıcı fonksiyonu çağrılır. Ancak türemiş sınıfın yapıcı 
	fonksiyonu taban sınıfın private bölümüne erişemediğine göre onun taban sınıf elemanlarına ilkdeğer veremez. İşte bunu sağlamak için şöyle bir mekanizma
	bulundurulmuştur: Türemiş sınıfın yapıcı fonksiyonu türemiş sınıfın taban sınıf kısmı için taban sınıfın yapıcı fonksiyonunu çağırmaktadır. Böylece nesnenin taban 
	sınıf kısmı taban sınıfın yapıcı fonksiyonu ile ilkdeğerlenmiş olur. Türemiş sınıfın yapıcı fonksiyonunun taban sınıfın yapıcı fonksiyonunu çağırması 
	türemiş sınıfın yapıcı fonksiyonun ana bloğunun başında derleyicinin yerleştirdiği gizli bir çağırma kodu yoluyla yapılmaktadır. Böylece önce taban sınıf yapıcı 
	fonksiyonu sonra türemiş sınıf yapıcı fonksiyonu çalıştırılmış olur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	//...
};

class B : public A {
public:
	B();
	//...
};

A::A()
{
	cout << "A constructor" << endl;
}

B::B()
{
	cout << "B constructor" << endl;
}

int main()
{
	B b;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir dizi türetme olduğu durumda her sınıfın yapıcı fonksiyonu kendi sınıfının doğrudan taban sınıfının yapıcı fonksiyonunu çağırmaktadır. Böylece
	aslında yapıcı fonksiyonlar yukarıdan aşağıya doğru çalıştırılmış olmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	//...
};

class B : public A {
public:
	B();
	//...
};

class C : public B {
public:
	C();
	//...
};

A::A()
{
	cout << "A constructor" << endl;
}

B::B()
{
	cout << "B constructor" << endl;
}

C::C()
{
	cout << "C constructor" << endl;
}

int main()
{
	C c;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi taban sınıfın birden fazla yapıcı fonksiyonu varsa nesnenin taban sınıf parçası için taban sınıfın hangi yapıcı fonksiyonu çağrılacaktır? İşte bu durum
	daha önce görmüş olduğumuz MIL sentaksıyla belirlenmektedir. MIL sentaksında ':' atomundan sonra taban sınıfın ismi belirtilerek bir argüman listesi 
	girilirse o argüman listesine uygun taban sınıfın yapıcı fonksiyonu çağrılmaktadır. Eğer MIL sentaksında bu biçimde taban sınıf ismi belirtilmediyse bu durumda
	nesnenin taban sınıf parçası için taban sınıfın default yapıcı fonksiyonu çağrılmaktadır. 

	Tabii biz türemiş sınıfın yapıcı fonksiyonunda MIL sentaksında o yapıcı fonksiyonun parametrelerini taban sınıf yapıcı fonksiyonu için argüman olarak kullanabiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	A(int x);
	
	int x() const { return m_x; }
private:
	int m_x;
};

class B : public A {
public:
	B();
	B(int x, int y);

	int y() const { return m_y; }
private:
	int m_y;
};

A::A()
{
	m_x = 0;
}

A::A(int a)
{
	m_x = a;
}

B::B()
{
	m_y = 0;
}

B::B(int x, int y) : A(x)
{
	m_y = y;
}

int main()
{
	B b1;

	cout << b1.x() << endl;		// 0
	cout << b1.y() << endl;		// 0

	B b2(10, 20);

	cout << b1.x() << endl;		// 10
	cout << b1.y() << endl;		// 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta her zaman yapıcı fonksiyonlarla yıkıcı fonksiyonlar ters sırada çalıştırılmaktadır. Bu durumda türemiş sınıfın yıkıcı fonksiyonunun ana bloğunun 
	sonunda derleyici tarafından yerleştirilen gizli bir çağırma kodu yoluyla taban sınıfın yıkıcı fonksiyonu çağrılmaktadır. Yani önce türemiş sınıfın sonra taban 
	sınıfın yıkıcı fonksiyonları çalıştırılmış olmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	A();
	~A();
	//...
};

class B : public A {
public:
	B();
	~B();
	//...
};

A::A()
{
	cout << "A constructor" << endl;
}

A::~A() 
{
	cout << "A destructor" << endl;
}

B::B() 
{
	cout << "B constructor" << endl;
}

B::~B() 
{
	cout << "B destructor" << endl;
}

int main()
{
	cout << "main begins..." << endl;
	{
		B b;

		cout << "continues..." << endl;
	}

	cout << "main ends..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir sınıf hem başka bir sınıftan türetilmiş olsun hem de sınıfın başka sınıf türünden bir veri elemanı bulunyor olsun. Bu durumda yapıcı ve yıkıcı fonksiyonların
	çağrılma sıraları nasıl olacaktır? İşte her zaman önce taban sınıfın yapıcı fonksiyonu çalıştırılır, sonra elemanlara ilişkin sınıfların yapıcı fonksiyonu çalıştırılır 
	sonra da türemiş sınıfın yapıcı fonksiyonu çalıştırılır.  Tabii yıkıcı fonksiyonların çağrılma sırası ters biçimde olacaktır.

	C++'ta hiçbir zaman MIL sentaksındaki sıranın bir önemi yoktur. Yani örneğin biz MIL sentaksında önce eleman için belitim yapsak bile yine taban sınıfın 
	yapıcı fonksiyonu önce çağrılacaktır. Daha önceden de elemanlar için yapıcı fonksiyonların bildirimdeki sıraya göre çağrıldığını görmüştük.

	Aşağıdaki örnekte B sınıfı A sınıfından türetilmiştir ve X sınıfı türünden bir veri elemanına sahiptir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class X {
public:
	X();
	~X();
	//...

};

class A {
public:
	A();
	~A();
	//...
};

class B : public A {
public:
	B();
	~B();
	//...
private:
	X m_x;
	int m_y;
};

X::X()
{
	cout << "X constructor" << endl;
}

X::~X()
{
	cout << "X destructor" << endl;
}

A::A()
{
	cout << "A constructor" << endl;
}

A::~A()
{
	cout << "A destructor" << endl;
}

B::B() : m_x(), A()		// MIL sentaksındaki sıranın hiçbir önemi yok! Yine önce A için yapıcı fonksiyon çağrılır
{
	cout << "B constructor" << endl;
}

B::~B()
{
	cout << "B destructor" << endl;
}

int main()
{
	B b;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çoklu türetme durumunda sınıfın doğrudan taban sınıfı birden fazla olabilmektedir. Bu durumda taban sınıfların yapıcı fonksiyonlarının çağrılma sıraları 
	bildirimdeki sıraya göredir. MIL sentaksındaki sıranın bir önemi yoktur. Yine MIL sentaksında belirtilmeyen sınıflar için o sınıfların default yapıcı fonksiyonlarında çağrılmaktadır. 
	Tabii yıkıcı fonksiyonlar yine ters sırada çağrılırlar. Örneğin:

	class A {
		//...
	};

	class B {
		//...
	};

	class C : public A, public B {
		//...
	};

	Burada C'nin yapıcı fonksiyonu şöyle yazılmış olsun:

	C::C(...) : B(...)
	{
		//...
	}

	Burada MIL sentaksında A taban sınıfı belirtilmemiştir. Ancak yine derleyici önce A için default yapıcı fonksiyonu sonra B için belirtilen yapıcı 
	fonksiyonu çağırır.

	Sınıfın temel türlerine ilişkin veri elemanları için de MIL sentaksında ilkdeğer verilebildiğini görmüştük. Bunlar da tamamen sınıfın başka sınıf türünden 
	veri elemanlarıyla aynı hakka sahip olarak bildirimdeki sıraya göre ilkdeğer alırlar. Örneğin C sınıfı şöyle olsun:

	class C : public A, public B {
	public:
		//...
	private:
		int m_x;
		Y m_y;
	};

	C::C(...) : m_y(...), m_x(...), B(...)
	{
		//...
	}

	Burada önce A için default yapıcı fonksiyon çağrılır. Sonra B için belirtilen yapıcı fonksiyon çağrılır. Sonra X için ilkdeğerleme yapılır, sonra
	m_y için Y sınıfının uygun yapıcı fonksiyonu çağrılır. Tabii yıkıcı fonksiyonlar her zaman ters sırada çağrılacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir göstericiye (void gösterici dışında) farklı türden bir adres bilgisini doğrudan atayamayız. Ancak C++'ta istisna olarak türemiş sınıf türünden bir adres
	taban sınıf türünden bir göstericiye doğrudan atanabilmektedir. Yani türemiş sınıf adresleri taban sınıf adreslerine doğrudan dönüştürülebilmektedir. Örneğin,
	B sınıfı A sınıfından türetilmiş olsun:

	A *pA;
	B b;

	pA = &b;		// geçerli

	Türemiş sınıf nesnesinin adresinin taban sınıf türünden bir göstericiye atanması sonrasında artık taban sınıf türünden gösterici türemiş sınıf nesnesinin
	taban sınıf kısmını gösteriyor durumda olur. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	int m_a;
};

class B : public A {
public:
	int m_b;
};

int main()
{
	B b;
	A *pA;

	b.m_a = 10;
	b.m_b = 20;

	pA = &b;
	cout << pA->m_a << endl;					// 10

	pA->m_a = 30;

	cout << b.m_a << ", " << b.m_b << endl;		// 30, 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki işlemin tersi geçerli değildir. Yani biz taban sınıf türünden bir nesnenin adresini türemiş sınıf türünden bir göstericiye doğrudan atayamayız.
	Eğer böyle bir şey mümkün olsaydı türemiş sınıf göstericisi yoluyla biz aslında var olmayan elemanlara erişebilirdik. Bu da tanımsız davranışa yol açardı.
	Türemiş sınıf türünden nesnenin adresini taban sınıf türünden göstericiye atayabiliyor olmamız türemiş sınıf nesnesinin taban sınıfı kapsamasından kaynaklanmaktadır.
	Halbuki taban sınıf nesnesi türemiş sınıf nesnesini kapsamamaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir dizi türetme söz konusu olduğunda türemiş sınıf nesnesinin adresi o türemiş sınıfın büütn taban sınıfları türünden göstericilere atanabilmektedir. Örneğin
	C sınıfı B sınıfından B sınıfı da A sınıfından türetilmiş olsun:

	A
	B
	C

	Biz burada C sınıfı türünden bir nesnenin adresini A sınıfı türünden ya da B sınıfı türünden bir göstericiye atayabiliriz. Yani türemiş sınıf adreslerinden 
	o sınıfın tüm taban sınıflarının adreslerine otomatik (implicit) tür dönüştürmesi vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Referanslar da bir çeşit gösterici olduğuna göre türemiş sınıftan taban sınıfa adres dönüştürmeleri referanslar yoluyla da yapılabilmektedir. Yani taban sınıf
	türünden bir referans türemiş sınıf türünden bir nesne ile ilkdeğer verilerek tanımlanabilir. Bu durumda taban sınıf türünden referans türemiş sınıf nesnesinin
	yine taban kısmının adresini tutacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	int m_a;
};

class B : public A {
public:
	int m_b;
};

int main()
{
	B b;

	b.m_a = 10;
	b.m_b = 20;

	A &r = b;

	cout << r.m_a << endl;						// 10

	r.m_a = 30;

	cout << b.m_a << ", " << b.m_b << endl;		// 30, 20

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf nesnesinin adresinin taban sınıf türünden bir göstericiye ya da referansa atanması bir türetme şeması üzerinde genel işlemleri yapabilen fonksiyonların
	yazılmasını mümkün hale getirmektedir. Aşağıdaki gibi bir türetme şeması olsun:

                           Employee
              Worker        Manager        SalesPerson
			               Executive


	Burada her sınıf aslında Employee sınıfından türetilmiştir. Aşağıdaki gibi bir fonksiyon olsun:

	void disp_employee(const Employee &e);

	Biz bu fonksiyon ile çalışan kişi kim olursa olsun onun temel bilgilerini display edebiliriz. Çünkü bu temel bilgiler zaten Employee sınıfı içerisindedir ve
	her türemiş sınıfın aslında bir Employee kısmı vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// employee.hpp

#ifndef EMPLOYEE_HPP_
#define EMPLOYEE_HPP_

#include <string>

class Employee {
public:
	Employee(const char *name, const char *address, int no);
	
	std::string name() const { return m_name; }
	std::string address() const { return m_address; }
	int no() const { return m_no; }

private:
	std::string m_name;
	std::string m_address;
	int m_no;
};

#endif

// employee.cpp

#include "employee.hpp"

Employee::Employee(const char *name, const char *address, int no)
	: m_name(name), m_address(address), m_no(no)
{
	//...
}

// worker.hpp

#ifndef WORKER_HPP_
#define WORKER_HPP_

#include "employee.hpp"

enum class Shift {
	Morning, Noon, Even
};

class Worker : public Employee {
public:
	Worker(const char *name, const char *address, int no, Shift shift, int overtime);
private:
	Shift m_shift;
	int m_overtime;
};

#endif

// worker.cpp

#include "worker.hpp"

Worker::Worker(const char *name, const char *address, int no, Shift shift, int overtime)
	: Employee(name, address, no)
{
	m_shift = shift;
	m_overtime = overtime;
}

// manager.hpp

#ifndef MANAGER_HPP_
#define MANAGER_HPP_

#include <string>
#include "employee.hpp"

class Manager : public Employee {
public:
	Manager(const char *name, const char *address, int no, const char *department);
	//...
private:
	std::string m_department;
};

#endif

// manager.cpp

#include "manager.hpp"

Manager::Manager(const char *name, const char *address, int no, const char *department)
	: Employee(name, address, no), m_department(department)
{}

// app.cpp

#include <iostream>
#include "employee.hpp"
#include "worker.hpp"
#include "manager.hpp"

using namespace std;


void disp_employee(const Employee &e)
{
	cout << e.name() << ", " << e.address() << ", " << e.no() << endl;
}

int main()
{
	Worker w("Kaan Aslan", "Atasehir", 567, Shift::Morning, 2);
	Manager m("Necati Ergin", "Mecidiyekoy", 678, "Uretim");

	disp_employee(w);
	disp_employee(m);
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf nesnesinin adresini taban sınıf türünden gösterici ya da referansa atayabilmemiz için türetme biçiminin "public türetmesi" olması gerekir. 
	Zaten en fazla kullanılan türetme biçiminin "public türetmesi" olduğunu anımsayınız. Örneğin:

	class A {
		//...
	};

	class B : protected A {
		//...
	};

	B b;
	A *pa = &b;		// error!

	Eğer böyle bir şeye izin verilseydi o zaman b yoluyla A'nın public bölümüne erişemediğimiz halde bu yolla erişebilir duruma gelirdik.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta derleyici bir isimle karşılaştığında o ismin bir bildirimini bulmak zorundadır. Bir isme ilişkin bildirimin bulunması sürecine standartlarda 
	"isim araması (name lookup)" denilmektedir. İsim araması ikiye ayrılmaktadır:

	1) Niteliksiz isim araması (unqualified name lookup)
	2) Nitelikli isim araması (qualified name lookup)

	Düz yazılan yani ".", "->" ve "::" opereatörü olmadan yazılan isimlerin aranması niteliksiz arama kurallarına göre yapılır. Ancak nokta operatörünün, 
	ok operatörünün ve :: operatörünün sol tarafındak isimlerin aranması niteliksiz, sağ tarafındaki isimlerin aranması nitelikli isim arama kuralına göre yapılmaktadır. İsim araması sırasıyla bazı faaliyet alanlarına sırasıyla bakılarak yapılır. 
	İsim sırasıyla çeşitli faaliyet alanlarınd aranır. İsim bulunursa arama devam ettirilmez. İsim bulunmazsa error oluşur. 

	Niteliksiz isimlerin aranması aşağıdaki sırada yapılmaktadır.

	1) İsim bir fonksiyon içerisinde kullanılmışsa derleyici ismi önce kullanım yerinden yukarıya doğru fonksiyonun yerel blokları içerisinde içten dışa doğru arar. 
	2) İsim bir üye fonksiyonun içerisinde kullanılmışsa o üye fonksiyonun ilişkin olduğu sınıf bildiriminin  her yerinde aranır (fonksiyon inline olarak sınıf içerisinde
	yazılmış olsa da sınıf bildiriminin her yerine bakılır.)
	3) İsim üye fonksiyonun ilişkin olduğu sınıfın taban sınıflarında aşağıdan yukarıya doğru onların sınıf bildirimlerinin her yerinde aranır. Eğer çoklu türetme 
	söz konusuysa ismin taban sınıf kollarından yalnızca birinde bulunuyor olması gerekir. Eğer farklı kollarda isim bulunursa bu durum error oluşturur. İsmin farklı kollardaki bulunduğu düzeyin 
	bir önemi yoktur. Yani çoklu türetmede arama kollarda herhangi bir sırada yapılmamaktadır. Başka bir deyişle bir kolun diğer kola herhangi bir üstünlüğü yoktur.
	4) İsim kullanıldığı fonksiyonun içinde bulunduğu isim alanı içerisinde kullanım yerinden yukarıdaki bölgede aranır.
	5) İsim kullanıldığı isim alanını kapsayan isim alanlarında içten dışa doğru kullanım yerinden yukarıdaki bölgede aranır.
	6) İsim nihayet global isim alanında kullanım yerinden yukarıdaki bölgede aranır.

	C++'ta her zaman önce isim araması yapılır. Sonra erişim kontrolü uygulanır. Yani arama erişilebilen isimler arasında yapılmaz. 

	C++'ta (Java ve C# gibi dillerde böyle değil) bir isim bir sınıfta bulunursa artık isim araması bitirilir. Dolayısıyla bulunan isim bir fonksiyon ismi 
	ise overload resolution işlemine aday fonksiyon olarak ismin bulunduğu sınıftaki aynı isimli fonksiyonlar sokulur. Taban sınıftaki fonksiyonlar artık
	overload resolution işlemine sokulmaz. Yani C++'ta "overload resolution" işlemi yalnızca aynı faaliyet alanındaki fonksiyonlar arasında yapılmaktadır. 

	Yukarıda belirttiğimiz gibi ".", "->" ve "::" operatörlerinin sağ tarafındaki isimler "nitelikli isim araması" kurallarına göre aranmaktadır. Nitelikli isim araması
	aşağıdaki sırada yapılmaktadır:

	1) Nokta ya da ok operatörünün sağındaki isimler solundaki nesne ya da gösterici hangi sınıf türündense o sınıf bildirimi içerisinde sınıf bildiriminin her 
	yerinde aranır. Eğer isim o sınıfta bulunamazsa aşağıdan yukarıya doğru isim o sınıfın taban sınıflarında onların bildirimlerinin her yerinde sırasıyla aranır.
	Ayrıca kapsayan isim alanlarında herhangi bir arama yapılmaz.  
	2) :: operatörünün sağındaki isimler eğer bu operatörün solunda bir isim alanı varsa yalnızca o isim alanında kullanım yerinden yukarıdaki bölgede aranır.
	Kapsayan isim alanlarına bakılmaz. Eğer :: operatörünün solunda bir sınıf ismi varsa isim o sınıf bildiriminde aranır, bulunamazsa taban sınıfların bildirimlerinde de 
	aşağıdan yukarıya doğru aranır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public: 
	void foo(double a)
	{
		cout << "A::foo double" << endl;
	}
	void foo(const char *name)
	{
		cout << "A::foo const char *" << endl;
	}
};

class B : public A {
public:
	void foo(int a)
	{
		cout << "B::foo int" << endl;
	}
	void bar()
	{
		foo(10.2);		// dikkat isim isim bulununca artık taban sınıflara bakılmaz!
		foo("ali");		// error! isim bulunuca artık taban sınıflara bakılmazm!
	}
};

int main()
{
	B b;

	b.bar();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Taban sınıf ile türemiş sınıfta aynı isimi elemanların bulunduğu durumda isim arama kurallarına göre önce türemiş sınıftaki elemanlara bulunamazsa aşağıdan
	yukarıya doğru taban sınıftaki elemamlara bakılmaktadır. Bu tür durumlarda taban sınıftaki elemanlarına taban sınıf ismi ve çözünürlük operatörü ile erişilebilir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo()
	{
		cout << "A::foo" << endl;
	}
};

class B : public A {
public:
	void foo()
	{
		cout << "B::foo" << endl;
	}
};

int main()
{
	B b;

	b.foo();		// B::foo

	b.A::foo();		// A::foo

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    NYPT'de çokbiçimlilik biyolojiden aktarılmış bir kavramdır. Biyolojide çokbiçimlilik "bir canlının çeşitli doku ve organlarının temel işlevleri aynı kalmak üzere
	onların yaşam koşullarına göre farklılaşması" anlamına gelmektedir. Örneğin "kulak" pek çok canlıda vardır. Temel işlevi duymaktır. Ancak her canlının kulağı az çok 
	diğer canlılardan farklılıklar göstermektedir. 

	Pek çok teorisyene göre bir dilin nesne yönelimli olması için "sınıf", "türetme" dışında çokbiçimliliğe de sahip olması gerekmektedir. Eğer bir dilde sınıf varsa, türetme varsa
	ama çokbiçimlilik yoksa bu dillere "nesne yönelimli (object oriented)" değil "nesne tabanlı (object based)" diller denilmektedir. 
	
	Çokbiçimlilik (polymorphism) NYPT'nin en önemli anahtar kavramlarından biridir. Çeşitli bakış açılarına göre çeşitli biçimlerde tanımlanabilir:

	1) Çokbiçimlilik türden bağımsız kod paraçalarının oluşturulması için kullanılan bir tekniktir. (Yazılım mühendisliği tanımı)
	2) Çokbiçimlilik taban sınııfn belli bir fonksiyonunun türemiş sınıflar tarafından onlara özgü bir biçimde gerçekleştirilmesidir. (Biyolojik tanım)
	3) Çokbiçimlilik önceden yazılmış kodların sonradan yazılmış kodları çağırabilmesi özelliğidir (Aşağı seviyeli tanım)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta çokbiçimlilik sanal fonksiyonlarla (virtual functions) gerçekleştirilmektedir. Yalnızca sınıfların static olmayan üye fonksiyonları sanal yapılabilmektedir. 
	Bir üye fonksiyonu sanal yapabilmek için üye fonksiyon bildiriminde "virtual" anahtar sözcüğünün kullanılması gerekir. virtual anahtar sözcüğü tanımlama sırasında
	kullanılamaz. Yalnızca bildirimde kullanılabnilir. Örneğin:

	class A {
	public:
		virtual void foo();		// sanal fonksiyon
		//...
	};

	void A::foo()				// tanımşama sırasında virtual anahtar sözcüğü kullanılmaz
	{
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Taban sınıftaki bir sanal fonksiyon türemiş sınıfta "aynı isimle, aynı parametrik yapıyla" ve "aynı geri dönüş değeri türü ile" bildirilirse bu duruma 
	"taban sınıftaki sanal fonksiyonun türemiş sınıfta "override" edilmesi denilmektedir. Taban sınıftaki sanal fonksiyon türemiş sınıfta farklı bir geri dönüş 
	değeri türü ile override edilemez. Taban sınıftaki sanal fonksiyon türemiş sınıfta farklı bir parametrik yapıyla da override edilemez. 

	Taban sınıftaki sanal fonksiyon türemiş sınıfta override edildiğinde override edilmiş olan bu fonksiyon da sanal kabul edilir. Bu fonksiyonun başına
	virtual yazılmasa bile yazılmış kabul edilir. Örneğin:

	class A {
	public:
		virtual void foo();
		//...
	};

	class B : public A {
	public:
		void foo();			// virtual yazılmış gibi etki gösterir		
		//...
	};

	Taban sınıfta sanal olmayan bir fonksiyon türemiş sınıfta aynı biçimde yeniden tanımlanırsa bu bir override işlemi değildir. Override terimi sanal fonksiyonlar
	için kullanılır. Örneğin:

	class A {
	public:
		void foo();
		//...
	};

	class B : public A {
	public:
		void foo();			// bu bir override işlemi değil!
		//...
	};

	Taban sınıftaki sanal fonksiyon yanlışlıkla türemiş sınıfta farklı bir parametrik yapıyla (const'luk da dahil olmak üzere) yazılırsa bu durum override anlamına 
	gelmez. Bu konuda dikkat etmek gerekir. Örneğin:

	class A {
	public:
		virtual void foo() const;
		virtual void bar(int a);
		virtual void tar(int a);
		//...
	};

	class B : public A {
	public:
		void foo();			// geçerli ancak bu bir override işlemi değil! çünkü const'luk belirtilmemiş
		void bar();			// geçerli ancak bu bir override işlemi değil! parametrik yapılar farklı
		int tar(int a);		// geçersiz! aynı parametrik yapıyla farklı geri dönüş değeri türüyle override işlemi yapılamaz
		//...
	};

	Override işlemi bir dizi türetmede devam ettirilebilir. Örneğin:

	class A {
	public:
		virtual void foo();
		//...
	};

	class B : public A {
	public:
		void foo();			// virtual yazılmış gibi etki gösterir		
		//...
	};

	class C : public {
	public:
		void foo();			// override işlemi yapılmış, virtual yazılmış gibi işlem görür
	};

	Tabii sanallık daha sonra da başlatılabilir. Örneğin:

	class A {
	public:
		void foo();		// sanal değil
		//...
	};

	class B : public A {
	public:
		virtual void foo();				
		//...
	};

	class C : public {
	public:
		void foo();			// override işlemi yapılmış, virtual yazılmış gibi işlem görür
	};

	Override işlemi için sanal fonksiyonun doğrudan taban sınıfta olması gerekmemektedir. Yani sınııfn doğurdan taban sınıfında değil dolaylı taban sınıflarında 
	sanal yapılmış bir fonksiyon da overrde edilebilir. Örneğin:

	class A {
	public:
		virtual void foo();
	};

	class B : public A {
	public:
		void foo(int a);		// override işlemi değil
	};

	class C : public B {
	public:
		void foo();				// geçerli override işlemi 
	};

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden gösterici ya da referansın "statik" ve "dinamik" türü vardır. Sınıf türünden olmayan değişkenlerin yalnızca statik türleri vardır.
	Bir sınıf türünden gösterici ya da referansın statik türü bildirimde belirtilen türüdür. Dinamik türü ise o gösterici ya da referans bir nesneyi gösteriyorken 
	eğer aslında başka bir nesnenin türemiş sınıf parçasını gösteriyorsa gösterdiği nesnenin bütününün türüne o gösterici ya da referansın dinamik türü denilmektedir. 
	Gösterici ya da referansların statik türleriyle dinamik türlerinin farklılaşması türemiş sınıf nesnesinin adresinin taban sınıf türünden bir gösterici ya da 
	referansa atanmasıyla olur. Aşağıdaki gibi bir türetme şeması olsun:

	A
	B
	C

	C c;
	A *pA;

	pA = &c;

	Burada pA göstericisinin statik türü A'dır. Ancak dinamik trü C'dir. Çünkü pA aslında bütünü C olan bir nesnenin A parçasını göstermektedir. Örneğin:

	B *pB;

	pB = &c;

	Burada pB'nin statik türü B'dir. Ancak dinamik türü C'dir. Aynı durum referanslar için de söz konusudur. Örneğin:

	C c;
	B &b = c;

	Burada b referansının statik türü B, dinamik türü C'dir. Örneğin:

	C *pC;

	pC = &c;

	Burada pC göstericisinin statik türü ile dinamik türü aynıdır ve C'dir. 

	Statik tür değişmez. Ancak dinamik tür değişebilir. Örneğin:

	A
	B
	C

	C c;
	B b;
	A a;
	A *pA;

	pA = &c;		// pA'nın statik türü A, dinamik türü C
	//...
	pA = &b;		// pA'nın statik türü A, dinamik türü B
	//...
	pA = &a;		// pA'nın statik türü A, dinamik türü A

	Örneğin:

	void foo(A &r)
	{
		//...
	}
	//...
	C c;
	B b;
	A a;

	foo(c);			// r referansının dinamik türü A
	foo(b);			// r referansının dinamik türü A
	foo(a);			// r referansının dinamik türü A

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çokbiçimli (polymophic) mekanizma şöyledir: Bir sınıf türünden gösterici ya da referans ile o sınıfın bir üye fonksiyonu çağrılmış olsun. Bu üye fonksiyon 
	isim araması kuralına göre gösterici ya da referansın statik türüne ilişkin sınıfta aranır (tabii o sınıfta bulunamazsa taban sınıflara da bakılır). Sonra bulunan 
	fonksiyonun sanal olup olmadığına bakılır. Eğer bulunan fonksiyon sanal değilse bulunan fonksiyon çağrılır. Eğer bulunan fonksiyon sanal ise o fonksiyonun 
	çağrılmasında kullanılan gösterici ya da referansın dinamik türüne ilişkin override edilmiş sanal fonksiyon çağrılır. Eğer gösterici ya da referansın dinamik türüne 
	ilişkin sınıfta ilgili sanal fonksiyon override edilmemişse yukarıya doğru o sanal fonksiyonun override edilmiş olduğu ilk taban sınıfın sanal fonksiyonu çağrılır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	void foo();
	virtual void bar();
};

class B : public A {
public:
	void foo();		// override işlemi değil
	void bar();		// override işlemi
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void A::bar()
{
	cout << "A::bar" << endl;
}

void B::foo()
{
	cout << "B::foo" << endl;
}

void B::bar()
{
	cout << "B::bar" << endl;
}

int main()
{
	B b;
	A *pA;

	pA = &b;

	pA->foo();		// A::foo() çağrılır, çünkü foo sanal değil
	pA->bar();		// B::bar çağrlır, çünkü bar sanal

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte referansın dinamik türüne ilişkin sınıfta fonksiyon override edilmemiştir. Bu durumda yukarıya doğru fonksiyonun override edildiği ilk taban sınıfın
	fonksiyonu çağrılacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	virtual void foo();
	//...
};

class B : public A {
public:
	void foo();		// override edilmiş
	//...
};

class C : public B {
	//...
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void B::foo()
{
	cout << "B::foo" << endl;
}

int main()
{
	C c;

	A &r = c;		// referansın statik türü A, dinamik türü C

	r.foo();		// B::foo çağrılır, çünkü C'de foo override edilmemiş	

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte test fonksiyonun parametresi taban sınıf türünden bir göstericidir. Bu test fonksiyonu türemiş sınıf türünden nesnelerin adresleriyle çağrılmıştır.
	Çokbiçimli mekanizma gereği dinamik türe ilişkin sınıfların override edilmiş üye fonksiyonlarının çağrıldığına dikkat ediniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	virtual void foo();
	//...
};

class B : public A {
public:
	void foo();		// override edilmiş
	//...
};

class C : public B {
public:
	void foo();
};

void A::foo()
{
	cout << "A::foo" << endl;
}

void B::foo()
{
	cout << "B::foo" << endl;
}

void C::foo()
{
	cout << "C::foo" << endl;
}

void test(A *pA)
{
	pA->foo();
}

int main()
{
	A a;
	B b;
	C c;

	test(&a);
	test(&b);
	test(&c);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Nesne yönelimli teknikte ideal olarak kod üzerinde değişiklikler yapılmaz. Her zaman ekleme yöntemi uygulanır. Daha önceki kod sağlam çalışıyorsa ve ekleme işleminden 
	sonra problem oluşmuşsa problem eklenen kısımla ilgilidir. Bu durumda eklenen kısmın test edilmesi yeterlidir. Halbuki biz kodda bir değişiklik yaparsak
	tüm kodun yeniden test edilmesi gerekir. Çünkü yaptığımız değişiklik başka yerleri bozuyor olabilir. 

	İşte çokbiçimlilik türden bağımsız kod parçalarının ekleme yöntemiyle oluşturulması için kullanılan bir tekniktir. NYPT'de değişebilecek öğelere doğrudan değil 
	çokbiçimli olarak erişilir. Örneğin top ile oynanan bir oyun programında top değişebilir bir öğe olsun. Bu durumda biz top kavramını bir sınıfla temsil ederiz. 
	Oyunda "patlak topu", "zıplayan topu", "normal topu" bu top sınıfından türetme yaparak oluştururuz. Oyunda top genel bir kavram olarak Top sınıfıyla temsil edilir. 
	Ancak topun çeşiti eylemleri sanal fonksiyonlarla ifade edilir. Böylece bu top değiştiğinde artık kodda değişiklik yapılması gerekmez.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Top {
public:
	virtual void git() {}
	//...
};

class NormalTop : public Top {
public:
	void git();
	//...
};

class PatlakTop : public Top {
public:
	void git();
	//...
};

class ZiplayanTop: public Top {
public:
	void git();
	//...
};

void NormalTop::git()
{
	cout << "Normal top gidiyor" << endl;
}

void PatlakTop::git()
{
	cout << "Patlak top gidiyor" << endl;
}

void ZiplayanTop::git()
{
	cout << "Zıplayantop gidiyor" << endl;
}

Top *top_sec(string isim)
{
	Top *top;

	if (isim == "normal")
		top = new NormalTop();
	else if (isim == "patlak")
		top = new PatlakTop();
	else if (isim == "ziplayan")
		top = new ZiplayanTop();
	else
		top = new Top();

	return top;
}

int main()
{
	Top *top;

	top = top_sec("patlak");
	//...

	top->git();
	//...
	top->git();
	//...
	top->git();
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programda oyuna yeni bir top cinsi ekleyecek olalım. Tek yapacağımız şey aslında bu yeni top sınıfını Top sınıfından türetmek ve sanal fonksiyonları 
	bu sınıfta override etmektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Top {
public:
	virtual void git() {}
	//...
};

class NormalTop : public Top {
public:
	void git();
	//...
};

class PatlakTop : public Top {
public:
	void git();
	//...
};

class ZiplayanTop: public Top {
public:
	void git();
	//...
};

class HafifTop : public Top {
	void git();
	//...
};

void NormalTop::git()
{
	cout << "Normal top gidiyor" << endl;
}

void PatlakTop::git()
{
	cout << "Patlak top gidiyor" << endl;
}

void ZiplayanTop::git()
{
	cout << "Zıplayan top gidiyor" << endl;
}

void HafifTop::git()
{
	cout << "Hafif top gidiyor" << endl;
}

Top *top_sec(string isim)
{
	Top *top;

	if (isim == "normal")
		top = new NormalTop();
	else if (isim == "patlak")
		top = new PatlakTop();
	else if (isim == "ziplayan")
		top = new ZiplayanTop();
	else if (isim == "hafif")
		top = new HafifTop();
	else
		top = new Top();

	return top;
}

int main()
{
	Top *top;

	top = top_sec("hafif");
	//...

	top->git();
	//...
	top->git();
	//...
	top->git();
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Taban sınıftaki birssanal fonksiyon bazen programcılar tarafından "override" edildi sanılmakta ancak programcı bu işlem sırasında parametre 
	türlerini yanlış yazdığı için aslında override işlemi yapılamamaktadır. İşte bu tür hataları engellemek için C++11 ile birlikte C++'a override anahtar sözcüğü 
	de eklenmiştir. Fonksiyonun parametre parantezinden sonra "override" anahtar sözcüğü yazılırsa bu durumda eğer taban sınıfta override edilecek bir sanal fonksiyon yoksa
	derleme aşamasında error oluşmaktadır. Örneğin:

	class A {
	public:
		virtual void foo(long a);
		//...
	};

	class B : public A {
	public:
		void foo(int a) override;		/* derleme sırasına error oluşacak */
		//...
	};

	Yine C++11 ile birlikte zaten Java ve C# gibi dillerde olan "final override" kavramı da C++'a eklenmiştir. Eğer fonksiyonun parametre parantezinden sonra "final" 
	anahtar sözcüğü getirilirse bu durumda o sanal fonksiyon artık daha fazla override edilemez. Edilmeye çalışılırsa derleme zamanı sırasında error oluşur. Örneğim:

	class A {
	public:
		virtual void foo(long a);
		//...
	};

	class B : public A {
	public:
		void foo(long a) override final;		// foo artık daha fazla override edilemez!
		//...
	};

	class C : public B {
	public:
		void foo(long a);		// compile time error!
		//...
	};

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Çokbiçimli uygulamalarda çoğu kez taban sınıf aslında türden bağımsız işlem yapmak için bulundurulmaktadır. Aslında o taban sınıf türünden bir nesne yaratılmamaktadır.
	İşte bu tür durumlarda taban sınıftaki sanal fonksiyonların boşuna gövdeye sahip olması gerekmez. Eğer taban sınıftaki sanal fonksiyonun gövdeye sahip olması istenmiyorsa
	fonksiyonun parametre parantezinden sonra "= 0" sentaksı kullanılır. Yalnızca sanal fonksiyonlarda bu sentaks kullanılabilmektedir. Bu tür fonksiyonlara C++'ta
	"saf sanal fonksiyonlar (pure virtual functions)" denilmektedir. En az bir saf sanal fonksiyona sahip olan sınıfa da "soyut sınıf (abstract class)" denir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

class A {
public:
	virtual void foo() = 0;		// pure virtual
	//...
};

class B : public A {
public:
	void foo()
	{
		cout << "B::foo" << endl;
	}
};

class C : public A {
public:
	void foo()
	{
		cout << "C::foo" << endl;
	}
};

class D : public A {
public:
	void foo()
	{
		cout << "D::foo" << endl;
	}
};

int main()
{
	vector<A *> v{new B(), new C(), new D(), new C()};

	for (A *pa : v)
		pa->foo();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Soyut sınıflar türünden nesneler yaratılmaz. Ancak göstericiler ve referanslar tanımlanabilir. Örneğin A bir soyut sınıf olsun B de bu soyut sınıftan türetilmiş
	soyut olmayan (somut (concrete) de diyebiliriz) bir sınıf olsun:

	A a;	// error! soyut sınıf türündne nesne yaratılamaz.
	A *pa;	// geçerli, soyut sınıf türünden gösterici yaratılabilir. 

	Bir soyut sııf türündne gösterici ya da referansa tipik olarak o sınıftan türetilmiş bir sınıf nesnesinin adresi atanabilir. Örneğin:

	A *pa;
	B b;

	pa = &b;		// geçerli
	A &r = b;		// geçerli

	pa->foo();		// B::foo çağrılır
	r.foo();		// B::foo çağrılır

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir soyut sınıftan türetme yapıldığında türemiş sınıfın taban soyut sınıftaki tüm saf sanal fonksiyonları override etmesi beklenir. Eğer türemiş sınıf taban 
	sınıftaki tüm saf sanal fonksiyonları override etmezse bu durumda tüemiş sınıf da soyut olur, türemiş sınıf türünden de nesneler yaratılmaz. Örneğin:

	class A {
	public:
		//...
		virtual void foo() = 0;
		virtual void bar() = 0;
		//...
	};

	Burada A soyut (abstract) bir sınıftır. A sınıfı türünden nesneler yaratamayız. Şimdi A sınıfından B sınıfını türetelim:

	class B : public A {
	public:
		//...
		void foo() override		// yalnızca foo override edilmiş olsun
		{
			//...
		}
		//...
	};

	Burada B sınıfında yalnızca foo override edildiği için B sınıfı da soyuttur ve B sınıfı türünden de nesneler yaratamayız. 

	A soyut sınıfındaki saf sanal fonksiyonların bir bölümü ondan türetilmiş B sınıfında override edilmiş olsun. Bu duurmda B de soyut bir sınıftır. Ancak geri 
	kalan saf sanal fonksiyonlar B'den türetilmiş  C override edilirse C artık soyut olmaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class A {
public:
	virtual void foo() = 0;
	virtual void bar() = 0;
	//...
};

class B : public A {
public:
	void foo() override 
	{
		//...
	}
	//...
};

class C : public B {
public:
	void bar() override
	{
		//...
	}
};

int main()
{
	A *pa = new C();		// geçerli, C soyut değil somut'
	//...

	delete pa;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Saf sanal fonksiyonların kullanılmasına yönelik Tetris örneğinin basit biimi aşağıdaki gibi olabilir. Bu örnekte taban Shape sınıfı "şekil kavramını"
	temsil etmektedir. Bu Shape sınıfından sınıflar türetilmiş ve sanal fonksiyonlar override edilmiştir. Shape sınıfı türünden hiçbir nesne yaratılmayacağı için
	Shape sınıfı soyut bir sınıf yapılmıştır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <ctime>
#include <cstdlib>
#include <Windows.h>
#include <conio.h>

using namespace std;

class Shape {
public:
	virtual void move_down() = 0;
	virtual void move_left() = 0;
	virtual void move_right() = 0;
	virtual void rotate() = 0;

private:
	//...
};

class BarShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class TShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class ZShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class SquareShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class LShape : public Shape {
public:
	void move_down() override;
	void move_left() override;
	void move_right() override;
	void rotate() override;
};

class Tetris {
public:
	Tetris();
	void run();
private:
	Shape *get_random_shape();		// static olabilir ancak henüz görmedik
	//...
};

void BarShape::move_down()
{
	cout << "Barshape move down" << endl;
}

void BarShape::move_left()
{
	cout << "Barshape move left" << endl;
}

void BarShape::move_right()
{
	cout << "Barshape move right" << endl;
}

void BarShape::rotate()
{
	cout << "Barshape rotate" << endl;
}

void TShape::move_down()
{
	cout << "TShape move down" << endl;
}

void TShape::move_left()
{
	cout << "TShape move left" << endl;
}

void TShape::move_right()
{
	cout << "TShape move right" << endl;
}

void TShape::rotate()
{
	cout << "TShape rotate" << endl;
}

void ZShape::move_down()
{
	cout << "ZShape move down" << endl;
}

void ZShape::move_left()
{
	cout << "ZShape move left" << endl;
}

void ZShape::move_right()
{
	cout << "ZShape move right" << endl;
}

void ZShape::rotate()
{
	cout << "ZShape rotate" << endl;
}

void SquareShape::move_down()
{
	cout << "SquareShape move down" << endl;
}

void SquareShape::move_left()
{
	cout << "SquareShape move left" << endl;
}

void SquareShape::move_right()
{
	cout << "SquareShape move right" << endl;
}

void SquareShape::rotate()
{
	cout << "SquareShape rotate" << endl;
}

void LShape::move_down()
{
	cout << "LShape move down" << endl;
}

void LShape::move_left()
{
	cout << "LShape move left" << endl;
}

void LShape::move_right()
{
	cout << "LShape move right" << endl;
}

void LShape::rotate()
{
	cout << "LShape rotate" << endl;
}

Tetris::Tetris()
{
	srand(time(NULL));
}

void Tetris::run()
{
	Shape *pshape;
	int ch;

	for (;;) {
		pshape = get_random_shape();
		for (int i = 0; i < 25; ++i) {
			pshape->move_down();
			Sleep(500);
			if (_kbhit()) {
				ch = _getch();
				switch (ch) {
					case 'a':				// move left
						pshape->move_left();
						break;
					case 'd':				// move right
						pshape->move_right();	
						break;
					case 's':				// rotate
						pshape->rotate();
						break;
					case 'q':
						goto EXIT;
				}
			}

		}
	}
EXIT:
	;
}

Shape *Tetris::get_random_shape()
{
	Shape *pshape;

	switch (rand() % 5) {
		case 0:
			pshape = new TShape();
			break;
		case 1:
			pshape = new ZShape();
			break;
		case 2:
			pshape = new SquareShape();
			break;
		case 3:
			pshape = new LShape();
			break;
		case 4:
			pshape = new BarShape();
			break;
	}

	return pshape;
}

int main()
{
	Tetris tetris;

	tetris.run();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aslında sınıf (class) ve üye fonksiyon (member function), veri elemanı (data member) gibi kavramlar yapay kavramlardır. İşlemcilerimiz prosedürel teknikte
	kodladığımız programları çalıştırmaya uygundur. Nesne yönelimli teknik yapay bir kavramdır. Gerçek makinenin çalışması C'deki gibidir. C++'taki gibi değildir. 
	Bu nedenle C++'ta bir sınıf aslında derlendiğinde C gibi kodlar üretilmektedir. Üye fonksiyonların sınıfın veri elemanlarına doğrudan erişmesi de makinede 
	mümkün değildir. Dolayısıyla sınıf faaliyet alanı da yapay bir kavramdır. Üye fonksiyonların sınıfın veri elemanlarına doğrudan erişmesi aslında derleyicilerin
	üye fonksiyonlara gizlice geçirdikleri bir parametre yoluyla sağlanmaktadır. Derleyiciler üye fonksiyonun çağrılmasında kullanılan nesnenin adresini üye fonksiyona
	gizlice (genellikle birinci parametre olarak) geçirirler ve veri elemanına erişmeyi bu gizli parametre yoluyla yaparlar. Bu gizlice geçirilen parametreye 
	this göstericisi denilmektedir. Aşağıdaki gibi bir sınıf söz konusu olsun:


	class Sample {
	public:
		void set_val(int val);
		void disp();
	private:
		int m_val;
	};

	void Sample::set_val(int val)
	{
		m_val = val;
	}

	void Sample::disp()
	{
		cout << m_val << endl;
	}

	int main()
	{
		Sample s;

		s.set_val(10);
		s.disp();

		return 0;
	}

	Aslında bu kod derlendiğinde makine kodları incelendiği zaman bu kodların tamamen C gibi ve aşağıdakine benzer olduğu görülür:

	#include <stdio.h>

	using namespace std;

	struct Sample {
		int m_val;
	};

	void Sample_set_val(struct Sample *this, int val)
	{
		this->m_val = val;
	}

	void Sample_disp(struct Sample *this)
	{
		printf("%d\n", this->m_val);
	}

	int main()
	{
		struct Sample s;

		Sample_set_val(&s, 10);
		Sample_disp(&s);

		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    this göstericisi üye fonksiyonlara gizlice geçiriliyor olsa da üye fonksiyon içerisinde açıkça kullanılabilir. this hangi sınıfın üye fonksiyonu içerisinde kullanılıyorsa
	o sınıf türünden bir gösterici belirtmektedir. Bir üye fonksiyon içerisinde sınıfın m_val gibi bir veri elamanına doğrudan m_val ismiyle erişmekle this->m_val 
	biçiminde erişmek arasında hiçbir performans farklılığı yoktur. Zaten programcı bu elemana m_val biçiminde eriştiğinde aslında derleyici ürettiği kodda buna
	this->m_val gibi erişmektedir. 

	foo gibi bir üye fonksiyon içerisinde bar üye fonksiyonun aşağıdaki gibi çağrıldığını düşünelim:

	void Sample::foo()
	{
		//...
		bar();
		//...
	}

	Aslında bu çağrı tamamen this->bar() gibi yapılmaktadır. Yani bar fonksiyonuna geçirelecek this göstericisi aslında foo fonksiyonun this göstericisidir. 

	void Sample::foo()
	{
		//...
		this->bar();		// bar(); ile eşdeğer
		//...
	}

	const bir üye fonksiyon aslında ona gizlice geçirilen this göstericisinin const olduğu (gösterdiği yer const olduğu) bir fonksiyondur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazen bir üye fonksiyonun geri dönüş değeri kendi sınıfı türünden bir sol taraf değeri referansı olur. Fonksion da *this ifadesiyle geri döner. Bu durumda *this
	üye fonksiyonun çağrıldığı nesnedir. Dolayısıyla fonksiyon da aslında bize bu nesneyi geri döndürür. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample &foo();
	void bar();
	//...
};

Sample &Sample::foo()
{
	cout << "Sample::foo" << endl;

	return *this;
}

void Sample::bar()
{
	cout << "Sample::bar" << endl;
}

int main()
{
	Sample s;

	s.foo().bar();		// s.foo(); s.bar(); ile eşdeğer etki

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aslında bir sınıfın üye fonksiyonları ve veri elemanları static olabilir ya da olmayabilir. Biz şimdiye kadar hep static olmayan (nonstatic)  üye fonksiyonlarını
	ve veri elemanlarını kullandık. Gerçekten de static üye fonksiyonlar ve veri elemanları seyrek kullanıldığı için "üye fonksiyon" denildiğinde özellikle static'lik 
	belirtilmediyse static olmayan üye fonksiyon anlaşılmalıdır. Benzer biçimde "veri elemanı" denildiğinde de özellikle static'lik belirtilmediyse static olmayan
	veri elemanı anlaşılmalıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazı global fonksiyonlar belli bir konuyla ilgili iş yapıyor olabilirler. Bu durumda o global fonskiyonların o konuya ilişkin sınıf ile ilişkilendirilmeleri 
	iyi bir tekniktir. Örneğin bir yılın artık yıl olup olmadığını belirleyen isleap isimli bir fonksiyon mantıksal ilgi nedeniyle Date sınıfın static bir üye fonksiyonu
	yapılmalıdır. static üye fonksiyonlar sınıfın veri elemanlarını kullanamazlar. Eğer sınıfın veri elemanlarını kullanmayan fonksiyonlar sınıfın static olmayan 
	bir üye fonksiyonu olarak yazılırsa bu durumda gereksiz biçimde onun bir nesne ile çağrılma zorunluluğu ortaya çıkar. Halbuki bu fonksiyonlar sınıfın veri elemanlarını zaten kullanmamaktadır.
	İşte bir üye fonksiyon static yapılırsa artık o üye fonksiyon bir nesne olmadan sınıf ismi ve :: operatörüyle (tabii public bölümdeyse) çağrılabilmektedir. Bir üye fonksyonu static yapabilmek için
	sınıf bildirimi içerisindeki prototipin önüne "static" anahtar sözcüğü getirilir. static anahtar sözcüğü tanımlamada kullanılamaz. Örneğin:

	class Sample {
	public:
		void foo();
		static void bar();
		//...
	};

	void Sample::foo()
	{
		//...
	}

	void Sample::bar()
	{
		//...
	}

	int main()
	{
		Sample::foo();		// nesne olmadan sınıf ismiyle çağırabiliriz

		return 0;
	}

	static üye fonksiyonlar nesne ile çağrılmadığı için onlara this parametresi geçirilmez. Dolayısıyla da static üye fonksiyonlar sınıfın static olmayan veri elemanlarını
	ve static olmayan üye fonksiyonlarını kullanamazlar. 

	Aslında static üye fonksiyonlar bir nesne, gösterici ya da referans yoluyla da çağrılabilirler. Bu çağrımada derleyici static üye fonksiyonun çağrıldığı 
	nesnenin türüne bakar ve üye fonksiyonun o sınıf ismi ile çağrıldığını kabul eder. Tabii bu durumda yine this göstericisi fonksiyona geçirilmemektedir. Örneğin:

	Sample::foo();

	Sample s;
	s.foo();		// tamamen Sample::foo() ile eşdeğer

	Sınıfın static üye fonksiyonları const üye fonksiyonlar yapılamaz. Zaten static üye fonksiyonlar sınııfn static olmayan veri elemanlarına erişemedikleri için 
	bunların const yapılmasının bir anlamı da yoktur. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp 

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date() = default;
	Date(int day, int month, int year);
	void disp() const;

	int day() const { return m_day; }
	void set_day(int day) {	m_day = day; }

	int month() const { return m_month; } 
	void set_month(int month) {	m_month = month; }

	int year() const { return m_year;	}
	void set_year(int year)	{ m_year = year; }

	static bool isleap(int year);
	static Date today();
private:
	int m_day;
	int m_month;
	int m_year;
};

#endif

// date.cpp

#include <iostream>
#include <ctime>
#include "date.hpp"

using namespace std;

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

bool Date::isleap(int year)
{
	return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

Date Date::today()
{
	Date result;

	time_t t = time(NULL);
	tm *pt = localtime(&t);

	result.m_day = pt->tm_mday;
	result.m_month = pt->tm_mon + 1;
	result.m_year = pt->tm_year + 1900;

	return result;
}

// app.cpp

#include <iostream>
#include "date.hpp"

using namespace std;

int main()
{
	Date date;

	cout << (Date::isleap(2000) ? "Artik" : "Artik degil") << endl;
	date = Date::today();

	date.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıfların static veri elamanlarının toplamda tek bir kopyası bulunur. static veri elemanları sınıf türünden nesnelerin içerisinde yer kaplamazlar. Yani nesnelerin
	bir parçası değillerdir. O sınıf türünden nesne yaratılsa da yaratılmasa da her zaman bu tek kopya yaratılmış bir biçimde bulunur. Sınıf içerisinde bu static
	veri elemanı kullanıldığında her zaman o tek olan kopya kullanılıyor durumdadır. Aslında sınıfın veri veri elemanaları pekala global bir nesne olabilecek durumdadır. 
	Ancak programcı onu global yapmak yerine sınıf ile mantıksal ilişkisi nedeniyle sınıfın içerisine yerleştirmiştir ve static yapmıştır. 

	Sınıfların static veri elemanları ismiyle de kullanılabilmektedir. Çünkü onlar aslında hiçbir nesnenin parçası değildir. 
	Veri elemanını static yapmak için sınıf bildiriminde static anahtar sözcüğü kullanılır. Ancak static veri elemanlarının sınıfın dışında  bir tanımlamasının 
	yapılması gerekir. Bu tanımlama sınıf ismi ve çözünürlük operatörü ile yapılır. Tanımlama sırasında static anahtar sözcüğü kullanılmaz ancak ilkdeğer verilebilir. Örneğin:

	class Sample {
	public:
		//...
		int m_a;
		int m_b;
		static int m_c;
	};

	int Sample::m_c;

	int main()
	{
		Sample::m_c = 10;

		cout << Sample::m_c << endl;

		return 0;
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#include <iostream>

using namespace std;

struct Sample {
	//...
	int m_a;
	int m_b;
	static int m_c;
};

int Sample::m_c;

int main()
{
	Sample::m_c = 10;

	cout << Sample::m_c << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Sınıfın static veri elemanlarının da private bölüme konularak onlara public getter/setter fonksiyonlar ile erişilmesi veri gizlemesi (data hidening) bakımından
	tavsiye edilmektedir. Tabii bu durumda getter/setter fonksiyonların static üye fonksiyon olması anlamlıdır. static üye fonksiyonlar sınıfın diğer static üye 
	fonksiyonlarını doğrudan çağırabilir ve sınıfın static veri elemanlarını doğrudan kullanabilir. Ancak static olmayan elemanlarını kullanamaz. 

	Sınıfın static veri elemanlarına yine o sınıf türünden nesne, gösterici ya da referans yoluyla erişebiliriz. Bu durumda erişimde kullanılan nesne aslında yalnızca
	sınıfın türünü belirtmektedir. Bu biçimde erişimler yanlış anlaşılmaya yol açabilmektedir. Bu nedenle static veri elemanlarına sınıf ismiyle erişmeye gayret etmelisiniz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a = 0, int b = 0) : m_a(a), m_b(b)
	{
		++m_count;
	}
	static int count() { return m_count; }
	static void set_count(int count) { m_count = count; }

private:
	int m_a;
	int m_b;
	static int m_count;
};

int Sample::m_count;

int main()
{
	Sample s;
	Sample k;
	Sample z;

	cout << Sample::count() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz sınıfın üye fonksiyonlarına ve veri elemanlarına "sınıfın elemanları" diyelim. static olmayan üye fonksiyonlarına ve static olmayan veri elemanlarına da "static olmayan elemanları"
	diyelim. Bu durumda static üye fonksiyonlar sınıfın yalnızca static elemanlarını kullanabilirler. Ancak static olmayan üye fonksiyonlar sınıfın hem static olmayan
	elemanlarını hem de static olan elemanlarını kullanabilirler. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// date.hpp 

#ifndef DATE_HPP_
#define DATE_HPP_

class Date {
public:
	Date() = default;
	Date(int day, int month, int year);
	void disp() const;

	int day() const { return m_day; }
	void set_day(int day) {	m_day = day; }

	int month() const { return m_month; } 
	void set_month(int month) {	m_month = month; }

	int year() const { return m_year;	}
	void set_year(int year)	{ m_year = year; }
	
	const char *get_day_name() const;

	static bool isleap(int year);
	static Date today();
	
private:
	static long get_total_days(int day, int month, int year);
	static const char *get_day_name(int day, int month, int year);
private:
	int m_day;
	int m_month;
	int m_year;

	static int ms_montab[12];
	static const char *ms_monnames[7];
};

#endif

// date.cpp

#include <iostream>
#include <ctime>
#include "date.hpp"

using namespace std;

int Date::ms_montab[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
const char *Date::ms_monnames[7] = {"Pazar", "Pazartesi", "Sali", "Carsamba", "Persembe", "Cuma", "Cumartesi"};

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << '-' << get_day_name() << endl;
}

const char *Date::get_day_name() const
{
	return get_day_name(m_day, m_month, m_year);
}

bool Date::isleap(int year)
{
	return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}

Date Date::today()
{
	Date result;

	time_t t = time(NULL);
	tm *pt = localtime(&t);

	result.m_day = pt->tm_mday;
	result.m_month = pt->tm_mon + 1;
	result.m_year = pt->tm_year + 1900;

	return result;
}

long Date::get_total_days(int day, int month, int year)
{
	long total = 0;

	for (int i = 1900; i < year; ++i)
		total += isleap(i) ? 366 : 365;

	ms_montab[1] = isleap(year) ? 29 : 28;
	for (int i = 0; i < month - 1; ++i)
		total += ms_montab[i];

	total += day;

	return total;
}

const char *Date::get_day_name(int day, int month, int year)
{
	auto tdays = get_total_days(day, month, year);

	return ms_monnames[tdays % 7];
}

#include <iostream>
#include "date.hpp"

using namespace std;

int main()
{
	Date d(23, 4, 1920);

	d.disp();

	cout << d.get_day_name() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Global bir fonksiyon ya da başka bir sınıfın üye fonksiyonu bir sınıfın arkadaş fonksiyonu yapılabilir. Bu durumda arkadaş yapılan fonksiyon özel bir 
	erişim ayrıcalığına sahip olur. Arkadaş fonksiyonlar içeriisinde arkadaş olunan sınıf türünden bir nesne, gösterici ya da referans yoluyla o sınıfın tüm 
	bölümlerine erişebiliriz. friend bildirimi sınıfın herhangi bir bölümünde yapılabilir. Hangi bölümünde yapıldığının bir önemi yoktur. 

	Global bir fonksiyon friend yapıldığında friend bildirimi için o global fonksiyonun prototipinin ya da tanımlamasının görülmüş olması gerekmez. Ancak 
	friend bildirimi dışarısı için bir prototip bildirimi olarak kullanılamaz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a) : m_a(a)
	{}
	friend void foo();
private:
	int m_a;
};

void foo()
{
	Sample s;

	s.m_a = 10;					// geçerli çünkü foo friend

	cout << s.m_a << endl;		// geçerli çünkü foo friend
}

int main()
{
	foo();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Arkadaş sınıf bir sınıfın tüm üye fonksiyonlarının arkadaş olduğu anlamına gelmektedir. Bir sınıfı arkadaş yapabilmek için "friend class" bildirimi gerekir. 
	Örneğin:

	class Mample {
	public:
		void foo();
		void bar();
		//...
	};

	class Sample {
		//...
		friend class Mample;
	};

	Burada Mample sınıfı Sample sınıfının arkadaş sınıfıdır. Yani Mample içerisindeki foo ve bar üye fonksiyonlarında Sample türünden bir nesne, gösterici ya da referenas 
	yoluyla Sample sınıfının her bölümüne erişilebilir. Arkadaş bildiriminde arkadaş olarak bildirilen sınıf daha sonra bildirilebilir. Örneğin:

	class Sample {
		//...
		friend class Mample;
	};
	
	class Mample {
	public:
		void foo();
		void bar();
		//...
	};

	Tabii bunun için friend anahtar sözüğünün yanında class anahtar sçzcüğünün bulundurulması gerekir. Eğer arkadaş sınıf daha yukaıda bildiriliyorsa bu durumda 
	class anahtar sözcüğünün bulundurulması gerekmez. Örneğin:

		class Mample {
	public:
		void foo();
		void bar();
		//...
	};

	class Sample {
		//...
		friend Mample;		// geçerli
	};
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample() = default;
	Sample(int a) : m_a(a)
	{}
	friend class Mample;
private:
	int m_a;
};

class Mample {
public:
	void foo()
	{
		Sample s;

		s.m_a = 10;		// geçerli, Mample sınıfı Sample sınıfıın arkadaşı
		//...
	}

	void bar()
	{
		Sample s;

		s.m_a = 10;		// geçerli, Mample sınıfı Sample sınıfıın arkadaşı
		//...
	}
};

int main()
{
	//...

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin bir bağlı liste bir sınıfla temsil edilmiş olsun. Onun düğümleri de bir sınıfla temsil edilmiş olabilir. Bu durumda bağlı listenin bu düğümlerin
	private elemanlarına erişmesi gerekebilmektedir. İşte Node sınıfında bağlı sınıfını arkadaş sınıf yapabiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// linkedlistint.hpp 

#ifndef LINKEDLISTINT_HPP
#define LINKEDLISTINT_HPP

#include <cstddef>

class Node {
public:
	Node() = default;
	Node(int val) : m_val(val), m_next(nullptr)
	{}
	friend class LinkedListInt;
private:
	Node *m_next;
	int m_val;
};

class LinkedListInt {
public:
	LinkedListInt() : m_head(nullptr), m_tail(nullptr), m_size(0)
	{}
	~LinkedListInt();
	Node *add_tail(int val);
	void disp() const;
	std::size_t size() const { return m_size; }
private:
	Node *m_head;
	Node *m_tail;
	std::size_t m_size;
};

#endif

// linkedlistint.cpp

#include <iostream>
#include "linkedlistInt.hpp"

using namespace std;

Node *LinkedListInt::add_tail(int val)
{
	Node *new_node = new Node(val);

	if (m_head != nullptr)
		m_tail->m_next = new_node;
	else
		m_head = new_node;

	m_tail = new_node;

	++m_size;

	return new_node;
}

void LinkedListInt::disp() const
{
	for (Node *node = m_head; node != nullptr; node = node->m_next)
		cout << node->m_val << " ";
	cout << endl << m_size << " element listed" << endl;
}

LinkedListInt::~LinkedListInt()
{
	Node *node, *temp;

	node = m_head;
	while (node != nullptr) {
		temp = node->m_next;
		delete node;
		node = temp;
	}
}

// app.cpp

#include <iostream>
#include "LinkedListInt.hpp"

using namespace std;

int main()
{
	LinkedListInt lli;

	for (int i = 0; i < 100; ++i)
		lli.add_tail(i);

	lli.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ın standart kütüphanesinde dinamik olarak büyütülen dizileri temsil eden vector isimli şablon bir sınıf bulunmaktadır. vector sınıfının bildirimi 
	<vector> dosyası içerisinde yapılmıştır. Bir vector tutacağı elemanların türü belirtilerek sınıfın default yapıcı fonksiyonuyla yaratılabilir. Örneğin:

	vector<int> v;

	Vekötörün sonına eleman eklemek için push_back isimli üye fonksiyon kullanılmaktadır. vector sınıfının [] operatör fonksiyonu yazılmış durumadır. (Operatör
	fonksiyonları sonraki konuda ele alınacaktır.) Biz bu sayede vektörün herhangi bir indeksli elemanına erişebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 100; ++i)
		v.push_back(i);

	for (int i = 0; i < 100; ++i)
		cout << v[i] << " ";
	cout << endl;
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++11 ile birlikte C++'a eklenen "initializer list yapıcı fonksiyonu yoluyla" biz kme pareantezleri içerisinde elemanları belirterek de bir vektörü 
	oluşturabiliriz. Vektörler aralık tabalı for döngüsüyle dolaşılabilirler. Bu durumda döngünün her yünelenmesinde biz vektörün yeni bir elemanını 
	elde etmiş oluruz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {1, 2, 3, 4, 5};

	for (int x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Tabii aralık tabanlı for döngsünde dönü değişkeni bir referans olarak alınabilir burada auto belirleyicisi de kullanılabilir.     
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {1, 2, 3, 4, 5};

	for (int &x : v)
		x += 10;
	
	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir vektörde vektöre yerleştirilmiş eleman sayısına "size", vektör için tahsis edilmiş eleman sayısına ise "capacity" denilmektedir. Normalde capacity değeri
	size değerinden büyüktür. Ancak vektöre eleman eklendikçe size değeri artar. size değeri capacity değerine geldiğinde vektör capacity değerini yeniden tahsisat 
	yaparak büyütür. Capacity değerinin ne kadar büyütüleceği standartlarda belirtilmemiş olsa da tipik olarka eskisinin iki katı kadar büyütme uygulanmaktadır. 

	Vektördeki size değeri size üye fonksiyonu ile capacity değeri capacity üye fonksiyonu ile elde edilebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v = {1, 2, 3, 4, 5};

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	size ve capacity değerinin artışı aşağıdaki gibi gözlemlenebilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 100; ++i) {
		v.push_back(i);
		cout << "size: " << v.size() << ", capacity: " << v.capacity() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında bir vector belli bir size işin başında belirtilerek de yaratılabilir. Tabii bu durumda burada belirtilen miktarda eleman eğer vektör temel türleri 
	tutuyorsa 0'larla sınıf türlerini tutuyorsa onların default yapıcı fonksiyonlarıyla doldurulacaktır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v(10);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Vektöre eleman insert etme iteratör yoluyla yapılmaktadır. Biz enüz iteratör konusunu bilmiyoruz. Ancak eğer vektörün n'inci indeksine
	bir insert yapacaksanız buna ilişkin iteratörü v.begin() + n ifadesi ile oluşturabilirsiniz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v.insert(v.begin() + 3, 100);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Vektörden eleman silme işlemi de iteratör yoluyla yapılmaktadır. Ancak yukarıda da belirttiğimiz gibi pratik bir yöntem olarak iteratör pozisyonu
	v.begin() + n ifadesi ile oluşturulabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v.erase(v.begin() + 3);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	vector sınıfının clear üye fonksiyonu vektördeki tüm elemanları silmek için kullanılmaktadır. Ancak clear işleminden sonra vektörün size değeri 0 olmasına
	karşın, capacity değeri değiştirilmemektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v.clear();

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir vektörün içinin boş olup olmadığı empty üye fonksiyonu ile anlaşılabilir. Tabii aynıişlem v.size() == 0 ile de yapılabilir. C++11 ile birlikte ayrıca
	vektör sınıfına shrink_to_fit fonksiyonu eklenmiştir. Bu fonksiyon capacity değerini size değerine çekmektedir. Yine C++11 ile birlikte vektör sınıfına
	initializer_list atama operatör fonksiyonu eklenmiştir. Dolayısıyla biz bu sayede küme parantezli bir ifadeyi vektör nesnesine atayabiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	v = {10, 20, 30};		// C++11 ile birlikte

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Tabii vector sınıfında taşıma yapıcı fonksiyonu ve taşıma operatöçr operatör fonksiyonu olduğu için taşıma işlemleri etkin bir biçimde yapılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <vector>

using namespace std;

vector<int> foo()
{
	vector<int> v = {1, 2, 3, 4, 5};

	return v;		// taşıma yapıcı fonksiyonu çağrılır
}

int main()
{
	vector<int> v;

	v = foo();		// taşıma operatör fonksiyonu çağrılacak

	for (auto x : v)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Tabii vector sınıfı şablon bir sınıf olduğu için aslında herhangi türden bir nesneyi tutabilir.    
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main()
{
	vector<string> v = {"ali", "veli", "selami"};

	v.push_back("fatma");

	for (auto s : v)
		cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları (operator ovrloading) C++'ın yanı sıra C#, Swift, Python dillerde de olan bir özelliktir. Operatör fonksiyonları sayesinde sınıf nesneleri
	sanki temel türlerden nesnelermiş gibi +, -, * gibi operatörlerle işleme sokulabilmektedir. Operatör fonksiyonları aslında dile ilave bir işlevsel katmaz. 
	Yalnızca okunabilirlilk sağlamaktadır. 

	Operatör fonksiyonları bir sınıfın static olmayan üye fonksiyonları biçiminde yazılabilir ya da global bir fonksiyon biçiminde yazılabilir. Operatör fonksiyonlarının 
	genel biçimi şöyledir:

	<geri dönüş değerini türü> operator <operatör sembolü> ([parametre bildirimi])
	{
		//...
	}

	Operatör fonksiyonları tamamen normal bir fonksiyon gibidir. Bunların tek farkı isimlerinin operator anahtar sözcüğü ve operatör sembolünden oluşmasıdır. 

	Operatör fonksiyonlarının geri dönüş değerleri herhangi bir biçimde olabilir. Ancak operatör fonksiyonlarının parametre sayıları üzerinde kısıt vardır. Şöyle ki:

	- Operatör fonksiyonu iki operandlı bir operatöre ilişkinse onu üye operatör fonksiyon olarak yazarken fonksiyon tek parametreye, global operatör fonksiyonu olarak yazarken
	fonksiyon iki parametreye sahip olmak zorundadır. 

	- Operatör fonksiyonu tek operandlı bir operatöre ilişkinse onu üye operatör fonksiyon olarak yazarken fonksiyon sıfır parametreye, global operatör fonksiyonu olarak yazarken
	fonksiyon bir parametreye sahip olmak zorundadır. 
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları olmasaydı biz sınıflar üzerindeki operatörsel işlemleri normal fonksiyonlara yaptırırdık. Örmeğin aynı sınıf üründne iki sınıf nesnesini 
	toplamak için sınıf içerisine add isimli bir static olmayan üye fonksiyon ya da static bir üye fonksiyon yerleştirebilirid. Gerçekten de örneğin Java'da operatör
	fonksiyonları olmadığı için böyle işlemler üye fonksiyonlarla (metotlarla) yapılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number add(const Number &a) const;
	static Number add(const Number &x, const Number &y);

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
	
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::add(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::add(const Number &x, const Number &y)
{
	Number result;

	result.m_val = x.m_val + y.m_val;

	return result;
}

int main()
{
	Number a(10), b(20), c;

	c = a.add(b);	
	c.disp();

	c = Number::add(a, b);
	c.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	İşte operatör fonksiyonları aslında yukarıdaki gibi normal fonksiyonlardır. Onların tek farklılıkları isimlerinin operator anahtar sözcüğü ve operatör sembolünden
	oluşmasıdır. Tabii operatör fonksiyonları aslında isimle de çağrılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

int main()
{
	Number a(10), b(20), c;

	c = a + b;	// a.operator +(b)
	c.disp();

	c = a.operator +(b);
	c.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++ derleyicisi bir operatörle karşılaştığından önce operand'ların türlerine bakar. Eğer operand'lar temel türlere ilişkinse işlem öncesi otomatik tür 
	dönüştürmesi yoluyla işlemi yapar. Eğer operand'lardan en az bir tanesi bir sınıf türündense bu işlemi yapabilmek için sınıf içerisinde ve global düzeyde 
	operatör fonksiyonu araştırır. Operatör sembolü @ ile temsil ediliyor olsun:

	1) a @ b gibi bir işlem için derleyici a operand'ının ilişkin olduğu sınıfta a.operator @(b) çağrısına uygun bir @ operatör fonksiyonu araştırır. Aynı zamanda 
	derleyici bu işlemi yapabilecek global düzeyde operator @(a, b) çağrısına uygun bir global operatör fonksiyonu araştırmaktadır. Sınıfın operator @ ve global operator @
	fonksiyonları aday fonksiyonlar olarak seçilir ve "over resolution" işlemine sokulur. 

	2) @a ya da a@ gibi unary bir operatör için derleyici yine sınıfın içerisinde ve global düzeyde operator @ fonksiyonları araştırmaktadır. Sınıfın içerisinde 
	a.operator @() çağrısına uygun ya da global düzeyde operator @(a) çağrısına uygun global operatör fonksiyonlarını üye fonksiyon olarak belirler ve bunları 
	"overload resolution" işlemine sokar.

	Yukarıdaki örnekte:

	c = a + b;

	Buarada derleyici bu toplama işlemini yapabilecek Numbner sınıfında operator + isimli üye fonksiyonu ile global düzeyde operator + isiml global fonksiyonları 
	araştıracaktır. Dolayısıyla derleyici için bu işlem aşağıdakiyle eşdeğer olacaktır:

	c = a.operator +(b);

	C++'ta ".", "::", "?:" ve ".*" operatörlerine ilişkin operatömr fonksiyonları zaten hiç yazılamamaktadır 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Operatör fonksiyonları kombine edilebilir. Ancak bu duurmda operatör fonksiyonlarının çağrılma sırası operatör nceliklerine göre yapılmaktadır. Operatör
	önceliklerini değiştirmenin bir yolu yoktur. Örneğin:

	result = a + b * c;

	gibi bir işlemde önce b ile c operator * fonksiyonu ile işleme sokulur. Buradan elde edilecek değer a ile toplanır. Yani bu işlemin eşdeğeri şöyledir:

	result = a.operator +(b.operator *(c));

	Örneğin:

	result = a + b + c;

	Bu işlemin de eşdeğeri şöyledir:

	result = a.operator +(b).operator +(c);

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;
	Number operator *(const Number &x) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::operator *(const Number &x) const
{
	Number result;

	result.m_val = m_val * x.m_val;

	return result;
}

int main()
{
	Number a(1), b(2), c(3), result;

	result = a + b * c;		// result = a.operator +(b.operator *(c));
	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları anlamlı ve herkes tarafındna tahmin edilebilecek bir işleve sahip olacaksa bulundurulmalıdır. Bazı operatörler varsa onunla ilişkili 
	bazı operatörlerin de sınıfta bulundurulması uygun olur. Örneğin sınıfta '+' operatör fonksiyonu varsa '-' operatör fonksiyonu da sınıfta bulundurulmalıdır.
	'*' operatör fonksiyonu varsa '/' operatör fonksiyonu da sınıfta bulundurulmalıdır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;
	Number operator -(const Number &a) const;
	Number operator *(const Number &x) const;
	Number operator /(const Number &x) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::operator -(const Number &x) const
{
	Number result;

	result.m_val = m_val - x.m_val;

	return result;
}

Number Number::operator *(const Number &x) const
{
	Number result;

	result.m_val = m_val * x.m_val;

	return result;
}

Number Number::operator /(const Number &x) const
{
	Number result;

	result.m_val = m_val / x.m_val;

	return result;
}

int main()
{
	Number a(1), b(2), c(3), result;

	result = a + a + a;		
	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Operatör fonksiyonları da "overload" edilebilirler. Yani farklı parametrik yapılara sahip aynı isimli birden fazla operatör fonksiyonu bir arada bulunabilir. 
	Örneğin iki Number nesnesini toplayan + operatör fonksiyonunun yanı sıra bir Number nesnesi ile bir int değeri toplayan bir + operatör fonksiyonu bir arada 
	bulunabilir. Ancak bazı operatörlerin değişme özelliğinin sağlanması da gerekir. Örneğin bir Number nesnesi ile bir int değeri toplayabiliyorsak, bir int değerle
	bir Number nesnesini de toplayabilmemiz gerekir. Ancak bir int değerle birt Number nesnesini toplayabilen üye operatör fonksiyonu yazmak mümkün değldir. Örneğin:

	int a = 10;
	Number b(20);
	Number result;

	result = a + 10;		// result = a.operator +(10);
	result = 10 + a;		// result = 10.operator +(a); Dikkat! int bir sınıf değil! mümkün değil

	İşte bu tür durumlarda global operatör fonksiyonları ile bu işlemler yapılabilmektedir. C++'ta birkaç operatörün operatör fonksiyonları üye operatör fonksiyonu 
	biçiminde yazılmak zorundadır. Ancak pek çok operatör üye operatör fonksiyonu biçiminde ve global operatör fonksiyonu biçiminde yazılabilmektedir. Bu tür durumlarda
	programcılar genellikle üye operatör fonksiyonu olarak yazabildiklerini üye operatör fonksiyonu olarak, yazamadıklarını da global operatör fonksiyonu olarak 
	yazmalıdırlar.

	Operatör fonksiyonunu global operatör fonksiyonu olarak yazdığımızda artık sınıfın private elemanlarına erişemeyeceğimize dikkat ediniz. Bu durumda mecburen 
	sınıfın getter/setter fonksiyonlarındna faydalanırız. Aslında bu tür fonksiyonların "arkadaş (friend)" yapılması çok karşılaşılan bir durumdur. 

	Tabii aslında bu tür global operatör fonksiyonları bir "sarma (wrapper)" fonksiyon olarak da yazılabilmektedir. Örneğin:

	inline Number operator +(int val, const Number &x)
	{
		return x + val;
	}

	C++'ta dört operatöre ilişkin operatör fonksiyonlarının üye operatör fonksiyonu olarak yazılması zorunlu tutulmuştur. Bunlar "=", "(...)", "*" ve "->" operatör
	fonksiyonlarıdır. Diğer operatörlerin operatör fonksiyonları üye operatör fonksiyonu ya da global operatör fonksiyonu biçiminde yazılabilirse de programcı 
	mümkün olduğu kadar üye operatör fonksiyonu biçiminde bunları yazmaya çalışmalıdır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Number {
public:
	Number() = default;
	Number(int val) : m_val(val)
	{}
	void disp() const;
	Number operator +(const Number &a) const;
	Number operator -(const Number &a) const;
	Number operator *(const Number &x) const;
	Number operator /(const Number &x) const;

	Number operator +(int val) const;
	Number operator -(int val) const;
	Number operator *(int val) const;
	Number operator /(int val) const;

	int val() const { return m_val; }
	void set_val(int val) { m_val = val; }
		
private:
	int m_val;
};

void Number::disp() const
{
	cout << m_val << endl;
}

Number Number::operator +(const Number &x) const
{
	Number result;

	result.m_val = m_val + x.m_val;

	return result;
}

Number Number::operator -(const Number &x) const
{
	Number result;

	result.m_val = m_val - x.m_val;

	return result;
}

Number Number::operator *(const Number &x) const
{
	Number result;

	result.m_val = m_val * x.m_val;

	return result;
}

Number Number::operator /(const Number &x) const
{
	Number result;

	result.m_val = m_val / x.m_val;

	return result;
}

Number Number::operator +(int val) const
{
	Number result;

	result.m_val = m_val + val;

	return result;
}

Number Number::operator -(int val) const
{
	Number result;

	result.m_val = m_val - val;

	return result;
}

Number Number::operator *(int val) const
{
	Number result;

	result.m_val = m_val * val;

	return result;
}

Number Number::operator /(int val) const
{
	Number result;

	result.m_val = m_val / val;

	return result;
}

inline Number operator +(int val, const Number &x)
{
	Number result;

	result.set_val(val + x.val());

	return result;		// return x + val;
}

Number operator *(int val, const Number &x)
{
	Number result;

	result.set_val(val * x.val());

	return result;
}

int main()
{
	Number a(1), result;

	result = a + 2;
	result.disp();

	result = 2 + a;
	result.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Karşılaştırma operatör fonksiyonlarının geri dönüş değerleri herhangi bir türden olabilir ancak bunların bool türden olması en uygun durumdur. 
	Karşılaştırma operatör fonksiyonlarının mümkünse hepsi yazılmalıdır. Yani örneğin eğer biz < operatör fonksiyonunu yazmış isek > opertör fonksiyonunu da
	yazmalıyız. == operatör fonksiyonunu yazmış isek != operatör fonksiyonunun da yazılması uygun olur. Yani mümkünse <, >, <=, >=, ==, != operatör fonksiyonlarının
	hepsinin yazılması tavsiye edilmektedir. Tabii bazı sınıflar için örneğin == ve != operatörleri anlamlı iken <, >, <=, >= operatör fonksiyonlaırnın bir anlamı olmayabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Köşeli parantez operatörüne ilişkin operatör fonksiyonları yazılırken fonksiyonun bir referansa geri dönmesi gerekir. Çünkü köşeli parantez 
	ifadesine aynı zamanda atama da yapılabilmektedir. const nesnelerle köşeli parantez operatörünün kullanılabilmesi için bu operatör fonksiyonun 
	const bir biçimi de bulundurulmalıdır. Tabii bu biçimin const bir referansa geri dönmesi uygun olur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <stdexcept>

using namespace std;

class Date {
public:
	Date(int day, int month, int year) : m_day(day), m_month(month), m_year(year)
	{}
	void disp() const;
	int &operator[] (size_t index);
private:
	int m_day;
	int m_month;
	int m_year;
};

void Date::disp() const
{
	cout << m_day << '/' << m_month << '/' << m_year << endl;
}

int &Date::operator[] (size_t index)
{
	if (index == 0)
		return m_day;
	if (index == 1)
		return m_month;
	if (index == 2)
		return m_year;

	throw invalid_argument("index out of range");
}

int main()
{
	Date d(12, 11, 2007);

	cout << d[0] << endl;
	cout << d[1] << endl;
	cout << d[2] << endl;

	d[0] = 13;
	d[1] = 6;
	d[2] = 2022;

	d.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    En önemli operatör fonksiyonlarından biri de "atama operatör" fonksiyonudur. Bir atama işleminde sol taraftaki nesne bir sınıf türündense bu duurmda atama 
	işlemi sınıfın "atama operatör fonksiyonu" denilen bir fonksiyon çağrılarak yapılır. Yani a bir sınıf nesnesi olmak üzere:

	a = b;

	işleminin derleyici için eşdeğeri şöyledir:

	a.operator=(b);

	Atama operatör fonksiyonları "overload" edilebilir. Ancak bir sınıfın kendi sınıfı türünden bir nesneyi atamakta kullanılan operatör fonksiyonuna "kopya atama
	operatör fonksiyonu" denilmektedir. Kopya atama operatör fonksiyonu sınıfın ismi T olmak üzere aşağıdkai parametrelere sahip atama operatör fonksiyonlarıdır:

	T &operator =(const T&r);
	T &operator =(T &r);
	T &operator =(volatile T &r);
	T &operator =(const volatile T &r);
	T &operator =(T r);

	Eğer programcı sınıf için kopya atama operatör fonksiyonu yazmamışsa bu fonksiyon derleyici tarafından public inline biçiminde aşağıdaki parametrik 
	yapıyla yazılmaktadır:

	T &operator =(const T&r);

	Bu konuda bazı ayrıntılar da vardır. Derleyicinin yazdığı kopya atama operatör fonksiyonu sınıfın karşılıklı veri elemanlarını biribrine atar (memberwise copy).
	Tabii bir sınıfın gösterici veri elemanı gibi veri elemanları varsa programcı yine kopya atama operatör fonksiyonunu içerik kopyalaması yapacak biçimde kendisi 
	yazmalıdır. 

	Bie sınıf için ne zaman kopya yapıcı fonksiyonu gerekiyorsa o sınıf için aynı zamanda kopya atama operatör fonksiyonu da gerekmektedir. 

	C++11 ile birlikte kopya atama operatör fonksiyonu için bazı ayrıntılar da dile eklenmiştir. Örneğin bir sınıf taşıma yapıcı fonksiyonuna sahipse artık derleyici 
	o sınıf için kopya atama operatör fonksiyonunu "deleted" kabul etmektedir. Yazi yazmamaktadır. Ancak kopya atama operatör fonksiyonu "defaulted" yapılarak 
	derleyici tarafoan yazılması zorlanabilir. Örneğin:

	class T {
	public:
		//...
		T & operator =(const T&) = default;
	};

	Sınıfın kopya atama operatör fonksiyonu tıpkı kopya yapıcı fonksiyonunda olduğu gibi içerik kopyalaması yapmalıdır. 

	C++'ta atama operatöründen elde edilen değer bir nesne belirtmektedir. Ancak C'de nesne belirtmemektedir. Örneğin aşağıdaki ifade C'de geçersiz olduğu halde 
	C++'ta geçerlidir:

	(a = b) = c;		// C'de geçersiz! C++'ta geçerli

	İşte atama operatöründen elde edilen ürünün nesnebelirtmesi için atama operatör fonksiyonunun kendi sınıfı türünden bir referansa geri dönmesi ve return ifadesinde
	de *this bulunması gerekmektedir. 

	Ayrıca a = a gibi bir işlem anlamsız olsa da buna önlem almak gerekebilir. 


	Aşağıdaki örnekte kendş yazdığımız String sınıfına atama operatör fonksiyonlarını ekledik.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor

	void disp() const;

	String operator +(const String &r) const;
	String operator +(const char *str) const;
	String operator *(int n) const;
	char &operator[] (std::size_t index) { return m_str[index]; }
	const char &operator[] (std::size_t index) const { return m_str[index]; }
	String &operator =(const String &r);
	String &operator =(const char *str);

	~String();
private:
	char *m_str;
	std::size_t m_len;
};

String operator +(const char *str, const String &r);
String operator *(int n, const String &r);

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = nullptr;
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	if (r.m_str != nullptr) {
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
	}
	else
		m_str = nullptr;
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = nullptr;
}

void String::disp() const
{
	cout << m_str << endl;
}

String &String::operator =(const String &r)
{
	if (this == &r)		/* nesne kendisine atanmış mı? */
		return *this;

	delete[] m_str;

	m_len = r.m_len;
	m_str = new char[m_len + 1];
	strcpy(m_str, r.m_str);

	return *this;
}

String &String::operator =(const char *str)
{
	delete[] m_str;

	m_len = strlen(str);
	m_str = new char[m_len + 1];
	strcpy(m_str, str);

	return *this;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main()
{	
	String s("ankara");
	String k;

	k = s;		// k.operator =(s);

	s.disp();
	k.disp();

	k = "istanbul";		// s.operator =("istanbul");
	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Geçici bir sınıf nesnesinin sağ taraf değeri belirttiğini anımsayınız. Bu durumda biz bir sınıf nesnesine bir geçici nesne atarsak o geçici nesnedeki kaynakları
	etkin biçimde taşıyabiliriz. İşte bu işlem "taşıma atama operatör fonksiyonu (move assignment operator)" ile yapılmaktadır. Örneğin:

	String s;

	s = String("Ankara");

	Burada eğer taşıma operatör olmasaydı (C++11 öncesinde durum böyleydi) önce String nesnesi yaratılıp sonra o nesne kopya atama operatör fonksiyonu yoluyla
	s'e atanacaktı. Bu atama sırasında yine içerik kopyalaması yapılacaktı. Bu atamada aşağıdaki parametrik yapıya sahip taşıma atama operatör fonksiyonu çalıştırılabilmektedir:

	String &operator =(String &&s);

	Genel olarak bir sınıf taşıma yapıcı fonksiyonuna sahipse taşıma operatör fonksiyonuna da sahip olmalıdır. 

	Aşağıdaki örnekte daha önce yazdığımız String sınıfınına taşıma operatör atama fonksiyonunu ekledik.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor

	void disp() const;

	String operator +(const String &r) const;
	String operator +(const char *str) const;
	String operator *(int n) const;
	char &operator[] (std::size_t index) { return m_str[index]; }
	const char &operator[] (std::size_t index) const { return m_str[index]; }
	
	String &operator =(const String &r);
	String &operator =(const char *str);
	String &operator =(String &&r);

	~String();
private:
	char *m_str;
	std::size_t m_len;
};

String operator +(const char *str, const String &r);
String operator *(int n, const String &r);

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = nullptr;
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	if (r.m_str != nullptr) {
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
	}
	else
		m_str = nullptr;
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = nullptr;
}

void String::disp() const
{
	cout << m_str << endl;
}

String &String::operator =(const String &r)
{
	if (this == &r)		/* nesne kendisine atanmış mı? */
		return *this;

	delete[] m_str;

	m_len = r.m_len;
	m_str = new char[m_len + 1];
	strcpy(m_str, r.m_str);

	return *this;
}

String &String::operator =(const char *str)
{
	delete[] m_str;

	m_len = strlen(str);
	m_str = new char[m_len + 1];
	strcpy(m_str, str);

	return *this;
}

String &String::operator =(String &&r)
{
	delete m_str;

	m_len = r.m_len;
	m_str = r.m_str;

	r.m_str = nullptr;

	return *this;
}

String::~String()
{
	delete[] m_str;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main()
{	
	String s;

	s = String("istanbul");

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda vector sınıfına benzeyen ama şablon olmayıp yalnızca int türden değerleri tutan örnek bir sınıf oluşturulmuştur.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// intvector.hpp

#ifndef INTVECTOR_HPP_
#define INTVECTOR_HPP_

#include <cstddef>

const int DEF_CAPACITY = 4;

class IntVector {
public:
	IntVector();
	IntVector(std::size_t size);
	IntVector(const IntVector &r);
	IntVector(IntVector &&r);
	~IntVector();

	std::size_t size() const { return m_size; }
	std::size_t capacity() const { return m_capacity; }

	void push_back(int val);
	inline int &operator[](std::size_t index);
	inline const int &operator[](std::size_t index) const;

	IntVector &operator =(const IntVector &r);
	IntVector &operator =(IntVector &&r);

	void disp() const;
private:
	int *m_pv;
	std::size_t m_size;
	std::size_t m_capacity;
};

int &IntVector::operator[](std::size_t index)
{
	return m_pv[index];
}

const int &IntVector::operator[](std::size_t index) const
{
	return m_pv[index];
}

#endif

// intvector.cpp

#include <iostream>
#include "intvector.hpp"

using namespace std;

IntVector::IntVector()
{
	m_capacity = DEF_CAPACITY;
	m_size = 0;
	m_pv = new int[DEF_CAPACITY];
}

IntVector::IntVector(std::size_t size)
{
	m_capacity = size;
	m_size = size;
	m_pv = new int[size];
}

IntVector::IntVector(const IntVector &r)
{
	m_pv = new int[r.m_size];

	for (size_t i = 0; i < r.m_size; ++i)
		m_pv[i] = r.m_pv[i];

	m_capacity = m_size = r.m_size;
}


IntVector::IntVector(IntVector &&r)
{
	m_pv = r.m_pv;
	m_size = r.m_size;
	m_capacity = r.m_capacity;

	r.m_pv = nullptr;
}

IntVector::~IntVector()
{
	delete[] m_pv;
}

void IntVector::push_back(int val)
{
	int *pv_new;

	if (m_size == m_capacity) {
		pv_new = new int[m_capacity * 2];
		for (size_t i = 0; i < m_size; ++i)
			pv_new[i] = m_pv[i];
		m_capacity *= 2;
		delete[] m_pv;
		m_pv = pv_new;
	}
	m_pv[m_size++] = val;
}

IntVector &IntVector::operator =(const IntVector &r)
{
	if (this == &r)
		return *this;

	delete[] m_pv;

	m_pv = new int[r.m_size];

	for (size_t i = 0; i < r.m_size; ++i)
		m_pv[i] = r.m_pv[i];

	m_size = r.m_size;
	m_capacity = r.m_capacity;

	return *this;
}

IntVector &IntVector::operator =(IntVector &&r)
{
	delete[] m_pv;

	m_pv = r.m_pv;
	m_size = r.m_size;
	m_capacity = r.m_capacity;

	r.m_pv = nullptr;

	return *this;
}

void IntVector::disp() const
{
	for (size_t i = 0; i < m_size; ++i)
		cout << m_pv[i] << " ";

	cout << endl;
}

// app.cpp

#include <iostream>
#include "intvector.hpp"

using namespace std;

IntVector foo()
{
	IntVector v;

	for (int i = 0; i < 10; ++i)
		v.push_back(i);

	return v;
}

int main()
{	
	IntVector k;

	k = foo();

	k.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz başından beri ekrana (yani stdout dosyasına) birşeyler yazmak için cout değişkenini, klavyeden (yani stdin dosyasından) bir şeyler okuyabilmek için
	cin nesnesin kullandık. Pekiyi bu bu değişkenler nedir? İşte aslında cout ostream denilen bir sınıf türünden, cin ise istream denilen bir sınıf türündne global 
	nesnelerdir. ostream sınıfı basic_ostream şablon sınıfının char açılımıdır. Benzer biçimde istream sınıfı da aslında basic_istream şablon sınıfının char için 
	açılımıdır. Yani ostream ve istream aslında typedef isimleridir. Biz şablon sınıfları izleyen konularda göreceğiz. Bu nedenle bu sınıfların şablonluk özelliği 
	üzerinde durmayacağız. 

	C++'ın iostream sınıfları şablonluk özelliğini söz konusu etme<sek aşağıdaki biçimde bir türetme şemasına sahiptir. 

              ios_base 
			     |
				 |
              basic_ios
			   /    \
              /      \       
          istream  ostream
	        \        /
	         \      /  
		      \    /
               \  /
			 iostream

	Buradan da görüldüğü gibi iostream sınıfı istream ve ostream sınıfından çoklu türetilmiştir. istream ve ostream sınıflarının ortak elemanları basic_ios 
	sınıfından türetilmiş durumdadır. basic_ios sınıfı da ios_base sınıfındn türetilmiştir. ostream sınıfının bir grup overload edilmiş << operatör fonksiyonu, 
	istream sınıfının da overload edilmiş bir grup >> operatör fonksiyonu bulunmaktadır. cout nesnesi ostream sınıfı türünden olduğna göre viz bu nesneyle 
	yalnızca << operatör fonksiyonlarını, cin nesnesi de istream sınıfı türünden olduğuna göre biz bu nesneyle yalnızca >> ıperatör fonksiyonlarını kullanabiliriz. 
	Şablonluk özelliği bir yana bırakılırsa bu sınıfların aşağıdaki gibi bir yapıya sahip olduğu söylenebilir:

	class ostream : public basic_ios {
	public:
		ostream &operator <<(int a);
		ostream &operator <<(long a);
		ostream &operator <<(double a);
		ostream &operator <<(char a);
		//...
	};

	class istream : public basic_ios {
	public:
		istream &operator >>(int &a);
		istream &operator >>(long &a);
		istream &operator >>(double &a);
		istream &operator >>(char &a);
		//...
	};

	Şimdi cout nesnesinin aşağıdaki gibi kullanıldığını düşünelim:

	cout << a << ", " << b << "\n";

	Bunun eşdeğeri şöyledir:

	cout.operator <<(a).operator <<(", ").operator <<(b).operator <<("\n");

	Bu operatör fonksiyonlarının nesnenin kendisine geri döndüğüne dikkat ediniz. Böylece örneğin cout.operator <<(a) gibi bir çağrıdan cout nesnesinin yine 
	kendisi elde edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aşağıda ostream ve istream sınıflarınımn nasıl yazılmış olacbileceğine ilişkin bir örnek verilmiştir. Bu örneğin amacı ostream ve istream sınıflarının
	orijinalini yazmak değildir. Yalnızca ostream ve istream sınıfının nasıl yazılmış olabileceğine ilişkin bir ipucu vermektisr. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <cstdio>
#include <string>

class ostream {
public:
	ostream &operator <<(int a);
	ostream &operator <<(long a);
	ostream &operator <<(double a);
	ostream &operator <<(char a);
	ostream &operator <<(const char *str);
	ostream &operator <<(std::string &s);
	ostream &operator <<(ostream &(&f)(ostream &));
};

ostream &ostream::operator <<(int a)
{
	std::printf("%d", a);

	return *this;
}

ostream &ostream::operator <<(long a)
{
	std::printf("%ld", a);

	return *this;
}

ostream &ostream::operator <<(double a)
{
	std::printf("%f", a);

	return *this;
}

ostream &ostream::operator <<(char a)
{
	std::printf("%c", a);

	return *this;
}

ostream &ostream::operator <<(const char *str)
{
	std::printf("%s", str);

	return *this;
}

ostream &ostream::operator <<(std::string &s)
{
	std::printf("%s", s.c_str());

	return *this;
}

ostream &ostream::operator <<(ostream &(&f)(ostream &))
{
	return f(*this);
}

ostream &endl(ostream &os)
{
	os << '\n';

	return os;
}

class istream {
public:
	istream &operator >>(int &a);
	istream &operator >>(long &a);
	istream &operator >>(double &a);
	//...
};

istream &istream::operator >>(int &a)
{
	scanf("%d", &a);

	return *this;
}

istream &istream::operator >>(long &a)
{
	scanf("%ld", &a);

	return *this;
}

istream &istream::operator >>(double &a)
{
	scanf("%lf", &a);

	return *this;
}

ostream cout;
istream cin;

int main()
{	
	int a;
	double b;

	cin >> a >> b;

	cout << "a = " << a << ", b = " << b << endl;
	cout << "this is a test" << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar bir sınıf yazdığımızda o sınıfın içerisindeki bilgileri ekrana (stdout dosyasına) yazdırmak için sınıfta disp isimli fonksiyonlar 
	bulundurduk. Aslında C++'ta sınıf nesnesinin içerisindeki bilgilerin ekrana yazdırılması cout yoluyla yapılmalıdır. Yani cout nesnesi ile biz nasıl 
	int, long gibi temel türlere ilişkin bilgileri yazdırabiliyorsak kendi sınıfımıza ilişkin bilgileri yazdırabilmeliyiz. 

	Kendi sınıflarımıza ilişkin nesneleri ekrana (stdout dosyasına) yazdırabilmemiz mecburen global bir operatör fonksiyonu yazmamız gerekir. Örneğin:

	Sample s;

	cout << s;		// cout.operator(s)

	Burada biz ostream sınıfının içerisine fonksiyonumuzu yerleştiremeyeceğimize göre mesburen bu işlemi yapan bir global operatör fonksiyonu yazmalıyız. 
	Yazacağımız global operatör fonksiyonunun birinci parametresi ostream & türünden olmalıdır. İkinci parametresi ise kendi sınıfımız türünden const bir referans
	olabilir. Kombine edilebilirliği sağlamak için bu operatör fonksiyonun çağırısından bizim yine ostream nesnesinin kendisini elde etmemiz gerekir. Bu durumda 
	fonksiyonun geri dönüş değeri ostream & olmalıdır. Tabii bu global operatör fonksiyonun friend yapılması uygun olur. Özetle Smaple sınıfı için yazılacak 
	<< operatör fonksiyonu aşağıdaki gibi olmalıdır:

	class Sample {
		friend ostream &operator <<(ostream &os, const Sample &s);
		//...
	};

	ostream &operator <<(ostream &os, const Sample &s)
	{
		//...

		return os;
	}

	Aşağıda Complex sınıfı için bu operatör fonksiyonun yazımını görüyorsunuz.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP
#define COMPLEX_HPP

#include <ostream>

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0)
	{
		m_real = real;
		m_imag = imag;
	}
	friend std::ostream &operator <<(std::ostream &os, const Complex &r);
private:
	double m_real;
	double m_imag;
};

#endif

// complex.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

ostream &operator <<(ostream &os, const Complex &r)
{
	os << r.m_real << '+' << r.m_imag << 'i';

	return os;
}

// app.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

int main()
{	
	Complex z(3, 2);

	cout << z << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de String sınıfımız için bu operatör fonksiyonunu yazalım.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// string.hpp

#ifndef STRING_HPP_
#define STRING_HPP_

#include <cstddef>
#include <ostream>

class String {
public:
	String();
	String(const char *str);
	String(const String &r);		// copy constructor
	String(String &&r);				// move constructor
	~String();

	String operator +(const String &r) const;
	String operator +(const char *str) const;
	String operator *(int n) const;
	char &operator[] (std::size_t index) { return m_str[index]; }
	const char &operator[] (std::size_t index) const { return m_str[index]; }
	
	String &operator =(const String &r);
	String &operator =(const char *str);
	String &operator =(String &&r);

	friend std::ostream &operator <<(std::ostream &os, const String &r);
	
private:
	char *m_str;
	std::size_t m_len;
};

String operator +(const char *str, const String &r);
String operator *(int n, const String &r);

#endif

// string.cpp

#include <iostream>
#include <cstring>
#include "string.hpp"

using namespace std;

String::String()
{
	m_str = nullptr;
	m_len = 0;
}

String::String(const char *str)
{
	m_len = strlen(str);

	m_str = new char[m_len + 1];
	strcpy(m_str, str);
}

String::String(const String &r)
{
	if (r.m_str != nullptr) {
		m_str = new char[r.m_len + 1];
		strcpy(m_str, r.m_str);
	}
	else
		m_str = nullptr;
	m_len = r.m_len;
}

String::String(String &&r)
{
	m_str = r.m_str;
	m_len = r.m_len;
	r.m_str = nullptr;
}

String::~String()
{
	delete[] m_str;
}

String &String::operator =(const String &r)
{
	if (this == &r)		/* nesne kendisine atanmış mı? */
		return *this;

	delete[] m_str;

	m_len = r.m_len;
	m_str = new char[m_len + 1];
	strcpy(m_str, r.m_str);

	return *this;
}

String &String::operator =(const char *str)
{
	delete[] m_str;

	m_len = strlen(str);
	m_str = new char[m_len + 1];
	strcpy(m_str, str);

	return *this;
}

String &String::operator =(String &&r)
{
	delete m_str;

	m_len = r.m_len;
	m_str = r.m_str;

	r.m_str = nullptr;

	return *this;
}

ostream &operator <<(ostream &os, const String &r)
{
	os << r.m_str;

	return os;
}

// app.cpp

#include <iostream>
#include "string.hpp"

using namespace std;

int main()
{	
	String s{"ankara"};

	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Kendi sınıflarımızı cin ile okumasını yapmak çoğu kez mümkün olmaz. Çünkü sınıf nesneleri bileşik türlerdir. Bunların basit bir biçimde klavyeden (stdin dosyasından)
	mümkün olmayabilir. Ancak biz yine de burada Sample sınıfı için bunun nasıl yapılacağının ipucunu vermek istiyoruz.

	class Sample {
		friend istream &operator >>(istream &is, Sample &r);
		//...
	};

	istream &operator >>(istream &is, Sample &r)
	{
		//...

		return is;
	}

	Aşağıda Complex sınıfı için bir örnek verilmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// complex.hpp

#ifndef COMPLEX_HPP
#define COMPLEX_HPP

#include <ostream>
#include <istream>

class Complex {
public:
	Complex() = default;
	Complex(double real, double imag = 0)
	{
		m_real = real;
		m_imag = imag;
	}
	friend std::ostream &operator <<(std::ostream &os, const Complex &r);
	friend std::istream &operator >>(std::istream &is, Complex &r);
private:
	double m_real;
	double m_imag;
};

#endif

// complex.cpp

#include <iostream>
#include "Complex.hpp"

using namespace std;

ostream &operator <<(ostream &os, const Complex &r)
{
	os << r.m_real << '+' << r.m_imag << 'i';

	return os;
}

istream &operator >>(istream &is, Complex &r)
{
	is >> r.m_real >> r.m_imag;

	return is;
}

// app.cpp

#include <iostream>
#include "complex.hpp"

using namespace std;

int main()
{	
	Complex z;

	cout << "Bir karmaşık sayıyı gercek ve sanal kisimlarini belirterek giriniz:";
	cin >> z;

	cout << z << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta bir gösterici gibi davranan sınıflara "akıllı gösterici (smart pointer)" sınıfları denilmektedir. C++11 ile birlikte C++'a unique_ptr gibi, shared_ptr 
	gibi smart pointer sınıfları eklenmiştir. Bir sınıfın bir gösterici gibi davranmasının bazı faydaları söz konusu olabilir. Ancak en önemli fayda otomatik boşaltımın
	sağlanmasıdır. Programcı smart pointer sınıfı için bir nesnesyi dinamik olarak tahsis eder. Ancak bunun delete edilmesi sınıfın yıkıcı fonksiyonu yoluyla otomatik 
	yapılır. Tabii standart kütüphanedeki unique_ptr gibi shared_ptr gibi sınıflar şablon olarak yazılmıştır. 

	Göstericiyi taklit eden bir sınıf için * operatör fonksiyonun yazılması gerekir. * operatör fonksiyonu üye fonksiyon olarak yazılmak zorundadır. Ve bu fonksiyonun bir 
	sağ taraf değeri ile geri dönmesi gerekir. 

	Aşağıda int türünden bir göstericiyi taklit eden bir smart pointer sınıfı örneği verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class smart_pointer_int {
public:
	smart_pointer_int(int *pi) : m_pi(pi)
	{}
	~smart_pointer_int()
	{
		delete m_pi;
	}
	int &operator *() const
	{
		return *m_pi;
	}

private:
	int *m_pi;
};

int main()
{	
	smart_pointer_int pi{new int{10}};

	cout << *pi << endl;

	*pi = 20;

	cout << *pi << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    -> operatör fonksiyonu bir sınıf türünden gçstriciyi taklit eden sınıflar için kullanılmaktadır. -> operatör fonksiyonu da üye fonksiyon biçiminde yazılmak zorundadır. 
	-> operatör fonksiyonu bir sol taraf değeri ile değil bizzat sınıf türünden bir adresle geri dönmelidir. Çünkü s bir smart pointer nesnesi olmak üzere:

	s->a

	gibi bir işlemin C++ oepartör fonksiyonu eşdeğeri aslında şöyledir:

	s.operator->()->a 

	Aşağıda string sınıfı türünden göstericiyi temsil eden örnek bir smart pointer sınıfı verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class smart_pointer_string {
public:
	smart_pointer_string(string *ps) : m_ps(ps)
	{}
	~smart_pointer_string()
	{
		delete m_ps;
	}
	string &operator *() const
	{
		return *m_ps;
	}
	string *operator ->() const
	{
		return m_ps;
	}
private:
	string *m_ps;
};

int main()
{	
	smart_pointer_string ss(new string("ankara"));
	string s;

	cout << *ss << endl;

	s = (*ss).substr(0, 3);
	cout << s << endl;

	s = ss->substr(0, 3);		// s = ss.operator->()->substr(0, 3)
	cout << s << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++11 ile birlikte şablon tabanlı unique_ptr ismiyle genel bir smart pointer sınıfı standart kütüphaneye eklenmiştir. unique_ptr sınıfı (ismi üzerinde) 
	bir nesneyi gösteren tek bir smart pointer nesnesinin olmasını hedefleyen bir sınıftır. uniqe_ptr bir göstericiyi taklit eder. Ancak o göstericinin gösterdiği 
	yeri gösteren başka bir	uniqe_ptr nesnesinin bulunamayacağını da garanti etmektedir. Başka bir deyişle hiçbir zaman iki unique_ptr nesnesi aslında aynı dinamik alanı gösteremez. 

	uniqe_ptr nesnesi dinamik tahsis edilmiş bir nesnenin adresiyle yaratılmalıdır. Örneğin:

	unique_ptr<int> pi(new int);
	unique_ptr<string> ps(new string("ankara"));

	unique_ptr sınıfının yapıcı fonksiyonu "explicit" olduğu için (explicit yapıcı fonksiyonlar ileride ele elınacaktır) biz nesneyi '=' ile llkdeğer vererek yaratamayız. 
	Örneğin:

	unique_ptr<int> pi = new int;		// error!
	unique_ptr<int> pi(new int);		// geçerli
	unique_ptr<int> pi{new int};		// geçerli

	unique_ptr sınıfının * ve -> operatörleri overload edilmiştir. Örneğin:

	unique_ptr<string> ps(new string("ankara"));
	string result;

	cout << *ps << endl;

	result = ps->substr(0, 3);
	cout << result;

	Sınıfın yıkıcı fonksiyonu tabii dinamik alanı delete etmektedir. Sınıfın kopya yapıcı fonksiyonu ve kopya operatör fonksiyonu "deleted" biçimdedir. Yani aşağıdaki 
	gibi biz unique_ptr nesnesinin kopyasını çıkartamayız:

	unique_ptr<int> p1(new int);		// geçerli
	unique_ptr<int> p2(p1);				// error!

	p2 = p1;							// error!

	Sınıfın release isimli üye fonksiyonu sınıfın tuttuğu adresini geri dönüş değeri olarak verir. Ancak sınıfın içerisindeki göstericiye null adres atar. Yani release
	işleminden sonra artık sınıf o dinamik nesneyi göstermez hale gelr. Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us(new string("ankara"));
		string *s;

		s = us.release();				// us artık dinamik nesneyi göstermiyor, s artık dinamik nesneyi gösteriyor

		cout << *s << endl;	

		delete s;						// delete etmek bizim sorumluluğumuzda

		return 0;
	}

	sınıfın reset üye fonksiyonu bizden yeni bir nesneyi parametre olarak alır. Eskisini delete eder. Artık nesne yeni dinamik nesneyi gösterir duruma gelir. Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us(new string("ankara"));
	
		us.reset(new string("izmir"));

		cout << *us << endl;

		return 0;
	}

	reset fonksiyonuu default argümanla çağırırsak nesnin içerisindeki göstericiye null adres atanır. Tabii yine nesne daha önce gösterdiği dinamik nesneyi delete 
	edecektir. Örneğin:

	unique_ptr<string> us(new string("ankara"));

	us.reset();		// artık us bir nesneyi göstermiyor, eski alan delete edildi

	Nesneyi transfer etmek için release ile reset beraber kullanılmalıdır. Örneğin:

		#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us1(new string("ankara"));
		unique_ptr<string> us2;

		us2.reset(us1.release());		// transfer etmenin normal yöntemi

		cout << *us2 << endl;

		return 0;
	}

	Sınıfın get üye fonksiyonu sınıfın tuttuğu nesne adresini bize verir. get fonksiyonu sahipliği release gibi bırakmamaktadır. Dolayısıyla get kullanırken dikkat ediniz. 
	Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	int main()
	{	
		unique_ptr<string> us(new string("ankara"));
		string *s;

		s = us.get();		// us nesnenin adresini tutmaya devam ediyor 

		cout << *us << endl;

		return 0;
	}

	unique_ptr sınıfının kopya yapıcı fonksiyonu yoktur ancak taşıma yapıcı fonksiyonu vardır. Benzer biçimde sınıfın kopya atamam operatör fonksiyonu yoktur, 
	ancak taşıma atama operatör fonksiyonu vardır. Örneğin:

	#include <iostream>
	#include <string>

	using namespace std;

	unique_ptr<string> foo()
	{
		unique_ptr<string> us(new string("ankara"));

		return us;			// geçerli, çünkü sınıfın taşıma yapıcı fonksiyonu vardır
	}

	int main()
	{	
		unique_ptr<string> us(foo());

		cout << *us << endl;		// ankara
	
		us = unique_ptr<string>(new string("izmir"));		// geçerli, sınıfın taşıma atama operatör fonksiyonu var

		cout << *us << endl;		// izmir

		return 0;
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	uniqe_ptr sınıfının "deleter" denilen ikinci bir şablon parametresi daha vardır. Deleter nesneyi yok ederken çağrılacak fonksiyonu belirtir. Bu şablon parametresi
	default durumda delete operatörü ile silme yapan bir sınıfı argüman olarak almıştır. Programcı isterse silme işlemini kendi belirlediği bir fonksiyonla ya
	da bir sınıfla yapabilir. Tabii böyle bir sınıf yazılırken sınıfın fonksiyon çağırma operatör fonksiyonunun yazılmış olması gerekir. Bu konu izleyen bölümde 
	ele alınacaktır. Aşağıda deleter kullanımına ilişkin bir örnek verilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <memory>

using namespace std;

void foo(int *pi)
{
	cout << "foo called" << endl;

	delete pi;
}

int main()
{
	unique_ptr<int, void (*)(int *)> a(new int, foo);

	*a = 10;

	cout << *a << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf türünden nesne sanki bir fonksiyonmuş gibi fonksiyon çağırma operatörleriyle çağrılma işlemine sokulabilir. Örneğin:

	Sample s;

	s(...);

	Bu durumda sınıfın "fonksiyon çağırma operatör fonksiyonu" denilen operatör fonksiyonu çalıştırılır. Fonksiyon çağırma operatör fonksiyonun geri dönüş değeri 
	ve parametreleri herhangi türden olabilir. Bu durumda örneğin:

	s(....)

	işleminin eşdeğeri:

	s.operator()(....)

	biçimindedir. 

	Bu biçimdeki bir sınıf nesnesinin sanki bir fonksiyon gibi kullanılmasına "fonksiyon nesneleri (function object)" ya da kısaca "functor" denilmektedir. 
	Fonksiyon nesneleri gerçekte bir fonksiyon değil sınıf olduğu için çağrılar arasında durumsal bilgileri tutabilmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class Sample {
public:
	Sample(const char *msg) : m_msg(msg)
	{}

	int operator()(int a, int b);
private:
	string m_msg;
};

int Sample::operator()(int a, int b)
{
	cout << m_msg << endl;

	return a + b;
}

int main()
{
	Sample s("this is a test");
	int result;

	result = s(10, 20);		// result s.opereator()(10, 20);
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyon nesneleri C++ standrat kütüphanesinde algoritmalar tarafından kullanılabilmektedir. Böylece bu algoritmalar durumsal bilgiyi tutabilir duruma 
	gelirler. Örneğin for_each fonksiyonu bir dizilimin her elemanı için bir fonksiyonun çağrılmasını sağlar. Dolayısıyla bir for_each fonksiyonuna çağrılam 
	özelliği olan bir fonksiyon nesnesini verebiliriz. Fonksiyon nesnesi de bu çağrılar arasında durumsal bir bilgi oluşturabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

void foo(int a)
{
	cout << a * a << endl;
}

class Sample {
public:
	Sample()
	{
		m_total = 0;
	}

	void operator()(int a)
	{
		m_total += a;
	}
	int total() const { return m_total; }
private:
	int m_total;
};

int main()
{
	vector<int> v{1, 2, 3, 4, 5};
	Sample s;

	for_each(v.begin(), v.end(), foo);
	for_each(v.begin(), v.end(), s);

	cout << s.total() << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	new ve delete operatörlerinde de bizim istediğimiz bir fonksiyonun çağrılmasını sağlayabiliriz. Böylece programcı tahsisat işlemlerinde araya girebilir. Ya da 
	tahsisat işlemlerinin kendi istediği gibi yapılmasını sağlayabilir.

	new operatör fonksiyonun paramtreik yapısı aşağıdaki gibi olmalıdır:

	void *operator new(size_t size);
	void *operator new[](size_t size);

	Fonksiyonun normal ve köşeli parantezli biçimleri olduğunda dikkat ednizi. delete işleminde çağrılacak operator delete fonksiyonun da parametrik 
	yapısı şöyle olmalıdır:

	void operator delete(void *ptr);
	void operator delete[](void *ptr);

	Aslında standarrt kütüphanede new ve delete işlemleri sırasında çağırlan operator new ve operator delete fonksiyonları bulunmaktadır. Eğer programcı kendisi 
	bu fonksiyonları yazarsa kütüphanedekiler değil de programcının yazdığı fonksiyonlar devreye girer. Eğer programcı bunları yazmasa kütüphanedekiler devreye girer.

	new ve delete operatörlerinin "placement" denilen verisyonları da vardır. placement versiyonlarda new operatörü bir tahsisat yapmaz. Yalnızca programcının verdiği bir adresi
	sınıfın yapıcı fonksiyonunu çağırmak için kullanmaktadır. placement new operatörlerinin ayrı bir gösteri gösterici parametresi daha vardır. Parametrik yapıları şöyledir:

	void *operator new(size_t size, void *ptr);
	void *operator new[](size_t size, void *ptr);

	Placement new operatörü tipik olarak zaten tahsis edilmiş bir alan için sınıfın yapıcı fonksiyonun çağrılması amacıyla kullanılır. Placement new operatörü 
	ile tahsis edilmiş olan alan için delete operatörü çağrılmamlıdır. Çünkü delete operatörü operator delete fonksiyonun çalıştırılmasına yol açar. 
	placement biçime aktarılan adresinin boşaltılması programcının sorumluluğunda olmalıdır Tabii programcı bir sınıf nesnesi söz konusu olduğunda bu nesne için
	yıkıcı fonksiyonun çağrılmasını isteyebilir. Bu durumda yıkıcı fonksiyon açıkça çağrılabilir. Örneğin:

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b) : m_a(a), m_b(b)
	{
		cout << "Sample constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl;s
	}
	int m_a;
	int m_b;
};

int main()
{
	Sample *s;
	char buf[sizeof(Sample)];

	s = new (buf)Sample(10, 20);
	cout << s->m_a << ", " << s->m_b << endl;

	s->~Sample();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Mademki aslında new işlemi ile tahsisatlar operator new fonksiyonlarıyla yapılmaktadır. O halde programcı operator new fonksiyonlrını tahsisat fonksiyonları olarak da
	doğrudan çağırabilir. Aynı durum operator delete için de geçerlidir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

int main()
{
	int *pi;

	pi = static_cast<int *>(operator new[](sizeof(int) * 10));

	for (int i = 0; i < 10; ++i)
		pi[i] = i;

	for (int i = 0; i < 10; ++i)
		cout << pi[i] << endl;

	operator delete[](pi);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir sınıf nesnesi için operator new fonksiyonuyla tahsisat yapılmış sonra bu tahsis edilen alan için placement new yoluyla yapıcı 
	fonksiyon çağrılmıştır. Burada yine yıkıcı fonksiyon programcının kendisi tarafından çağrılmaktadır. Tahsisat operator delete fonksiyonuyla free hale getirilmiştir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	Sample(int a, int b) : m_a(a), m_b(b)
	{
		cout << "Sample constructor" << endl;
	}
	~Sample()
	{
		cout << "destructor" << endl; 
	}
	int m_a;
	int m_b;
};

int main()
{
	Sample *ps;

	ps = static_cast<Sample *>(operator new(sizeof Sample));

	ps = new (ps)Sample(10, 20);

	cout << ps->m_a << ", " << ps->m_b << endl;

	ps->~Sample();

	operator delete(ps);

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Exception mekanizması (exception handling) özellikle nesne yönelimli programlama dillerinde karşılaşılan bir hata kontrol mekanizmasıdır. C gibi klasik prosedürel 
	dillerde hata kontrolleri programcı açısından yorucu olabilmektedir. Programcı başarısız olabilecek her fonksiyonun başarısını kontrol etmek durumunda kalır.
	İç içe fonksiyonlarda iç bir fonksiyonda hata olşuştuğunda programcının içerden dışa doğru başsrıszlıkla geri dönmesi gerekmeketdir. Bu da programın çok kontrollü bir 
	biçimde oluşturulmasına yol açmaktadır. Bu bakımdan da okunabilirliği azaltmaktadır. İşte exception mekanizması bu srunları çözmek amacıyla bulundurulmaktadır. 
	Exception mekanizmasının sağladığı avantajlar şunlardır:

	- Programın daha az kontrollü bir biçimde oluşturulması sağlamak ve okunabilirliği artırmak.
	- Kod ile hata ele alımını biribirinden ayırmak
	- Tam bir hata kontrolü sağlama
	- İç içe çağırmalarda kolay bir hata kontrolü sağlamak"
	- Bir hata oluştuğunda hatanın nedenini de iletmek.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ta exception mekanizması için try, throw ve catch anahtar sözcükleri kullanılmaktadır. try anahtar sözcüğünü bir blok izelemek zorundadır. Buna "try bloğu"
	denir. try bloğu tek başına bulunmaz. try bloğunu bir ya da birden fazla catch bloğu izlemek zorundadır. Örneğin:

	try {
		// try bloğu
	}
	catch ([parametre bildirimi]) {
		//...
	}
	catch ([parametre bildiriiş]) {
		//...
	}
	catch ([parametre bildirimi]) {
		//...
	}

	catch parantezlerinin içerisinde "catch parametresi denilen bir bildirim bulunur. catch parametresi bir tane olmak zorundadır. catch bölümü tek parametreye sahip 
	bir fonksiyoın gibi de düşünülebilir. Bir try bloğunun aynı parametrik yapıya sahip olan birden fazla catch bölümü olamaz. Yani catch parametrelerinin 
	türlerinin farklı olması gerekir. catch parametrelerinde yalnıca tür de belirtilebilir. Örneğin:

	int main()
	{
		try {
			//...
		}
		catch (int) {
			//...

		}
		catch (long) {
			//...
		}

		return 0;
	}

	Programın akışı akış bakımından try bloğunun içerisindeyken bir exception oluşursa akış bir goto işlemi gibi tek hamlede try bloğunun uygun catch bloğuna 
	aktarılır. O catch bloğu çalıştırılır ve akış catch bloklarının sonundan devam eder. Yani catch blokları exception oluştuğunda hatanın ele alınacağı yerlerdir. 

	Exception2ı asıl oluşturan deyim throw deyimidir. throw deyiminin genel biçimi şöyledir:
	
	throw [ifade];

	Programın akışı throw deyimini gördüğünde en son girilen try bloğunun buradaki ifadenin türü ile aynı olan catch bloğuna aktarılır. Bu işlem bir goto 
	gibi yapılmaktadır. Artık akış catch bloğundadır. Yalnızca o catch bloğu çalıştırılır. Diğer catch blokları atlanır ve akış catch bloklarının sonundan devam eder.
	throw ifadesinin değeri catch parametresine atanmaktadır. catch parametreleriş herhangi bir türden olabilirse de genellikle uygun olan onların bir sınıf türünden 
	olmasıdır. Programın akışı catch bloğuna girdikten sınra hiç exception oluşmayabilir. Bu durumda akış try bloğundan çıkar, catch blokları atlanır ve akış 
	catch bloklarının sonundna devam eder. Yani catch blokları "exception oluşursa" devreye girmek üzere bulundurulur.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

void tar(int a)
{
	cout << "tar begins..." << endl;

	if (a < 0)
		throw 10;

	cout << "tar ends..." << endl;
}

void bar(int a)
{
	cout << "bar begins..." << endl;

	tar(a);

	cout << "bar ends..." << endl;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	bar(a);

	cout << "foo ends..." << endl;

}

int main()
{
	cout << "main begins..." << endl;

	try {
		foo(-10);
	}
	catch (int a) {
		cout << "exception caught: int a = " << a << endl;

	}
	catch (long a) {
		cout << "exception caught: long a = " << a << endl;
	}

	cout << "main ends..." << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Derleyici tarafından std::terminate isimli fonksiyon çağrılır. Bu terminate fonksiyonu da kendi içerisinde std::abort isimli fonksiyonu çağırmaktadır. 
	İşte abort fonksiyonu da programı sonlandırır. Programcı set_terminate fonksiyonu ile bu tür durumlarda kendi fonksiyonunun çağrılmasını sağlayabilmektedir. 

	std::terminate --> std::abort

	Yani biz oluşan bir exc eption'ı yakalamazsak programmız sonlandırılmaktadır. 

	throw ifadesiyle catch poarametresinin türünün tam olarak uyuşması gerekir. Overload resolution kuralları burada işletilmemektedir. (Örneğin throw ifadesi 
	char türdense bu int parametreli bir catch bloğu tarafından yakalanamaz.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında throw işlemi temel türlerle değil sınıf türleriyle yapılır. Çünkü sınıflar bilgi tutabilirler. Üstelik de her sınıf farklı tür belirttiğine göre farklı
	sınıf türlerine ilişkin catch blokları bulundurulabilmektedir. Tipik olarak programcı throw işlemini yapmadan önce bir sınıf türünden nesne yaratır. Bu nesnenin
	içini oluşan problemlemli durumları betimleyen bilgilerle doldurur. Sonra bu sınıf ile throw eder. Bunu yakalayn kişi de oluşan exception hakkında bilgileri 
	bu nesneden elde eder. 

	Aşağıdaki örnekte InvalidArgument isimli bir exception sınıfı yazılmıştır. throw işlemş sırasında bu sınıf türünden bir nesne yaratıldığına ve throw işleminin 
	bu nesne yapıldığına dikkat ediniz. Exception yine InvalidArgument parametreli bir catchbloğu tarafından yakalanmıştırç Bu catch bloğu exception nesnesinin içerisindeki 
	bilgileri ekrana (stdout dosyasına) yazdırmıştır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw InvalidArgument("Value must not be negative", 1234);

	cout << "foo ends..." << endl;

}
int main()
{
	try {
		foo(-10);
	}
	catch (InvalidArgument ia) {
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf ile throw işlemi yapılırken önemli bazı noktalar vardır. Bunlar üzerinde duralım:

	1) throw ifadesinin catch parametresine aktarılması doğrudan değil geçici bir nesne yoluyla yapılmaktadır. Örneğin:

	throw ifade;

	Burada önce ifadenin türünden geçici bir nesne yaratılır. Böylece ifade önce geçici bir nesneye atanır. Bu yaratılma ve atama işlemi ilkdeğer verme işlemi gibi yapılmaktadır. 
	Derleyicinin yarattığı bu geçici nesneye "exception nesnesi" de denilmektedir. Eğer ifade bir sınıf türündense bu geçici nesne de aynı sınıf türünden olacaktır. 
	Bu durumda geçici nesne için kopya yapıcı fonksiyonu ya da taşıma yapıcı fonksiyonu çağrılacaktır. Tabii daha önce görmüş 
	olduğumuz"copy elision" kuralları burada da geçerli olacaktır. Örneğin:

	ExceptionTest et;
	...

	throw et;

	Buradaki işlem aslında şununla eşdeğerdir:

	ExceptionTest temp = et;		// kopya yapıcı fonksiyon devreye girer.

	Tabii burada NRVO biçiminde zorunlu olmayan bir "copy elision" devreye girebilecektir. Yani aslında derleyici isterse buradaki et nesnesini zaten geçiçi nesne 
	gibi yaratıp hiç kopya yapıcı fonksiyonu çağırmayabilir. Ancak buaradaki "copy elision" zorunlu değil isteğe bağlıdır. 

	Eğer throw ifadesi geçici bir sınıf nesnesi ise C++17 ile birlikte "copy elision" işleminin zorunlu olarak yapıldığını anımsayınız. Örneğin:

	throw ExceptionTest();		// C++17 ile birlikte geçici nesne için "copy elision" zorunlu

	Burada artık C++17 ile birliklte derleyici zorunlu bir biçimde ExceptionTest() işlemi ile geçici sınıf nesnesini zaten kendi alanında yaratıp 
	kopya yapıcı fonksiyonu hiç çağırmaz. 

	2) Derleyicinin oluşturduğu geçici nesne catch parametresine atanmaktadır. Bu atama işlemi de fonksiyon çağırma gibi yani ilkdeğer verme biçiminde yapılmaktadır. 
	Örneğin:

	ExceptionTest et;
	...

	throw et;
	//...
	catch (ExceptionTest e) {
		//...
	}

	Burada aslında şu biçimde işlemler yapılmaktadır:

	ExceptionTest temp = et;
	ExceptionTest e = et;

	Burada hiç "copy elision" yapaılmazsa catch parametresi için de kopya yapıcı fonksiyonu çalıştırılacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	InvalidArgument ia("Value must not be negative", 1234);

	cout << "foo begins..." << endl;

	if (a < 0)
		throw ia;

	cout << "foo ends..." << endl;

}
int main()
{
	try {
		foo(-10);
	}
	catch (InvalidArgument ia) {
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Sınıf nesneleriyle throw işlemi sırasında kopya yapıcı fonksiyonun çalıştırılmasını elimine etmek için throw edilecek nesnenin geçici nesne biçiminde yaratlması 
	yoluna gidilebilir. Bu durumda C++17 ve sonrasında "copy elision" zorunlu olduğu için derleyicinin yaratacağı geçici nesne için kopya yapıcı fonksiyonu çağrılmayacaktır. 
	(Aslında programcının yarattığı geçici nesne doğrudan derleyicinin yaratacağı geçici exception nesnesi gibi olacaktır.)
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw InvalidArgument("Value must not be negative", 1234);		// C++17 ve sonrasında "mandatory copy elision" uygulanır

	cout << "foo ends..." << endl;

}

int main()
{
	try {
		foo(-10);
	}
	catch (InvalidArgument ia) {
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında C++ programcıları genellikle catch parametresini bir sınıf türünden referans biçiminde alırlar. Bu durumda hiç olmazsa catch parametresi için kopya 
	yapıcı fonksiyonu çalıştırılmaz. C++ standartlarında istisna olarak her ne kadar derleyicinin yarattığı exception nesnesi bir geçici nesne olsa da bunun 
	"sol taraf değeri (lvalue)" belirttiği söylenmiştir. Yani bu durumda catch parametresinin const bir sol taraf değeri referansı olması gerekmez. Ancak tabii
	genel olarak programcılar bu referansı const yaparlar. Burada derleyicinin yaratacağı geçici nesne catch parametresindeki referansın ömrü kadar olacaktır. Yani
	catch bloğu bittiğinde bu geçici nesne yok edilecektir. 

	Genellikle exeption'alrın ele alınması eğer throw ifadesi bir sınıf türndense bu biçimde yapılmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw InvalidArgument("Value must not be negative", 1234);		// C++17 ve sonrasında "mandatory copy elision" uygulanır

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const InvalidArgument &ia) {			// bu referans istenirse const olmayabilir
		cout << ia << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen programcılar fırlatacakları sınıf nesnesini heap'te new operatör ile tahsis edip onunla throw işlemi yaparlar. Bu durumda tabii derleyicinin yaratacağı geçici
	exception nesnesi bir gösteri olur ve kopya yapıcı fonksiyonun çağrılması söz konusu olmaz. Bu durumda catch parametrerisi de aynı sınıf türündne bir gösterici olmalıdır. 
	Ancak bu yakalama biçiminde nesnenin heap'ten delete edilemsi exception'ı yakalayan tarafından yapılmalıdır. Bu biçimde her ne kadar kopya yağıcı fonksiyonlar 
	çağrılmıyorsa da new ve delete işlemi de göreli bir zaman kaybına yol açmaktadır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>

using namespace std;

class InvalidArgument {
public:
	InvalidArgument(const char *msg, int error_code) : m_msg(msg), m_error_code(error_code)
	{
		cout << "constructor called" << endl;
	}
	InvalidArgument(const InvalidArgument &ia) : m_msg(ia.m_msg), m_error_code(ia.m_error_code)
	{
		cout << "copy constructor called" << endl;
	}
	friend ostream &operator <<(ostream &os, const InvalidArgument &ia);
	string msg() const { return m_msg; }
	
	int error_code() const { return m_error_code; }
private:
	string m_msg;
	int m_error_code;
};

ostream &operator <<(ostream &os, const InvalidArgument &ia)
{
	os << ia.m_msg << " (" << ia.m_error_code << ')';

	return os;
}

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw new InvalidArgument("Value must not be negative", 1234);		

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const InvalidArgument *pia) {			
		cout << *pia << endl;

		delete pia;				// delete etme sorumluluğu exception'ı yakalayan koda ait
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında programcının throw etmek için kendi exception sınıflarını yazmasına gerek kalmayabilmektedir. Çünkü C++'ın standart kütüphanesinde zaten çeşitli sorunlu durumlar
	için oluşturulmuş olan hazır exception sınıfları bulunmaktadır. Standart kütüphanedeki bu exception sınıflarının hepsi en tepedeki "exception" isimli bir sınıftan 
	türetilmiştir. Bu exception sınıfından temelde iki önemli türemiş kol ayrılmaktadır: logic_error ve runtime_error. logic_error sınıfı programdaki birtakım ön koşulların
	ihlal edilmesi durumu için düşünülmüştür. runtime_error ise programın çalışması sırasında karşılaşılan sorunlar için oluşturulmuştur. Bu logic_error ve runtime_error
	sınıflarından da sınıflar türetilmiştir. Örneğin invalid_argument isimli sınıf tipik olarak programcılar tarafından bir fonksiyonun argümanının yanlış bir biçimde 
	geçilmesi durumu için kullanılmaktadır. out_of_range ise belli bir aralıkta olması gereken değerin o aralıkta olmaması durumlarında kullanılmaktadır. 

	En tepedeki exception sınıfının what isimli sanal const char * türüyle geri dönen (yani bir yazının adresiyle geri dönen) bir üye fonksiyonu vardır. Bu sanal 
	fonksiyon türemiş sınıflarda override edilmiştir. exception sınıfından türetilmiş olan sınıfların hepsinin bir error yazısını parametre olarak alan bir yapıcı 
	fonksiyonu bulunmaktadır. Zaten bu what fonksiyonları da bu yapıcı fonksiyon ile verilen yazıyı bize geri vermektdir. 


	Aşağıdaki örnekte foo fonksiyonunun parametresi negatif olmamalıdır. foo fonksiyonunu yazan kişi işin başında bu parametreyi kontorl etmiş, eğer parametre negatif ise
	invalid_argument nesnesi ile hata mesajını da belirterek thwor işlemi yapmıştır. Fonksiyon çağrısında da exception ele alınmıştır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw invalid_argument("value must not be negative!");

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const invalid_argument &ia) {			
		cout << ia.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Standart exception sınıfları aslında C++'ın kendi standart kütüphanesi tarafından da kullanılmaktadır. Örneğin new operatör tahsisatı yapamazsa bad_alloc isimli
	exception sınıfından türetilmiş olan bir sınıf nesnesi ile throw eder. Ya da örneğin string sınıfında string içeriisndeki belli indekste bulunan karaktere erişme 
	işlemi at fonksiyonuyla yapılıyorsa bu at fonksiyonu erişlen indeks geçersizse out_of_range türüyle throw etmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>
#include <string>

using namespace std;

int main()
{
	string s{"ankara"};
	char ch;

	try {
		ch = s.at(10);			// sınır kontrolü yapılıyor, sınır ihlalinde std::out_of_range ile throw edilmektedir. 
	}
	catch (const out_of_range &oor) {
		cout << oor.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Programcı C++'ın standart excepion sınıflarını hiç kullanmayıp kendi exception sınıflarını da yazabilir. Aslında Qt gibi, MFC gibi pek çok yaygın 
	sınıf kütüphanesi hiç C++'ın standart exception sınıflarını kullanmadan kendi exception sınıflarını tanımlayarak throw işlemini bunlarla yapmaktadır. 

	Tabii programcı C++'ın standart exception sınıflarını kullanırken o sınıflardan türetme yaparak da kendi exception sınıflarını oluşturabilir. Aşağıda örnekte
	logic_error sınıfınından NegativeERror isimli bir exception sınıfı türetilmiş ve kodda bu sınıf kullanılmıştır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>
#include <string>

using namespace std;

class NegativeError : logic_error {
public:
	NegativeError(const char *msg, int errcode) : logic_error(nullptr), m_msg(msg), m_errcode(errcode)
	{}

	const char *what() const noexcept override
	{
		string err("Error: " + m_msg + ", Error Code: " + to_string(m_errcode));

		return err.c_str();
	}
private:
	string m_msg;
	int m_errcode;

};

void foo(int a)
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw NegativeError("value must not be negative!", 123);

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(-10);
	}
	catch (const NegativeError &ia) {			
		cout << ia.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Taban sınıfa ve türemiş sınıfa ilişkin catch blokları irlikte bulundurulabilir. Bu durumda türemiş sınıfa ilişkin catch bloğunun taban sınıfa ilişkin catch 
	bloğunun yukarısında konumlandırılması zorunludur. Böylece türemiş sınıf türünden bir nesne ile throw işlemi yapıldığında bu türemiş sınıf parametreli catch bloğu 
	tarafından taban sınıf türünden bir nesne ile throw yapıldığında bu da taban sınıf türünden catch bloğu tarafından yakalanır. Örneğin B sınıfı A sınıfından türetilmiş olsum:

	try {
		//...
	}
	catch (B &r) {
		//...
	}
	catch (A &r) {
		//...
	}

	Burada catch bloklarının sırası böyle olmak zorundadır.Çünkü catch blokları yukarıdan aşağıya sırasıyla taranmaktadır. Eğer taban ısının catch bloğu yukarıya 
	yazılabilseydi tüm exception'ları bu catch bloğu yakalardı.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bazen bir kod parçasında çok değişik türlerle throw işlemi yapılabilmektedir. Bu durumda bu türlerin hepsi için catch bloklarının bulundurulması yorucu bir işlemdir. 
	İşte programcılar bu nedenle exception sınıflarını bir taban sınıftan türetilmiş sınıflar biçiminde oluşturlar ve yalnızca taban sınıfa ilişkin catch bloğu ile exception'ı yakalayabilirler. 

	Aşağıda bu duruma bir örnek verilmiştir. Standart exception sınıflarındaki what fonksiyonunun sanal bir fonksiyon olduğunu ve türemiş sınıflarda override 
	edildiğini anımsayınız. Dolayısıyla aslında çağrılan what fonksiyonları çokbiçimli mekanizmadan dolayı exception nesnesine ilişkin sınıfın fonksiyonu olacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void foo(int size)
{
	if (size < 0)
		throw invalid_argument("size must not be negative!");
	if (size > 100)
		throw range_error("parameter is too big");
	if (size == 0) 
		throw length_error("size must not be zero");

	cout << "success" << endl;
}

int main()
{
	int size;

	cout << "Bir değer giriniz:";
	cin >> size;

	try {
		foo(size);
	}
	catch (const exception &r) {
		cout << r.what() << endl;		// what sanal bir fonksiyon
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Exception mekanizmasında diğer bir catch bloğu da "ellipsis (...)" parametreli catch bloğudur. Bu catch bloğu tüm exception'ları yakalar (yani "catch all" 
	gibi bir anlamı vardır). Ancak eğer ellipsis parametreli catch bloğu yerleştirileckse catch bloklarının sonuna yerleştirilmelidir. Böylece eğer exception
	daha yukarıdaki catch blokları tarafından yakalanmamışsa kesinlikle ellipsis parametreli catch bloğu tarafından yakalanacaktır. Tabii exception ellipsis 
	parametreli catch bloğu tarafından yakalandığında biz artık excepion nesnesini elde edemeyiz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void foo(int a) 
{
	cout << "foo begins..." << endl;

	if (a < 0)
		throw invalid_argument("value must be positive or zero");

	if (a > 100)
		throw range_error("parameter is too big");

	cout << "foo ends..." << endl;
}

int main()
{
	try {
		foo(110);
	}
	
	catch (const invalid_argument &r) {
		cout << "exception caught: " << r.what() << endl;
	}
	catch (...) {			// catch all
		cout << "another error occurred!" << endl;
	}
	
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta özel bir throw deyimi de yanında ifade olmadan throw; biçiminde kullanılan throw deyimidir. Buna "rethow" denilmektedir. Bu biçimdeki throw deyimleri ancak
	catch bloğu içerisinde kullanılabilir. Bu biçimdeki throw deyimleri "exception'ın orijinali hangi nesne ile fırlatılmışsa aynı nesne ile onu yeniden fırlatma" anlamına gelmektedir. Örneğin:

	try {
		foo(-10);
	}
	catch (exception &r) {
		//...
		throw;
	}

	Burada exception yakalandığında birtakım işlemler yapılıp rethow uygulanmıştır. Bu rethow işlemi orijinal exception nesnesi ne ise onunla yeniden throw etmek anlamına 
	gelir. Böylece exception bu try bloğunu akş bakımından içeren başka bir catch bloğu tarafındna yakalanabilecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Akış bir fonksiyonda ilerlerken bir throw işlemi oluşursa akış tamamen başka bir yere aktarılabilmektedir. Bu durum o fonksiyon içeisinde yapılan tahsisatlar ve
	yaratılan sınıf nesneleri için önemlidir. Çünkü throw işlemi yapılmadan önce çeşitli sınıf nesneleri yaratılmış olabilir. Bu sınıf nesnelerinin yıkıcı fonksiyonlarında 
	çeşitli boşaltım işlemleri yapılmış olabilir. İşte bu olumsuzlukları ortadan kaldırmak için "stack unwinding" denilen bir mekanizma bulunmaktadır. Bir throw işlemi
	gerçekleştiğinde o zaman kadar yaratılmış olan yerel sınıf nesneleri için yıkıcı fonksiyonlar ters sırada çağrılmaktadır. Böylece kaynaklar throw işlemi sırasında 
	başarılı bir biçimde boşaltılmış olur. Tabii bu mekanizmasının derleyici tarafından sağlanmasının birtakım zamansal maaliyetleri vardır. Bu nedenle bazı kritik uygulamalarda 
	programcılar exception mekanizmasını hiç kullanmak istemeyebilirler. 

	throw işlemi oluştuğunda yalnızca try bloğuna girildikten sonra yaratılmı ve yapıcı fonksiyonu tam olarak çalıştırılmış nesneler için yıkıcı fonksiyonlar ters sırada 
	çalıştırılmaktadır. new ile dinamik bir biçimde yaratılmış nesneler yıkıcı fonksiyonlar çalıştırılmaz ve bu nesneler için delete işlemi otomatik olarak uygulanmaz. 
	Bu nesnelerin boşaltımından programcı sorumludur. Bir yapıcı fonksiyonun içerisinde throw işlemi uygulanırsa o zamana kadar yapıcı fonksiyonu tam olarak çalıştırılmış
	nesneler ve alt nesneler için yıkıcı fonksiyon çalıştırılmaktadır.

	Aşağıdaki örnek "stack unwinding" mekanizmasını açıklamaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

class Sample {
public:
	Sample(int val) : m_val(val)
	{}
	~Sample()
	{
		cout << "destructor: " << m_val << endl;
	}
private:
	int m_val;
};

void foo(int a)
{
	Sample x(40), y(50);
	Sample *ps;

	ps = new Sample(60);		// dikkat bellek sızıntısı oluşacak!

	if (a < 0)
		throw invalid_argument("Value must not be negative!");
}

int main()
{
	Sample a(10);

	try {
		Sample b(20);
		Sample c(30);

		foo(-1);
	}

	catch (const exception &r) {
		cout << r.what() << endl;		
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    throw işlemi yapıldığında new ile dinamik biçimde yaratılmış sınıf nesneleri için yıkıcı fonksiyonların çağrılmadığına dikkat ediniz. O halde programcının throw öncesinde
	bu dinamik nesneleri delete etmesi gerekir. Ancak bunun takip edilmesi kolay değildir. İşte bu nedenden dolayı "smart pointer" sınıfları bellek sızıntısını engellemek
	amacıyla kullanılabilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>
#include <memory>

using namespace std;

class Sample {
public:
	Sample(int val) : m_val(val)
	{}
	~Sample()
	{
		cout << "destructor: " << m_val << endl;
	}
private:
	int m_val;
};

void foo(int a)
{
	Sample x(40), y(50);

	unique_ptr<Sample> ps(new Sample(60));		

	if (a < 0)
		throw invalid_argument("Value must not be negative!");
}

int main()
{
	Sample a(10);

	try {
		Sample b(20);
		Sample c(30);

		foo(-1);
	}

	catch (const exception &r) {
		cout << r.what() << endl;		
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ta "exception specification" denilen özellik bir fonksiyonun hangi exception'larla dışarıya throw yapabileceğini belirtmek kullanılıyordu. Örneğin:
	
	void foo(int a) throw(std::invalid_argument)
	{
		//...
	}

	Buarada foo fonksiyonu yalnızca dışarıya invalid_argument sınıfı ile throw yapabilmektedir. Exception specification ilk standartlardan beri bulunan bir özellikse de 
	zamanla "faydasının zararından az olduğu" fikri belirginleşmiştir. Bu nedenler C++11'de "deprecated" yapılmış ve C++17'de de kaldırılmıştır. Exception specification
	Java'da yoğun biçimde kullanılmaktadır. C++11 ile birlikte exception specification özelliğinin çok kısıtlı bir biçimi olan noexcept belirleyicisi dile eklenmiştir. 
	noexcept belirleyicisi "fonksiyonun bir tür ile throw etmeyeceğini" anlatmaktadır. Tabii eğer fonksiyonda bu belirleyici yoksa bu durum "fonksiyonun herhangi bir türle
	throw edebileceği" anlamına gelir. noexcept belirleyicisi fonksiyonun parametre parantezinden sonra yerleştirilir. Örneğin:

	void foo(int a) noexcept
	{
		//...
	}

	Eğer noexcept belirleyicisi kullanıldığı halde fonksiyonun dışına throw işlemi yapılırsa bu durumda derleyici tarafından std::unexpected isimli fonksiyon çağrılır. 
	Bı fonksiyon kendi içerisinde std::terminate fonksiyonunu bu da std::abort fonksiyonu çağıracaktır:

	unexpected --> terminate --> abort

	Yani kısaca biz noexcept ile verdiğimiz sözü tutmazsak programımız abort ile sonlandırılır. noexcept anahtar sözcüğü hem prototipte hem de
	tanımlama sırasında bulundurulmak zorundadır. Ancak overload bakımından fonksiyonun imzasını değiştirmez.

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <exception>

using namespace std;

void bar(int a)
{
	if (a < 0)
		throw invalid_argument("parameter is invalid");
}

void foo(int a) noexcept
{
	bar(a);		// std::unexpected --> std::terminate --> std::abort
}

int main()
{
	try {
		foo(-10);
	}
	catch (const invalid_argument &r) {
		cout << "exception caught: " << r.what() << endl;
	}

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	noexcept belirleyicisinde parantezler içerisinde true ve false sabitleri  kullanılabilmektedir. Örneğin:

	void foo() noexcept(true);

	Buradaki true fonksiyonun hiçbir biçimde dışarıya exception fırlatmayacağı anlamına gelir. Zaten default durum da böyledir. Dolayısıyla aşağıdaki iki bildirim 
	eşdeğerdir:

	void foo() noexcept;
	void foo() noexcept(true);

	false ise fonksiyonun dışarıya exception throw edebileceğini belirtir. Dolayısıyla aşağıdaki iki bildirim de eşdeğerdir:

	void foo() noexcept(false);
	void foo();

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon çağrıldığında fonksiyon içerisinde bir exception oluşursa akış throw işlemi ile birlikte fonksiyondan aniden çıkacaktır. Bu durumda fonksiyon içerisinde
	o ona kadar yapılmış olan tahsisatlar boşaltılamayabilir. Bu duruma fonksiyonun "exception güvenliliği (exception safety)" denilmektedir. Örneğin:

	try {
		foo();		// foo'da exception oluşursa sızıntı oluşur mu?
	}
	catch (exception &e) {
		//...
	}

	Bir fonksiyon için dört tür exception güvenliği söz konusu olabilir. Bunlar kötüden iyiye doğru aşağıdaki gibi sıralanabilirler:

	1) No Guarantee: Böyle fonksiyonlarda exception oluşursa bellek sızıntısı (memory leak) ya da kaynak sızıntısı (resource leak) oluşabilir. Şüphesiz böyle 
	fonksiyonların yazılmaması gerekir. Tabii bazen böyle fonksiyonların bir biçimde yazılması zorunlu olabilmektedir. Örneğin

	void foo(int a)
	{
		int *pi, *pc;

		pi = new int[10];
		pc = new char[100];		// Tahsisat yapılamazsa std::bad_alloc excepton'ı oluşabilir

		// ...

		delete[] pi;
	}

	2) Basic Guarantee: Burada ilgili fonksiyon içerisinde bir exception oluştuğunda "bellek sızıntısı" ya da "kaynak sızıntısı" olmayacağı garanti edilir. Ancak
	bu bir üye fonksiyon ise ilgili sınıf nesnesinin durumu programcının fonksiyonu çağırmadna önceki durumuyla aynı olmayabilir. Fakat nesne "geçerli" ve "destruct"
	edilebilir bir biçimde bırakılmalıdır. Örneğin:

	Sample s;
	//...
	try {
		s.foo();
	}
	catch (...) {
		//...
	}

	Burada eğer "basic guarantee" söz konusu ise foo fonksiyonunun içersinde exception oluşursa herhangi bir sızıntı olmamalıdır. Ayrıca buradaki s nesnesi 
	foo fonksiyonu çağrılmadan önceki durumunda olmayabilir ancak "destruct" edilebilir bir durumda olmalıdır. Yani "destructor" çağrıldığında nesne geri bırakım
	işlemlerini yapabilmelidir. Basic guarantee sağlayabilmek için programcı koduna dikkat etmelidir. Bir problem karşısında geri bırakımı yapıp rethow işlemi uygulayabilir. 
	Örneğin:

	void foo()
	{
		// kaynak tahsisatı yapılıyor olsun

		try {
			// exception'a yol açabilecek başka işlemler
		}
		catch (...) {
			// kaynaklar boşaltılıyor
			throw;
		}
		//...
	}

	Basic guarantee oluşturmak için dinamik bellek tahsisatlarında bellek sızıntısına karşı "smart pointer" sınıfları da kullanılabilir. Örneğin:

	void foo(int a)
	{
		//...

		unique_ptr<int> pi(new int[10]);
		unique_ptr<char> pi(new char[100]);		// artık burada exception oluşursa stack unwinding sırasında pi tahsisatı boşaltılacak
				
		// ...
	}

	3) Strong Guarantee: Burada bir üye fonksiyon çağrıldığında eğer üye fonksiyonun içerisinde exception oluşmuşsa akış fonksyondan çıktığında nesnenin durumu 
	(yani onun içerisindeki veri elemanlarının değerleri) bu üye fonksiyon çağrılmadan önceki değerlerdedir. Başka bir deyişle üye fonksiyonda exception oluşması
	nesne üzerinde hiçbir etki yaratmaz. Tabii sınızntı vs. gibi durumlar da oluşmaz. Örneğin.

	Sample s;
	//...
	try {
		s.foo();
	}
	catch (...) {
		s'in durumu foo'nun çağrılmadan önceki durumu ile tamamen aynıdır. 
		//...
	}

	Tabii "strong guarantee" oluşturmak hem zahmetli hem de zordur. C++'ın standart kütüphanesindeki pen çok sınıfın üye fonksiyonu "strong guarantee" oluşturmaktadır. Örneğin
	vektörde biz push_back yaptıpımızda bir exception oluşursa vector nesnemiz push_back yapmadan önceki durumla aynı durımda olur. Yani psuh_back fonksiyonu bize "strong guarantee"
	vermektedir. 

	4) No Throw Guarantee: Burada fonksiyon zaten dışarıya throw işlemi yapmayacağına ilişkin söz vermiştir. Dolayısıyla bir exception fırlatmayacaktır. O zaman 
	olabilecek en iyi durum budur. Böyle fonksiyonların programcılar tarafından noexcept belirleyicisi ile belirtilmsi iyi bir tekniktir. Örneğin:

	void foo() noexcept;

	Burada artık biz bu fonksiyonu zaten try-cath içerisinde çağırmak zorunda da değiliz. Çünkü fonksiyon zaten dışarıya throw işlemi yapmayacaktır. Dolaısıyla da bir 
	sızıntı söz konusu olmaz. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Daha önce yazmış olduğumuz String sınıfı aslında exception güvenliliği bakımından sorunluydu. O sınıfın atama operatör fonksiyonları herhangi bir exception
	garantisi vermiyordu. Ancak diğer fonksiyonlarda bir problem yoktu. Eski atama operatör fonksiyonları şöyle yazIlmıştı:

	String &String::operator =(const String &r)
	{
		if (this == &r)		/* nesne kendisine atanmış mı? */
			return *this;

		delete[] m_str;

		m_len = r.m_len;
		m_str = new char[m_len + 1];
		strcpy(m_str, r.m_str);

		return *this;
	}

	String &String::operator =(const char *str)
	{
		delete[] m_str;

		m_len = strlen(str);
		m_str = new char[m_len + 1];
		strcpy(m_str, str);

		return *this;
	}

	String &String::operator =(String &&r)
	{
		delete m_str;

		m_len = r.m_len;
		m_str = r.m_str;

		r.m_str = nullptr;

		return *this;
	}

	Bu fonksiyonlar yukarıdaki haliyle exception güveli değildir. Yani "basic guarantee" bile vermemektedir. Burada new işlemi başarısız olursa sızıntı oluşmaz ancak
	nesne kararlı bir durumda kalmamaktadır. "strong guarantee" nesnenin işlem öncesindeki durum ile aynı durumda olması anlamına gelmekteydi. Yukarıdaki atama operatör fonksiyonlarını
	"strong guarantee" verecek biçimde düzenlemenin en kolay yolu "copy and swap idiom" denilen kalıbın uygulanmasıdır. Bu kalıpta önce yerel bir nesne kopya yapıcı fonksiyonu ile
	yaratılır sonra yerel nesne ile asıl nesnenin veri elemanları yer değiştirilir. Bunun için genellikle sınıfta swap isimli bir üye fonksiyon bulunduruşur. Örneğin String 
	sınıfı için bu swap fonksiyonu şöyle olabilir:

	void String::swap(String &r) noexcept
	{
		std::swap(m_str, r.m_str);
		std::swap(m_len, r.m_len);
	}

	fonksiyonundaki içerisinde swap fonksiyonları standart kütüphenedeki template tabanlı swap fonksiyonlarıdır. ""copy  and swap idiom" aşağıdaki gibi uygulanabilir:

	String &String::operator =(const String &r)
	{
		String temp(r);		// exception safe

		swap(temp);
	
		return *this;
	}

	String &String::operator =(const char *str)
	{
		String temp(str);		// exception safe

		swap(temp);

		return *this;
	}

	String &String::operator =(String &&r) noexcept
	{
		swap(r);

		return *this;
	}

	Pekiyi bu fonksiyonlar neden "strong guarantee" vermektedir. Adım adım inceleyeim:

	1) Eğer yerel nesne üzerindeki kopya yapıcı fonksiyonunda except,ion oluşursa henüz asıl nesnede bir değişiklik yapılmadığı için "strong guarantee" bozulmaz.
	2) swap işlemi asıl nesneyle yerel nesnenin elemanlarını yer değiştirmektedir. Dolayısıyla swao zaten noexcept bir fonksiyondur. Yani "no throw guarantee" vermektedir. 
	3) return *this işleminde de artık exception oluşturacak bir durum yoktur. 

	Aşağıdaki kullanıma dikkat ediniz. 

	int main()
	{
		String s{"ankara"};
		String k;

		cout << s << endl;

		try {
			k = s;
		}
		catch (...) {
			//...
		}
		cout << k << endl;

		return 0;
	}

	Burada k = s işleminde bir exception oluşsa bile arık k'da hiçbir değişiklik olmayacaktır. Yani biz k'nın önceki hali ne ise onu öyle kullanmaya devam edebiliriz. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Özetle programcı bir global fonksiyon ya da üye fonksiyon yazarken satır satır hangi noktalarda exception oluşabileceğini dikka almalıdır. Mümkünse 
	fonksiyonlarınıza "string guarantee" vermeye çalışın. Mümkün değilse ya da efektif değilse o zaman "basic guarantee" vermeye çalışın. Zaten throw etmeyecek 
	fonksiyonlarda mutlaka noexcept belirleyicisini kullanın.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazı fonksiyonlar değişik türler için içi aynı olacak biçimde yeniden yazılmak zorundadır. Örneğin int bir dizinin en büyük elemanına geri dönen bir fonksiyon 
	yazmak isteyelim:

	int getmax(const int *pi, size_t size)
	{
		int max = pi[0];

		for (size_t i = 1; i < size; ++i)
			if (pi[i] > max)
				max = pi[i];

		return max;
	}

	Şimdi biz double bir diziin en büyük elemanını elde etmek istesek aynı fonksiyondan double için bir tane daha yazmak zorundayız:

	double getmax(const double *pi, size_t size)
	{
		double max = pi[0];

		for (size_t i = 1; i < size; ++i)
			if (pi[i] > max)
				max = pi[i];

		return max;
	}

	Görüldüğü gibi burada iki fonksiyonun içi tamamen ayndır. Yalnızca tür farklılığı yüzünden programcı yeniden aynı fonksiyondan yazmak zorunda kalmıştır. 
	Tabii aslında bazen tek bir fonksiyn farklı türlerele çalışabilir hale de getirilebilir. Ancak bu tür fonksiyonlar "kullanımı zor" ve "yavaş" olma eğilimindedir. Örneğin:

	void *getmax(const void *pi, size_t size, size_t width, int (*cmp)(const void *, const void *))
	{
		const void *max = pi;
		const const char *pc = reinterpret_cast<const char *>(pi);

		for (size_t i = 1; i < size; ++i)
			if (cmp(pc + (i * width), max) > 0)
				max = pc + (i * width);

		return const_cast<void *>(max);
	}

	İşte şablon (template) "içi aynı olan fakat parametrik türleri" farklı olan fonksiyonların ve sınıfların kullanılan her tür için yazılmasını 
	kolaylaştırmak amacıyla oluşturulmuş bir mekanizmadır. 

	Şablon mekanizmasının Java ve C# gibi dillerdeki mantıksal benzerine "generic" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Şablon mekanizması ikiye ayrılmaktadır:

	1) Fonksiyon şablonları (function templates)
	2) Sınıf şablonları (class templates)

	Fonksiyon şablonları tek bir fonksiyonun şablon olarak yazılması anlamına gelir. Sınıf şablonları ise bir sınıfın hepsinin şablon olarak yazılması anlamına gelir. 
	Biz önce fonksiyon şablonları üzerinde sonra sınıf şablonları üzerinde duracağız. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Fonksiyon şablonlarnda fonksiyon bildiriminde önce "şablon bildirim" yapılmak zorundadır. Şablon bildirimi template anahtar sözcüğünden sonr açısal parantezler 
	içerisinde şablon parametreleri belirtilerek yapılır. Şablon parametreleri aslında tür belirten parametrelerdir (tür belirtmeyen şablon parametreleri de olabilir). 
	Tür belirten şablon parametrelerinden önce "class" ya da "typename" anahtar sözcükleri getirilir. Bu iki anahtar sözcük arasında hiçbir farklılık ypktur. Örneğin:

	template <class T>
	T getmax(const T *p, size_t size)
	{
		//...
	}

	Burada template parametresinin ismi T'dir. template parametreleri herhangi bir biçimde isimlendirilebilir. Ancak genellikle programcılar tek karakterli T, K
	gibi harfleri tercih etmektedir. Templatae parametrelerinden önce class anahtar sözcüğü yerine typename anahtar sözcüğü de kullanılabilirdi. Örneğin:

	template <typename T>
	T getmax(const T *p, size_t size)
	{
		//...
	}

	Buradaki T template parametresi bir tür belirtmektedir. Yani programcı fonksiyonunu sanki T diye semblik bir türe dayalı olarak yazmaktadır. Bu T ismi tür belirten
	bir sözcük olarak fonksiyonun şablonunun her yerinde ekullanılabilir. Örneğin:

	template <class T>
	T getmax(const T *p, size_t size)
	{
		T max = p[0];

		for (size_t i = 1; i < size; ++i)
			if (max < p[i])
				max = p[i];

		return max;
	}

	Artık bir fonksiyon şablonu yazıldığında bu fonksiyon şablonu çağrılınca derleyici çağrılma ifadeisndeki argümanların türlerine bakarak template parametresinin (örneğimizde T)
	hangi tür olması gerektiğini anlamaya çalışır. Template parametresinin türünü çağrılma ifadesine göre tespit edilmesi sürecine "template argument deduction" denilmektedir. 
	Derleyici bu tespiti yaptıktan sonra gerçekten bu şablona bakarak ilgili tür için fonksiyonu yazar. Derleyicinin şablona bakarak ilgili fonksiyonu türe dayalı oalrak yazmasına ise
	"template instantiation" denilmektedir. Biz "instantiation" sözcüğü yerine "template fonksiyonun açılması" deyieceğiz. Örneğin:

	int a[5] = {34, 23, 12, 67, 43};
	
	int result;
	
	result2 = getmax(a, 5);

	Burada derleyici getmax fonksiyonun birinci argümanınınint * türündeb olduğunu görür. Bu durumda T türünün int olması gerektiğini anlar ve template fonksiyonu bizim 
	için aşağıdaki gibi açar (instantiate eder):

	int getmax(const int *p, size_t size)
	{
		int max = p[0];

		for (size_t i = 1; i < size; ++i)
			if (max < p[i])
				max = p[i];

		return max;
	}

	Derleyici her farklı tür için bu açımı kendisi yapmaktadır. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <class T>
T getmax(const T *p, size_t size)
{
	T max = p[0];

	for (size_t i = 1; i < size; ++i)
		if (max < p[i])
			max = p[i];

	return max;
}

int main()
{
	int a[5] = {34, 23, 12, 67, 43};
	double b[5] = {34.2, 45.4, 65.6, 21.3, 12.5};
	
	int result1;
	double result2;

	result1 = getmax(a, 5);
	cout << result1 << endl;

	result2 = getmax(b, 5);
	cout << result2 << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Örneğin iki nesnenin içerisindeki değeir yer değiştiren swap isimli bir fonksiyon yazılabilir. Zaten standart kütüphanede böyle bir fonksiyon vardır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

template <typename T>
void swap(T &a, T &b)
{
	T temp(a);

	a = b;
	b = temp;
}

int main()
{
	int a = 10, b = 20;
	double x = 12.3, y = 2.4;

	swap(a, b);
	std::cout << "a = " << a << ", b = " << b << std::endl;

	swap(x, y);
	std::cout << "x = " << x << ", y = " << y << std::endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Örneğin bir değerin mutlak değerine geri dönen bir fonksiyon template olarak yazılabilir 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T abs(T a)
{
	if (a < 0)
		return -a;

	return a;
}

int main()
{
	int a = -2;
	int result;

	result = abs(a);	
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyon şablonları derleyici tarafındna her derleme işleminde görülmelidir. Bu ndenle fonksiyon şablonları kütüphaneler içerisine yerleştirilemez. Onların 
	tipik olarak başlıkdosyalarına yerleştirilmesi uygun olur. Böylece derleyici derleme işlemi sırasında onların kodunu görecektir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T abs(T a)
{
	if (a < 0)
		return -a;

	return a;
}

int main()
{
	int a = -2;
	int result;

	result = abs(a);	
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    C++'ın standart kütüphanesi tamamen template esasına dayandırılmıştır. Orada pek çok hazır fonksiyon ve sınıf bulunmaktadır. Bu hazır fonksiyonlar ve sınıflar 
	"iteratör (iterator)" denilen bir kavram kullanılarak gerçekleştirilmiştir. İteratör "bir gösterici gibi davranan gerçek bir gösterici ya da sınıftır". 
	Standart kütüphanedeki fonksiyon şablonları bir dizi alacakları zaman onun başlangıç ve bitiş bitiş iteratörlerini bizden isterler. Başlangıç iteratörü dizinin ilk 
	elemanın adresidir. Ancak eğer bir sınıf söz konusuysa bu iteratör bir nesne durumunda olabilir. Bitiş iteratörü dizinin son elemanından sonraki elemanın adresidir. 
	Eğer biz C++'ın standart kütüphanesindeki fonksiyon şablonlarını dizi için kullanacaksak başlangıç iteratörünü dizinin başlangıç adresi olarak bitiş iteratörünü dizinin 
	son elemanından sonraki adres olarak vermeliyiz. Bu fonksiyonlar itertaörleri ilerleterek veri yapısının tüm elemanlarına erişirler. Örneğin <algorithm> başlık dosyasındaki
	copy isimli fonksiyon şablonu bizden bir dizinin ilk elemanın ve sondan bir sonraki elemanının adresini alarak oradaki tüm elemanları başka bir adresten itibaren kopyalar. 
	Bu fonksiyon aşağıdaki gibi yazılmıştır:
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

namespace CSD 
{
	template<class InputIt, class OutputIt>
	OutputIt copy(InputIt first, InputIt last, OutputIt dest)
	{
		while (first != last) {
			*dest = *first;
			++first;
			++dest;
		}

		return dest;
	}
}

int main()
{
	int a[5] = {1, 2, 3, 4, 5};
	int b[5];

	CSD::copy(a, a + 5, b);

	for (int x : a)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Örneğin standart kütüphanedeki find fonksiyonu türden bağımsız arama yapan genel bir fonksiyondur. Bizden dizinin ilk elemanının ve son elemanından sonraki elemanın adresini 
	ve aranacak değeri parametre olarak alır. Eğer değeri dizide bulursa bulduğu yerin adresiyle (iteratörüyle) geri döner. Bulamazsa son elemandan sonraki elemanın adresiyle 
	(yani end iteratörüyle) geri dönmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	double a[5] = {3, 5, 9, 2, 6};
	double *result;

	result = find(a, a + 5, 9);

	if (result == a + 5)
		cout << "cannot find item" << endl;
	else
		cout << "found: " << *result << endl;


	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin sort isimli fonksiyon şablosnu yine bizden bir dizinin ilk elemanın ve son elemanından sonraki elemanın adresini alarak o diziyi sıraya dizmektedir. 
	Biz bu fonksion şablonu yoluyla aslında her türden diziyi sıraya dizebiliriz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	double a[5] = {3, 5, 9, 2, 6};
	
	sort(a, a + 5);

	for (int x : a)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon şablonu çağrılırken şablon türleri açısal parantezler içerisinde açıkça (explicit) da belirtilebilmektedir. Bu durumda şablon parametreleri 
	argümanlardan hareketle belirlenmez.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
void foo(T a)
{
	cout << a << endl;
}

int main()
{
	foo(10);			// T = int
	foo(1.2);			// T = double
	foo<double>(100);	// T = double

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Açısal parantezler içerisinde şablon parametrelerinin açıkça belirtilmesi bazen gerekebilmektedir. Örneğin fonksiyonun şablonunun şablon parametresine 
	ilişkin bir parametre değişknei olmayabilir. Bu durumda derleyici şablonm parametresini otomatik belirleyemez.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
void foo()
{
	T a();

	cout << a << endl;
}

int main()
{
	foo();			// error!
	foo<int>()

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Örneğin bazen şablon parametresi fonksiyonun geri dönüş değerinde olabilir. Bu durumda da otomatik türs belirlemesi yapılamaz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T foo()
{
	cout << "foo" << endl;

	return T();
}

int main()
{
	int result;

	result = foo<int>();
	cout << result;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Programcı ilk n tane şablon parametresini açıkça belirtip geri kalanlarını derleyicinin tespit etmesini isteyebilir. 
	Aşağıdaki örnekte T şablon parametresi açıkça belirtilmiş ancak K şablon şablon parametresi derleyici tarafından belirlenmiştir.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T, typename K>
T foo(K a)
{
	cout << a << endl;

	return T();
}

int main()
{
	int result;

	result = foo<int>(12.3);		// T = int, K = double
	cout << result;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Aslında şablon parametreleri default değerler de alabilmektedir. Eğer bir şablon parametresi otomatik belirlenemiyorsa verilen default değerler 
	kullanılmaktadır. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T, typename K = int>
K foo(T a)
{
	cout << a << endl;

	return K();
}

int main()
{
	int result;

	result = foo(10.2);		// T = double, K = int
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir şablon fonksiyon ile aynı isimli normal fonksiyon bir arada bulunabilir. Bu durumda overload resolution işleminde normal fonksiyon eğer argüman türleri
	tam olarak uyum sağlıyorsa tercih edilmektedir. Ancak argüman türleri tam olarak uyum sağlamıyorsa fonksiyon şablonu tercih edilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
void foo(T a)
{
	cout << "template function: " << a << endl;
}

void foo(int a)
{
	cout << "non-template function: " << a << endl;
}

int main()
{
	foo(12.3);			// şablon olan 
	foo(100);			// normal fonksiyon

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıfın tamamı da şablon olarak yazılabilir. Böyle sınıflara "sınıf şablonları (class templates)" denilmektedir. Sınıf şablonları yazılırken 
	yine bir şablon bildirimi ile başlanır. Sonra normal sınıf bildirimi ile devamö edilir. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	Şablon parametresi tür belirten bir sözcük olarak sınıf bildirimin her yerinde ve tüm üye fonksiyonlarda kullanılabilir. 

	Bir sınıf şablonu mutlaka şablon parametresi açısal parantezler içerisinde belirtilerek kullanılmak zorundadır. Sınıf şablonlarında fonksiyon şablonlarında 
	olduğu gibi "otomatik şablon parametresinin tespiti" yapılmamaktadır. Şablon parametresinin mutlaka açısal parantezler içerisinde belirtilmesi gerekmektedir. 
	Örneğin:

	Sample<int> s(10);

	Bir sınıf şablonunun üye fonksiyonları sınıf içerisinde inline olarak tanımlanabilir. Ancak bu üye fonksiyonlar sınıfın dışında tanımlanacaksa şablon bildirimi
	biçiminde tanımlanmalıdır. Çünkü şablon bir sınıfın üye fonksiyonları şablon fonksiyonlar gibidir. Örneğin:

	template <typename T>
	class Sample {
	public:
		void foo();
		//...
	};

	template <typename T>
	void Sample<T>::foo()
	{
		//...
	}

	Aslında sınıf şablonunun üye fonksiyonları dışarıda yazılırken şablon parametrelerinin isimlerinin uyuşması gerekmemektedir. Ancak bu uyuşumu sağlamak iyi bir tekniktir. 
	Yani aslında biz foo üye fonksiyonunu şöyle de tanımlayabilirdik:

	template <typename K>
	void Sample<K>::foo()
	{
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
class Sample {
public:
	Sample(T val);
	void disp() const;
private:
	T m_val;
};

template <class T>
Sample<T>::Sample(T val)
{
	m_val = val;
}

template <typename T>
void Sample<T>::disp() const
{
	cout << m_val << endl;
}

int main()
{
	Sample<int> s(10);

	s.disp();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablonu aslında eğer o sınıf programda hiç kullanılmamışsa hiç "instantiate" edilmemektedir. (Biz "instantiate" sözcüğü yerine "açım", "açılma" 
	sözcüklerini de kullanıyoruz). Tabii bir sınıf şablonu açılırken aslında derleyici onun tüm üye fonksiyonlarını açmaz. Yalnızca kullanılan üye fonksiyonlarını 
	açar. 

	Aşağıdaki örnekte standart vector sınıfının birkaç fonksiyonu taklit edilmiştir. Tabii bu örnek orijinal vector sınıfının bir gerçekleştirimi değildir. 
	Orijinal vector sınıfında exception durumu için "strong guarantee" verilmektedir. Biz aşağıdaki örnekte herhangi bir exception garantisi vermiyoruz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// myvector.hpp

#ifndef MYVECTOR_HPP_H
#define MYVECTOR_HPP_H

#include <cstddef>

const int DEF_CAPACITY = 4;

template <typename T>
class myvector {
public:
	using size_type = std::size_t;

	myvector()
	{
		m_vector = new T[DEF_CAPACITY];
		m_size = 0;
		m_capacity = DEF_CAPACITY;
	}
	~myvector()
	{
		delete[] m_vector;
	}
	void push_back(const T &r);
	size_type size() const { return m_size; }
	size_type capacity() const { return m_capacity; }
	T &operator[](size_t index)
	{
		return m_vector[index];
	}
	const T &operator[](size_t index) const
	{
		return m_vector[index];
	}
private:
	T *m_vector;
	size_type m_size;
	size_type m_capacity;
};

template <typename T>
void myvector<T>::push_back(const T &r)
{
	if (m_size == m_capacity) {
		T *new_vector = new T[m_capacity * 2];
		for (size_type i = 0; i < m_size; ++i)
			new_vector[i] = m_vector[i];
		delete[] m_vector;
		m_vector = new_vector;
		m_capacity *= 2;
	}

	m_vector[m_size++] = r;
}

#endif

// app.cpp

#include <iostream>
#include "myvector.hpp"

using namespace std;

int main()
{
	myvector<int> mv;

	for (myvector<int>::size_type i = 0; i < 10; ++i)
		mv.push_back(i);

	for (myvector<int>::size_type i = 0; i < mv.size(); ++i)
		cout << mv[i] << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir sınıf şablonundan türetilebilir. Tabii bu durumda taban sınıf belirtilirken şablon parametresinin açısal parantezler içerisinde belirtilmesi gerekir. 
	örneğin:

	template <typename T>
	class A {
		//...
	};

	class B : public A<int> {
		//...
	};

	Burada B sınıfı A sınıfının int açılımından türetilmiştir. 

	Tabii bir sınıf şablonu normalk bir sınıftan da türetilebilir. Örneğin:

	class A {
		//...
	};

	template <typename T>
	class B : public A {
		//...
	};

	Bu duurmda B'nin her bir açılımı A'dan türetilmiş olmaktadır. Örneğin:

	B<int> x;
	B<double> y;
	...

	Bir sınıf şablonu başka bir sınıf şablonundan da türetilebilir. Örneğin:

	template <typename T>
	class A {
		//...
	};

	template <typename T>
	class B : public A<T> {
		//...
	};

	Burada B hangi tür ile açılırsa aslında o A'nın aynı türden açılımından türetilmiş olur. Örneğin:

	B<int> b;

	Burada B<int> sınıfı A<int> sınıfındna türetilmiştir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Normal bir sınıfın bir üye fonksiyonju bir fonksiyon şablonu olabilir. Sınıfın içerisindekli fonksiyon şablonlarına C++'ta "member template" denilmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

class Sample {
public:
	//...
	template <typename T>
	void foo(T a);				// member template
};

template <typename T>
void Sample::foo(T a)
{
	//...
}

int main()
{
	Sample s;

	s.foo(100);		// T = int
	s.foo(12.3);	// T = double

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablonun iye fonksiyonlarının zaten şablon fonksiyonlar gibi ele alındığını belirtmiştik. Ancak bir sınıf şablonunun belli üye fonksiyonları da
	ekstra biçimde şablon olabilir. Örneğin:

	template <typename T>
	class Sample {
	public:
		void foo();

		template <typename K>
		vaid bar(K a);			// member template bar içerisinde hem T hem de K kullanılabilir. 
		//...
	};

	template <typename T>
	void Sample<T>::foo()
	{
		//...
	}

	template <typename T>
	template <typename K>
	void Sample<T>::bar(K a)
	{
		//...
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
class Sample {
public:
	void foo();

	template <typename K>
	void bar(K a);			// member template bar içerisinde hem T hem de K kullanılabilir. 
	//...
};

template <typename T>
void Sample<T>::foo()
{
	//...
}

template <typename T>
template <typename K>
void Sample<T>::bar(K a)
{
	//...
}

int main()
{
	Sample<int> s;

	s.foo();
	s.bar(12.3);		// T = int, K = double

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bazen bir sınıf şablonunun özel bir tür için başka bir versiyonun yazılması istenebilir. Buna "özelleştirme (specialization)" denilmektedir. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	template <>
	class Sample<bool> {
		//...
	};

	Burada Sample sınıfının bool için özelleştirildiğini görüyorsunuz. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T> 
class Sample {
public:
	void foo()
	{
		cout << "general template foo" << endl;
	}
};

template<>
class Sample<bool> {
public:
	void foo()
	{
		cout << "bool specialization foo" << endl;
	}
};

int main()
{
	Sample<int> s;
	Sample<bool> k;

	s.foo();
	k.foo();

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablonunun her farklı türdne açımı farklı bir tür belirtmektedir. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	Sample<int> x;
	Sample<double> *y;

	y = &x;		// error! türler farklı

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Şablon fonksiyon ya da sınıf bildirimini gören derleyici hata kontrolünü iki aşamada yapmaktadır:

	1) Fonksiyon ta da sınıfı gördüğü aşamada. Burada henüz bir açım yapılmamıştır. Şablonb parametresi ne olursa olsun kodun geçerli olması gerekir. 
	örneğin aşağıdaki şablon bildiriminde daha açım yapılmadan derleyici error durumunu tespit edebilirr:

	template <typename T>
	void foo(T a)
	{
		xxxxxx		// böyle bir değişken yok! şablon parametresi ne olursa olsun burada bir error söz konusudr.
	}

	2) Açım (instantiation) sırasında. Şablonb parametrelerinin açım sırasında fonksiyon ya da sınıf şablonlarının koduna uygun olması gerekir. Örneğin iki değerin
	küçüğünü veren aşağıdaki gibi bir fonksiyon şablonu olsun:

	template <typename T>
	T minval(const T &a, const T &b)
	{
		if (a < b)
			return a;

		return b;
	}

	Burada bu fonksiyonu biz int türüyle açabiliriz. Ancak < operatör fonksiyonu olmayan bir sınıfla açmaya çalışsak açım sırasında error oluşacaktır.
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>

using namespace std;

template <typename T>
T minval(const T &a, const T &b)
{
	if (a < b)
		return a;

	return b;
}

class Number {
public:
	Number() = default;
	Number(int a) : m_a(a)
	{}
	bool operator <(const Number &r) const
	{
		return m_a < r.m_a;
	}
	friend ostream &operator <<(ostream &os, const Number &n)
	{
		os << n.m_a;

		return os;
	}
private:
	int m_a;
};

int main()
{
	int x;

	x = minval(10, 20);
	cout << x << endl;

	Number y;
	Number a(10), b(20);

	y = minval(a, b);

	cout << y << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Bir sınıf şablocu her zaman kullanılırken açım türü belirtilerek kullanılmalıdır. Örneğin:

	template <typename T>
	class Sample {
		//...
	};

	Sample s;			// error!
	Sample<int> k;		// geçerli

	Ancak istisna olarak bir sınıf şablonu sınıf bildirimi içerisinde ve sınıfın üye fonksiyonları içerisinde açım türü belirtilmeden kullanılabilir. Bu durumda
	açım türünün şablon türleri olduğu kabul edilir. Örneğin:

	template <typename T>
	class Sample {
	public:
		void foo();
		//...
	};

	template <typename T>
	void Sample<T>::foo()
	{
		Sample a;		// geçerli, Sample<T> ile eşdeğer.
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	C++'ın standart kütüphanesi hep fonksiyon ve sınıf şablonlarından oluşmaktadır. Örneğin aslında string sınıfı diye bir sınıf yoktur. Sınııfn asıl hali, 
	string'in karakterlerinin hangi türle ifade edileceğini de belirten şablon basic_string<T> sınıfıdır. string ismi aslında aşağıdaki gibi bir typedef 
	ismidir:

	typedef basic_string<char> string;

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanede veri yapılarını temsil eden bir grup sınıfa "nesne tutan sınıflar (container classes)" denilmektedir. Biz daha önce nesne tutan sınıf olarak 
	vector<T> sınıfını görmüştük. Diğer önemli bir nesne tutan sınıf da list<T> isimli sınıftır. list sınıfı "bağlı liste (linked list)" denilen veri yapısını 
	gerçekleştirmek için kullanılmaktadır. Bağlı listeler önceki elemanın sonraki elemanını, sonraki elemanın da önceki elemanını gösterdiği özel veri yapılarıdır. 
	Bağlı listenin elemanları bellekte ardışıl bulunmaz. Bağlı listelerde belli bir elemana erişmek için önceki elemanları da dolaşmak gerekir. 

	list<T> nesnesinin sonuna eleman eklemek için yine push_back fonksiyonu kullanılmaktadır. list nesnesinin elemanları aralık tabanlı for döngüleriyle dolaşılabilir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <list>

using namespace std;

int main()
{
	list<int> a;

	for (int i = 0; i < 100; ++i)
		a.push_back(i);

	for (int x : a)
		cout << x << " ";
	cout << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    list nesnesinin elemanları iteratör yoluyla da dolaşılabilmektedir. Daha önceden de belirttiğimiz gibi "iteratör" bir gösterici gibi kullanılan nesnelerdir. 
	Nesnenin başlangıç iteratörü begin üye fonksiyonuyla son elemandan sonraki iteratörü end üye fonksiyonuyla elde edilmektedir. list sınıfının kullandığı iteratörün
	türü sınıf içerisinde list<T>::iterator typedef ismiyle temsil edilmektedir. iteratör yoluyla list nesnesinin dolaşılmasının tipik kalıbı şöyledir:

	for (list<T>::iterator iter = a.begin(); iter != a.end(); ++iter) {
		//...
	}
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <list>

using namespace std;

int main()
{
	list<int> a;

	for (int i = 0; i < 100; ++i)
		a.push_back(i);

	for (list<int>::iterator iter = a.begin(); iter != a.end(); ++iter)
		cout << *iter << " ";
	cout << endl;

	for (auto iter = a.begin(); iter != a.end(); ++iter)
		cout << *iter << " ";
	cout << endl;
		
	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanede özel algoritmik bir yapı ile elemanları tutan bir grup nesne tutan sınıf da vardır. Bunlara İngilizce "associative containers" denilmektedir.
	Bunların listesi şöyledir:

	map<Key, Value>
	set<T>
	multimap<Key, Value>
	multiset<T>
	unordered_map<Key, Value>
	unordered_set<T>
	unordered_multimap<Key, Value>
	unordered_multiset<Key>

	Bu sınıfların aslında başka default değer alan şablon parametreleri de vardır. 

	map sınıfı en fazla kullanılan "associative container" sınıftır. Sınıf ahanat değer çiftlerini tutar. Anahtar verildiğinde değeri hızlı bir biçimde verir. 
	Sınıf iteratör yoluyla dolaşıldığında sıralı bir biçimde dolaşılmaktadır. Tipik olarak "dengelenmiş ikili ağaç (balanced binary tree)" biçiminde gerçekleştirilmektedir. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <map>

using namespace std;

int main()
{
	map<int, string> m;

	m[123] = "ali";
	m[100] = "veli";
	m[420] = "selami";
	m[53] = "ayse";
	m[132] = "fatma";

	string result;

	result = m[420];
	cout << result << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
	Bir map nesnesi iteratör yoluyla dolaşılırken anahtar-değer çiftleri pair isimli bir sınıf nesnesi olarak elde edilir. pair<T, K> iki şablon parametresine
	sahip bir sınıftır. Sınıfın first veri elemanı nesnein ilk elemanını, secod veri elemanı ise ikinci elemanını belirtmektedir. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <iostream>
#include <string>
#include <map>

using namespace std;

int main()
{
	map<int, string> m;

	m[123] = "ali";
	m[100] = "veli";
	m[420] = "selami";
	m[53] = "ayse";
	m[132] = "fatma";

	for (map<int, string>::iterator iter = m.begin(); iter != m.end(); ++iter)
		cout << iter->first << endl;

	for (auto iter = m.begin(); iter != m.end(); ++iter)
		cout << iter->first << endl;

	return 0;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
    
--------------------------------------------------------------------------------------------------------------------------------------------------------------*/

